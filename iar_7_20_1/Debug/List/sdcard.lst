###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.2.160/W32 for ARM         14/Oct/2018  14:43:39
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\drivers\sdcard.c
#    Command line =  
#        -f C:\Users\BUDWA_~1\AppData\Local\Temp\EWE201.tmp
#        (C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\drivers\sdcard.c
#        -D EIE1 --preprocess=c
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List
#        -lC
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List
#        -o
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\ -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\bsp\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\drivers\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\application\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.1\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List\sdcard.lst
#    Object file  =  
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\Obj\sdcard.o
#
###############################################################################

C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\drivers\sdcard.c
      1          /**********************************************************************************************************************
      2          File: sdcard.c                                                                
      3          
      4          Description:
      5          SD card interface application.  This task looks for an SD card and initializes it so it is ready
      6          to receive data read / write commands.  
      7          
      8          API
      9          Client applications may use the following functions to access this driver:
     10          
     11          SdGetStatus() - returns a variable of type SdCardStateType which may have the following value:
     12            SD_NO_CARD: no card is inserted.
     13            SD_CARD_ERROR: an inserted card has an error.
     14            SD_IDLE: card is ready and waiting for a read or a write to be requested.
     15            SD_READING: the card is being read and is not available for anything else 
     16            SD_DATA_READY: a sector of data has been requested from the SD card is ready for the client.
     17            SD_WRITING: the card is being written and is not available for anything else
     18          
     19          bool SdReadBlock(u32 u32SectorAddress_) - initiates read of one 512 byte block of memory from the SD card.
     20          Returns TRUE if the card is available and can start reading. 
     21          User must use SdGetStatus() and wait until the card status is SD_DATA_READY which means the read is done.
     22          
     23          bool SdWriteBlock(u32 u32BlockAddress_) - not yet implemented
     24          
     25          bool SdGetReadData(u8* pu8Destination_) - transfers the read data to the client.  The card state will return to SD_IDLE.
     26          
     27          
     28          **********************************************************************************************************************/
     29          
     30          #include "configuration.h"
     31          
     32          /***********************************************************************************************************************
     33          Global variable definitions with scope across entire project.
     34          All Global variable names shall start with "G_"
     35          ***********************************************************************************************************************/
     36          /* New variables */

   \                                 In section .bss, align 4
     37          volatile u32 G_u32SdCardFlags;                         /* Global state flags */
   \                     G_u32SdCardFlags:
   \        0x0                      DS8 4
     38          
     39          
     40          /*--------------------------------------------------------------------------------------------------------------------*/
     41          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     42          extern volatile u32 G_u32SystemFlags;                  /* From main.c */
     43          extern volatile u32 G_u32ApplicationFlags;             /* From main.c */
     44          
     45          extern volatile u32 G_u32SystemTime1ms;                /* From board-specific source file */
     46          extern volatile u32 G_u32SystemTime1s;                 /* From board-specific source file */
     47          
     48          
     49          /***********************************************************************************************************************
     50          Global variable definitions with scope limited to this local application.
     51          Variable names shall start with "SD_" and be declared as static.
     52          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     53          static fnCode_type SD_pfStateMachine;              /* The Debug state machine function pointer */
   \                     SD_pfStateMachine:
   \        0x0                      DS8 4
     54          

   \                                 In section .bss, align 4
     55          static u32 SD_u32Flags;                            /* Application flags for SD card */
   \                     SD_u32Flags:
   \        0x0                      DS8 4

   \                                 In section .bss, align 1
     56          static SdCardStateType SD_CardState;               /* Card state variable */
   \                     SD_CardState:
   \        0x0                      DS8 1
     57          

   \                                 In section .bss, align 1
     58          static u8  SD_u8ErrorCode;                         /* Error code */
   \                     SD_u8ErrorCode:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
     59          static fnCode_type SD_pfWaitReturnState;           /* The saved state to return after a wait period */
   \                     SD_pfWaitReturnState:
   \        0x0                      DS8 4
     60          //static u8* SD_NextCommand;                         /* Saved command to be executed next */
     61          

   \                                 In section .bss, align 4
     62          static SspConfigurationType SD_sSspConfig;         /* Configuration information for SSP peripheral */
   \                     SD_sSspConfig:
   \        0x0                      DS8 36

   \                                 In section .bss, align 4
     63          static SspPeripheralType* SD_Ssp;                  /* Pointer to SSP peripheral object */
   \                     SD_Ssp:
   \        0x0                      DS8 4
     64          

   \                                 In section .bss, align 4
     65          static u8 SD_au8RxBuffer[SDCARD_RX_BUFFER_SIZE];   /* Space for incoming bytes from the SD card */
   \                     SD_au8RxBuffer:
   \        0x0                      DS8 548
     66          static u8 *SD_pu8RxBufferNextByte;                 /* Pointer to next spot in RxBuffer to write a byte */
                            ^
Warning[Pe177]: variable "SD_pu8RxBufferNextByte" was declared but never
          referenced
     67          //static u8 *SD_pu8RxBufferParser;                   /* Pointer to loop through the Rx buffer to read bytes */
     68          

   \                                 In section .bss, align 4
     69          static u32 SD_u32Timeout;                          /* Timeout counter used across states */
   \                     SD_u32Timeout:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     70          static u32 SD_u32CurrentMsgToken;                  /* Token of message currently being sent */
   \                     SD_u32CurrentMsgToken:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     71          static u32 SD_u32Address;                          /* Current read/write sector address */
   \                     SD_u32Address:
   \        0x0                      DS8 4
     72          
     73          static u8 SD_au8CardInMessage[]    = "SD card inserted\n\r";
                           ^
Warning[Pe177]: variable "SD_au8CardInMessage" was declared but never
          referenced

   \                                 In section .data, align 4
     74          static u8 SD_au8SspRequestFailed[] = "SdCard denied SSP\n\r";
   \                     SD_au8SspRequestFailed:
   \        0x0   0x53 0x64          DC8 "SdCard denied SSP\012\015"
   \              0x43 0x61    
   \              0x72 0x64    
   \              0x20 0x64    
   \              0x65 0x6E    
   \              0x69 0x65    
   \              0x64 0x20    
   \              0x53 0x53    
   \              0x50 0x0A    
   \              0x0D 0x00    

   \                                 In section .data, align 4
     75          static u8 SD_au8CardReady[]        = "SD ready\n\r";
   \                     SD_au8CardReady:
   \        0x0   0x53 0x44          DC8 "SD ready\012\015"
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x0A 0x0D    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .data, align 4
     76          static u8 SD_au8CardError[]        = "SD error: ";
   \                     SD_au8CardError:
   \        0x0   0x53 0x44          DC8 "SD error: "
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x3A 0x20    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .data, align 4
     77          static u8 SD_au8CardError0[]       = "UNKNOWN\n\r";
   \                     SD_au8CardError0:
   \        0x0   0x55 0x4E          DC8 "UNKNOWN\012\015"
   \              0x4B 0x4E    
   \              0x4F 0x57    
   \              0x4E 0x0A    
   \              0x0D 0x00    
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .data, align 4
     78          static u8 SD_au8CardError1[]       = "TIMEOUT\n\r";
   \                     SD_au8CardError1:
   \        0x0   0x54 0x49          DC8 "TIMEOUT\012\015"
   \              0x4D 0x45    
   \              0x4F 0x55    
   \              0x54 0x0A    
   \              0x0D 0x00    
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .data, align 4
     79          static u8 SD_au8CardError2[]       = "CARD_VOLTAGE\n\r ";
   \                     SD_au8CardError2:
   \        0x0   0x43 0x41          DC8 "CARD_VOLTAGE\012\015 "
   \              0x52 0x44    
   \              0x5F 0x56    
   \              0x4F 0x4C    
   \              0x54 0x41    
   \              0x47 0x45    
   \              0x0A 0x0D    
   \              0x20 0x00    

   \                                 In section .data, align 4
     80          static u8 SD_au8CardError3[]       = "BAD_RESPONSE\n\r ";
   \                     SD_au8CardError3:
   \        0x0   0x42 0x41          DC8 "BAD_RESPONSE\012\015 "
   \              0x44 0x5F    
   \              0x52 0x45    
   \              0x53 0x50    
   \              0x4F 0x4E    
   \              0x53 0x45    
   \              0x0A 0x0D    
   \              0x20 0x00    

   \                                 In section .data, align 4
     81          static u8 SD_au8CardError4[]       = "NO_TOKEN\n\r";
   \                     SD_au8CardError4:
   \        0x0   0x4E 0x4F          DC8 "NO_TOKEN\012\015"
   \              0x5F 0x54    
   \              0x4F 0x4B    
   \              0x45 0x4E    
   \              0x0A 0x0D    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .data, align 4
     82          static u8 SD_au8CardError5[]       = "NO_SD_TOKEN\n\r";
   \                     SD_au8CardError5:
   \        0x0   0x4E 0x4F          DC8 "NO_SD_TOKEN\012\015"
   \              0x5F 0x53    
   \              0x44 0x5F    
   \              0x54 0x4F    
   \              0x4B 0x45    
   \              0x4E 0x0A    
   \              0x0D 0x00    
   \        0xE   0x00 0x00          DC8 0, 0
     83          
     84          

   \                                 In section .data, align 4
     85          static u8 SD_au8CMD0[]   = {SD_HOST_CMD | SD_CMD0,  0, 0, 0, 0, SD_CMD0_CRC};
   \                     SD_au8CMD0:
   \        0x0   0x40 0x00          DC8 64, 0, 0, 0, 0, 149, 0, 0
   \              0x00 0x00    
   \              0x00 0x95    
   \              0x00 0x00    

   \                                 In section .data, align 4
     86          static u8 SD_au8CMD8[]   = {SD_HOST_CMD | SD_CMD8,  0, 0, SD_VHS_VALUE, SD_CHECK_PATTERN, SD_CMD8_CRC};
   \                     SD_au8CMD8:
   \        0x0   0x48 0x00          DC8 72, 0, 0, 1, 170, 135, 0, 0
   \              0x00 0x01    
   \              0xAA 0x87    
   \              0x00 0x00    

   \                                 In section .data, align 4
     87          static u8 SD_au8CMD16[]  = {SD_HOST_CMD | SD_CMD16, 0, 0, 0x02, 0x00, SD_NO_CRC};
   \                     SD_au8CMD16:
   \        0x0   0x50 0x00          DC8 80, 0, 0, 2, 0, 1, 0, 0
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x00    

   \                                 In section .data, align 4
     88          static u8 SD_au8CMD17[]  = {SD_HOST_CMD | SD_CMD17, 0, 0, 0, 0, SD_NO_CRC};
   \                     SD_au8CMD17:
   \        0x0   0x51 0x00          DC8 81, 0, 0, 0, 0, 1, 0, 0
   \              0x00 0x00    
   \              0x00 0x01    
   \              0x00 0x00    

   \                                 In section .data, align 4
     89          static u8 SD_au8CMD55[]  = {SD_HOST_CMD | SD_CMD55, 0, 0, 0 ,0, SD_NO_CRC};
   \                     SD_au8CMD55:
   \        0x0   0x77 0x00          DC8 119, 0, 0, 0, 0, 1, 0, 0
   \              0x00 0x00    
   \              0x00 0x01    
   \              0x00 0x00    

   \                                 In section .data, align 4
     90          static u8 SD_au8CMD58[]  = {SD_HOST_CMD | SD_CMD58, 0, 0, 0 ,0, SD_NO_CRC};
   \                     SD_au8CMD58:
   \        0x0   0x7A 0x00          DC8 122, 0, 0, 0, 0, 1, 0, 0
   \              0x00 0x00    
   \              0x00 0x01    
   \              0x00 0x00    
     91          

   \                                 In section .data, align 4
     92          static u8 SD_au8ACMD41[] = {SD_HOST_CMD | SD_ACMD41,0, 0, 0, 0, SD_NO_CRC};
   \                     SD_au8ACMD41:
   \        0x0   0x69 0x00          DC8 105, 0, 0, 0, 0, 1, 0, 0
   \              0x00 0x00    
   \              0x00 0x01    
   \              0x00 0x00    
     93          
     94          
     95          /**********************************************************************************************************************
     96          Function Definitions
     97          **********************************************************************************************************************/
     98          
     99          /*--------------------------------------------------------------------------------------------------------------------*/
    100          /* Public Functions */
    101          /*--------------------------------------------------------------------------------------------------------------------*/
    102          
    103          /*----------------------------------------------------------------------------------------------------------------------
    104          Function: SdIsCardInserted
    105          
    106          Description:
    107          Updates and indicates whether or not an SD card is currently inserted.
    108          
    109          Requires:
    110            - 
    111          
    112          Promises:
    113            - Returns TRUE if card is inserted; otherwise returns FALSE 
    114            - _SD_CARD_INSERTED is updated (SET if card is in)
    115          */

   \                                 In section .text, align 2, keep-with-next
    116          bool SdIsCardInserted(void)
    117          {
    118            if( SD_CARD_INSERTED() )
   \                     SdIsCardInserted: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x400e0c3c
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x0740             LSLS     R0,R0,#+29
   \        0x8   0xD407             BMI.N    ??SdIsCardInserted_0
    119            {
    120              SD_u32Flags |= _SD_CARD_INSERTED;
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x14   0x6001             STR      R1,[R0, #+0]
    121              return TRUE;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xE00A             B.N      ??SdIsCardInserted_1
    122            }
    123            else
    124            {
    125              SD_u32Flags &= ~_SD_CARD_INSERTED;
   \                     ??SdIsCardInserted_0: (+1)
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \       0x1E   0x6801             LDR      R1,[R0, #+0]
   \       0x20   0x0849             LSRS     R1,R1,#+1
   \       0x22   0x0049             LSLS     R1,R1,#+1
   \       0x24   0x6001             STR      R1,[R0, #+0]
    126              SD_CardState = SD_NO_CARD;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x.... 0x....      LDR.W    R1,??DataTable26_2
   \       0x2C   0x7008             STRB     R0,[R1, #+0]
    127              return FALSE;
   \       0x2E   0x2000             MOVS     R0,#+0
   \                     ??SdIsCardInserted_1: (+1)
   \       0x30   0x4770             BX       LR               ;; return
    128            }
    129            
    130          } /* end SdIsCardInserted() */
    131          
    132          
    133          /*----------------------------------------------------------------------------------------------------------------------
    134          Function: SdGetStatus
    135          
    136          Description:
    137          Reports the current status of the SD card.
    138          
    139          SD_NO_CARD: no card is inserted.
    140          SD_CARD_ERROR: an inserted card has an error.
    141          SD_IDLE: card is ready and waiting for a read or a write to be requested.
    142          SD_READING: the card is being read and is not available for anything else 
    143          SD_DATA_READY: a sector of data has been requested from the SD card is ready for the client.
    144          SD_WRITING: the card is being written and is not available for anything else
    145          
    146          Requires:
    147            - SD_CardState up to date.
    148          
    149          Promises:
    150            - Returns SD_CardState
    151          */

   \                                 In section .text, align 2, keep-with-next
    152          SdCardStateType SdGetStatus(void)
    153          {
    154            return SD_CardState;
   \                     SdGetStatus: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0x4770             BX       LR               ;; return
    155            
    156          } /* end SdGetStatus() */
    157          
    158          
    159          /*----------------------------------------------------------------------------------------------------------------------
    160          Function: SdReadBlock
    161          
    162          Description:
    163          Reads a block at the sector address provided.
    164          Byte-addressable cards are automatically converted appropriately so user does not have to distinguish
    165          and can always read by 512 byte block.
    166          
    167          Requires:
    168            - _SD_TYPE_SD1, _SD_TYPE_SD2, _SD_CARD_HC are correctly set/clear to indicate card type.
    169            - u32SectorAddress_ is a valid SD card address
    170          
    171          Promises:
    172            - If the card is currently SD_IDLE, initiates the read, changes card state to "SD_READING" and returns TRUE.
    173          */

   \                                 In section .text, align 2, keep-with-next
    174          bool SdReadBlock(u32 u32SectorAddress_)
    175          {
   \                     SdReadBlock: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0001             MOVS     R1,R0
    176            if(SD_CardState == SD_IDLE)
   \        0x4   0x.... 0x....      LDR.W    R2,??DataTable26_2
   \        0x8   0x7810             LDRB     R0,[R2, #+0]
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xD110             BNE.N    ??SdReadBlock_0
    177            {
    178              /* Capture the card address of interest with adjustment for byte-accessed cards as required */
    179              SD_u32Address = u32SectorAddress_;
   \        0xE   0x.... 0x....      LDR.W    R3,??DataTable26_3
   \       0x12   0x6019             STR      R1,[R3, #+0]
    180              if( !(SD_u32Flags & _SD_CARD_HC) )
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \       0x18   0x7800             LDRB     R0,[R0, #+0]
   \       0x1A   0x0740             LSLS     R0,R0,#+29
   \       0x1C   0xD404             BMI.N    ??SdReadBlock_1
    181              {
    182                SD_u32Address *= 512;
   \       0x1E   0x681C             LDR      R4,[R3, #+0]
   \       0x20   0xF44F 0x7000      MOV      R0,#+512
   \       0x24   0x4344             MULS     R4,R0,R4
   \       0x26   0x601C             STR      R4,[R3, #+0]
    183              }
    184              
    185              /* Update the card state which will trigger the start of the read sequence */
    186              SD_CardState = SD_READING;
   \                     ??SdReadBlock_1: (+1)
   \       0x28   0x2003             MOVS     R0,#+3
   \       0x2A   0x7010             STRB     R0,[R2, #+0]
    187              return TRUE;
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xE000             B.N      ??SdReadBlock_2
    188            }
    189            
    190            return FALSE;
   \                     ??SdReadBlock_0: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \                     ??SdReadBlock_2: (+1)
   \       0x32   0xBC10             POP      {R4}
   \       0x34   0x4770             BX       LR               ;; return
    191            
    192          } /* end SdReadBlock() */
    193          
    194          
    195          /*----------------------------------------------------------------------------------------------------------------------
    196          Function: SdWriteBlock
    197          
    198          Description:
    199          Writes a block at the address provided.
    200          
    201          Requires:
    202            - 
    203          
    204          Promises:
    205            - 
    206          */

   \                                 In section .text, align 2, keep-with-next
    207          bool SdWriteBlock(u32 u32BlockAddress_)
    208          {
   \                     SdWriteBlock: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    209            return FALSE;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x4770             BX       LR               ;; return
    210              
    211          } /* end SdWriteBlock() */
    212          
    213          
    214          /*----------------------------------------------------------------------------------------------------------------------
    215          Function: SdGetReadData
    216          
    217          Description:
    218          Transfers the data that was just read from the card.
    219          
    220          Requires:
    221            - pu8Destination points to the start of a 512 byte buffer where the data will be read.
    222            - The 512 bytes of data that was just read is at SD_au8RxBuffer[0] thru SD_au8RxBuffer[511] -
    223              this will set SD_CardState to SD_DATA_READY.
    224          
    225          Promises:
    226            - if SD_CardState = SD_DATA_READY, loads 512 bytes to pu8Destination_ and returns TRUE
    227            - else returns FALSE
    228          */

   \                                 In section .text, align 2, keep-with-next
    229          bool SdGetReadData(u8* pu8Destination_)
    230          {
   \                     SdGetReadData: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    231            /* To ensure data integrity, card state must be SD_DATA_READY */
    232            if(SD_CardState == SD_DATA_READY)
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \        0x6   0x7802             LDRB     R2,[R0, #+0]
   \        0x8   0x2A04             CMP      R2,#+4
   \        0xA   0xD112             BNE.N    ??SdGetReadData_0
    233            {
    234              SD_CardState = SD_IDLE;
   \        0xC   0x2202             MOVS     R2,#+2
   \        0xE   0x7002             STRB     R2,[R0, #+0]
    235          
    236              for(u16 i = 0; i < 512; i++)
   \       0x10   0x2000             MOVS     R0,#+0
   \                     ??SdGetReadData_1: (+1)
   \       0x12   0x0002             MOVS     R2,R0
   \       0x14   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \       0x16   0xF5B2 0x7F00      CMP      R2,#+512
   \       0x1A   0xDA08             BGE.N    ??SdGetReadData_2
    237              {
    238                *pu8Destination_ = SD_au8RxBuffer[i];
   \       0x1C   0x.... 0x....      LDR.W    R2,??DataTable26_4
   \       0x20   0x0003             MOVS     R3,R0
   \       0x22   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \       0x24   0x5CD2             LDRB     R2,[R2, R3]
   \       0x26   0x700A             STRB     R2,[R1, #+0]
    239                pu8Destination_++;
   \       0x28   0x1C49             ADDS     R1,R1,#+1
    240              }
   \       0x2A   0x1C40             ADDS     R0,R0,#+1
   \       0x2C   0xE7F1             B.N      ??SdGetReadData_1
    241              
    242              return TRUE;
   \                     ??SdGetReadData_2: (+1)
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xE000             B.N      ??SdGetReadData_3
    243            }
    244            /* Otherwise return FALSE */
    245            else
    246            {
    247              return FALSE;
   \                     ??SdGetReadData_0: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \                     ??SdGetReadData_3: (+1)
   \       0x34   0x4770             BX       LR               ;; return
    248            }
    249              
    250          } /* end SdGetReadData() */
    251          
    252          
    253          /*--------------------------------------------------------------------------------------------------------------------*/
    254          /* Protected Functions */
    255          /*--------------------------------------------------------------------------------------------------------------------*/
    256          
    257          /*--------------------------------------------------------------------------------------------------------------------
    258          Function: SdCardInitialize
    259          
    260          Description:
    261          Initializes the State Machine and its variables.
    262          
    263          Requires:
    264            -
    265          
    266          Promises:
    267            - 
    268          */

   \                                 In section .text, align 2, keep-with-next
    269          void SdCardInitialize(void)
    270          {
   \                     SdCardInitialize: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
    271          #ifdef ENABLE_SD
    272            u8 au8SdCardStartedMsg[] = "SdCard task ready\n\r";
    273          
    274            /* Reset the receive buffer to dummies for a known starting state */
    275            memset(SD_au8RxBuffer, SSP_DUMMY_BYTE, SDCARD_RX_BUFFER_SIZE);
    276          
    277            /* Initailze startup values and the command array */
    278            SD_pu8RxBufferNextByte = &SD_au8RxBuffer[0];
    279          
    280            /* Configure the SSP resource to be used for the SD Card application */
    281            SD_sSspConfig.SspPeripheral      = SD_SSP;
    282            SD_sSspConfig.pCsGpioAddress     = SD_BASE_PORT;
    283            SD_sSspConfig.u32CsPin           = SD_CS_PIN;
    284            SD_sSspConfig.pu8RxBufferAddress = SD_au8RxBuffer;
    285            SD_sSspConfig.ppu8RxNextByte     = &SD_pu8RxBufferNextByte;
    286            SD_sSspConfig.u16RxBufferSize    = SDCARD_RX_BUFFER_SIZE;
    287            SD_sSspConfig.eBitOrder          = MSB_FIRST;
    288            SD_sSspConfig.eSspMode           = SPI_MASTER_MANUAL_CS;
    289            
    290            /* Always start in SdCardSM_IdleNoCard but display different message if card is already in */
    291            SD_pfStateMachine = SdCardSM_IdleNoCard;
    292            DebugPrintf(au8SdCardStartedMsg);
    293          
    294            if( SdIsCardInserted() )
    295            {
    296              DebugPrintf(SD_au8CardInMessage);
    297            }
    298          
    299            G_u32ApplicationFlags |= _APPLICATION_FLAGS_SDCARD;
    300          #else /* ENABLE_SD */
    301            u8 au8SdCardStartedMsg[] = "SdCard task disabled\n\r";
   \        0x4   0x4668             MOV      R0,SP
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \        0xA   0x2217             MOVS     R2,#+23
   \        0xC   0x.... 0x....      BL       __aeabi_memcpy
    302          
    303            G_u32ApplicationFlags |= _APPLICATION_FLAGS_SDCARD;
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0xF051 0x0180      ORRS     R1,R1,#0x80
   \       0x1A   0x6001             STR      R1,[R0, #+0]
    304            SD_pfStateMachine = SdCardSM_Disabled;
   \       0x1C   0x.... 0x....      ADR.W    R0,SdCardSM_Disabled
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x24   0x6008             STR      R0,[R1, #+0]
    305            DebugPrintf(au8SdCardStartedMsg);
   \       0x26   0x4668             MOV      R0,SP
   \       0x28   0x.... 0x....      BL       DebugPrintf
    306          #endif /* ENABLE_SD */
    307          } /* end SdCardInitialize() */
   \       0x2C   0xB007             ADD      SP,SP,#+28
   \       0x2E   0xBD00             POP      {PC}             ;; return
    308          
    309          
    310          /*----------------------------------------------------------------------------------------------------------------------
    311          Function SdCardRunActiveState()
    312          
    313          Description:
    314          Selects and runs one iteration of the current state in the state machine.
    315          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    316          may take 1ms / n to execute.
    317          
    318          Requires:
    319            - State machine function pointer points at current state
    320          
    321          Promises:
    322            - Calls the function to pointed by the state machine function pointer
    323          */

   \                                 In section .text, align 2, keep-with-next
    324          void SdCardRunActiveState(void)
    325          {
   \                     SdCardRunActiveState: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    326            SD_pfStateMachine();
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable26_7
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x4780             BLX      R0
    327          
    328          } /* end SdCardRunActiveState */
   \        0xA   0xBD01             POP      {R0,PC}          ;; return
    329          
    330          
    331          /*--------------------------------------------------------------------------------------------------------------------*/
    332          /* Private functions */
    333          /*--------------------------------------------------------------------------------------------------------------------*/
    334          
    335          /*--------------------------------------------------------------------------------------------------------------------
    336          Function: SdCommand
    337          
    338          Description:
    339          Queues a command and sets up the application to read the response when it arrives.
    340          
    341          Requires:
    342            - No other commands should be queued for the SSP peripheral being used.
    343            - All commands have the same size, SD_CMD_SIZE which include an extra byte which is the first
    344              read back for the response.
    345            - pau8Command_ is a pointer to the first byte of the command byte array
    346          
    347          Promises:
    348            - Requested command is queued to the SSP peripheral
    349            - SD_u32CurrentMsgToken updated with the corresponding message token
    350            - SD_u32Timeout loaded to start counting the timeout period for the command
    351            - State machine set to wait command
    352          */

   \                                 In section .text, align 2, keep-with-next
    353          void SdCommand(u8* pau8Command_)
    354          {
   \                     SdCommand: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    355            /* Queue the transmit message with this command */
    356            SD_u32CurrentMsgToken = SspWriteData(SD_Ssp, SD_CMD_SIZE, pau8Command_);
   \        0x4   0x.... 0x....      LDR.W    R6,??DataTable26_8
   \        0x8   0x.... 0x....      LDR.W    R5,??DataTable26_9
   \        0xC   0x0022             MOVS     R2,R4
   \        0xE   0x2106             MOVS     R1,#+6
   \       0x10   0x6828             LDR      R0,[R5, #+0]
   \       0x12   0x.... 0x....      BL       SspWriteData
   \       0x16   0x6030             STR      R0,[R6, #+0]
    357            if(SD_u32CurrentMsgToken)
   \       0x18   0x6830             LDR      R0,[R6, #+0]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD00E             BEQ.N    ??SdCommand_0
    358            {
    359              SspAssertCS(SD_Ssp);
   \       0x1E   0x6828             LDR      R0,[R5, #+0]
   \       0x20   0x.... 0x....      BL       SspAssertCS
    360          
    361              /* Set up time-outs and next state */
    362              SD_u32Timeout = G_u32SystemTime1ms;
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0x.... 0x....      LDR.W    R1,??DataTable26_11
   \       0x2E   0x6008             STR      R0,[R1, #+0]
    363              SD_pfStateMachine = SdCardSM_WaitCommand;
   \       0x30   0x.... 0x....      ADR.W    R0,SdCardSM_WaitCommand
   \       0x34   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x38   0x6008             STR      R0,[R1, #+0]
   \       0x3A   0xE008             B.N      ??SdCommand_1
    364            }
    365            else
    366            {
    367              /* We didn't get a return token, so abort */
    368              SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \                     ??SdCommand_0: (+1)
   \       0x3C   0x2004             MOVS     R0,#+4
   \       0x3E   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \       0x42   0x7008             STRB     R0,[R1, #+0]
    369              SD_pfStateMachine = SdCardSM_Error;
   \       0x44   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x48   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x4C   0x6008             STR      R0,[R1, #+0]
    370            }
    371              
    372          } /* end SdCommand() */
   \                     ??SdCommand_1: (+1)
   \       0x4E   0xBD70             POP      {R4-R6,PC}       ;; return
    373          
    374          
    375          /*--------------------------------------------------------------------------------------------------------------------
    376          Function: CheckTimeout
    377          
    378          Description:
    379          Checks on timeout and updates the state machine if required.
    380          
    381          Requires:
    382            - State machine is running through states where timeouts are frequently checked and where the result of
    383              a timeout should be a timeout error and redirection to the error state.
    384            - u32Time_ is ms count for timeout
    385            - SD_u32Timeout is the reference time
    386          
    387          Promises:
    388            - if the timeout has occured, sets the erorr code and directs the SM to SdCardSM_Error state
    389          */

   \                                 In section .text, align 2, keep-with-next
    390          void CheckTimeout(u32 u32Time_)
    391          {
   \                     CheckTimeout: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    392            if( IsTimeUp(&SD_u32Timeout, u32Time_) )
   \        0x4   0x0021             MOVS     R1,R4
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable26_11
   \        0xA   0x.... 0x....      BL       IsTimeUp
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD008             BEQ.N    ??CheckTimeout_0
    393            {
    394              SD_u8ErrorCode = SD_ERROR_TIMEOUT;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \       0x18   0x7008             STRB     R0,[R1, #+0]
    395              SD_pfStateMachine = SdCardSM_Error;
   \       0x1A   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x1E   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x22   0x6008             STR      R0,[R1, #+0]
    396            }
    397          
    398          } /* end CheckTimeout() */
   \                     ??CheckTimeout_0: (+1)
   \       0x24   0xBD10             POP      {R4,PC}          ;; return
    399          
    400          #if 0
    401          /*--------------------------------------------------------------------------------------------------------------------
    402          Function: AdvanceSD_pu8RxBufferParser
    403          
    404          Description:
    405          Safely advances SD_pu8RxBufferParser by the number of bytes required.
    406          
    407          Requires:
    408            - u32NumBytes_ is the number of bytes that the buffer pointer will be advanced
    409          
    410          Promises:
    411            - SD_pu8RxBufferParser moved u32NumBytes_ with wrap-around protection.
    412          */
    413          void AdvanceSD_pu8RxBufferParser(u32 u32NumBytes_)
    414          {
    415            for(u32 i = 0; i < u32NumBytes_; i++)
    416            {
    417              SD_pu8RxBufferParser++;
    418              if(SD_pu8RxBufferParser == &SD_au8RxBuffer[SDCARD_RX_BUFFER_SIZE])
    419              {
    420                SD_pu8RxBufferParser = &SD_au8RxBuffer[0];
    421              }
    422            }
    423            
    424          } /* end AdvanceSD_pu8RxBufferParser() */
    425          
    426          
    427          /*--------------------------------------------------------------------------------------------------------------------
    428          Function: FlushSdRxBuffer
    429          
    430          Description:
    431          Skips all new bytes currently in the RxBuffer.
    432          
    433          Requires:
    434            - 
    435          
    436          Promises:
    437            - SD_pu8RxBufferParser set to SD_pu8RxBufferNextByte
    438          */
    439          void FlushSdRxBuffer(void)
    440          {
    441            SD_pu8RxBufferParser = SD_pu8RxBufferNextByte;
    442            
    443          } /* end FlushSdRxBuffer() */
    444          #endif
    445          
    446          /**********************************************************************************************************************
    447          State Machine Function Definitions
    448          **********************************************************************************************************************/
    449          
    450          /*-------------------------------------------------------------------------------------------------------------------*/
    451          /* Wait for a card to be inserted */

   \                                 In section .text, align 2, keep-with-next
    452          static void SdCardSM_IdleNoCard(void)
    453          {
   \                     SdCardSM_IdleNoCard: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    454          
    455            if( SdIsCardInserted() )
   \        0x2   0x.... 0x....      BL       SdIsCardInserted
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD03C             BEQ.N    ??SdCardSM_IdleNoCard_0
    456            {
    457              /* Request the SSP resource to talk to the card */
    458              SD_Ssp = SspRequest(&SD_sSspConfig);
   \        0xA   0x.... 0x....      LDR.W    R4,??DataTable26_9
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable26_13
   \       0x12   0x.... 0x....      BL       SspRequest
   \       0x16   0x6020             STR      R0,[R4, #+0]
    459              if(SD_Ssp == NULL)
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD114             BNE.N    ??SdCardSM_IdleNoCard_1
    460              {
    461                /* Go to wait state if SSP is not available */
    462                DebugPrintf(SD_au8SspRequestFailed);
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable26_14
   \       0x22   0x.... 0x....      BL       DebugPrintf
    463                SD_u32Timeout = G_u32SystemTime1ms;
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0x.... 0x....      LDR.W    R1,??DataTable26_11
   \       0x30   0x6008             STR      R0,[R1, #+0]
    464                SD_pfWaitReturnState = SdCardSM_IdleNoCard;
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable26_15
   \       0x36   0x.... 0x....      LDR.W    R1,??DataTable26_16
   \       0x3A   0x6008             STR      R0,[R1, #+0]
    465                SD_pfStateMachine = SdCardSM_WaitSSP;
   \       0x3C   0x.... 0x....      ADR.W    R0,SdCardSM_WaitSSP
   \       0x40   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x44   0x6008             STR      R0,[R1, #+0]
   \       0x46   0xE01D             B.N      ??SdCardSM_IdleNoCard_0
    466              }
    467              else
    468              {
    469                /* If card is in, set flag and then try to talk to card.  Note that the SSP peripheral will 
    470                be allocated to the SD card for this whole initialization process. */
    471                SD_u32Flags &= SD_CLEAR_CARD_TYPE_BITS;
   \                     ??SdCardSM_IdleNoCard_1: (+1)
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \       0x4C   0x6801             LDR      R1,[R0, #+0]
   \       0x4E   0xF031 0x017C      BICS     R1,R1,#0x7C
   \       0x52   0x6001             STR      R1,[R0, #+0]
    472          
    473                /* CS is NOT asserted for initial dummy clocks */
    474                SspDeAssertCS(SD_Ssp);
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x.... 0x....      BL       SspDeAssertCS
    475                
    476                /* Queue up a set of dummy transfers to make sure the card is awake; */
    477                if(SspReadData(SD_Ssp, SD_WAKEUP_BYTES))
   \       0x5A   0x2114             MOVS     R1,#+20
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x.... 0x....      BL       SspReadData
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD005             BEQ.N    ??SdCardSM_IdleNoCard_2
    478                {
    479                  SD_pfStateMachine = SdCardSM_Dummies;
   \       0x66   0x.... 0x....      ADR.W    R0,SdCardSM_Dummies
   \       0x6A   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x6E   0x6008             STR      R0,[R1, #+0]
   \       0x70   0xE008             B.N      ??SdCardSM_IdleNoCard_0
    480                }
    481                else
    482                {
    483                  /* We didn't get a return token, so abort */
    484                  SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \                     ??SdCardSM_IdleNoCard_2: (+1)
   \       0x72   0x2004             MOVS     R0,#+4
   \       0x74   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \       0x78   0x7008             STRB     R0,[R1, #+0]
    485                  SD_pfStateMachine = SdCardSM_Error;
   \       0x7A   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x7E   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x82   0x6008             STR      R0,[R1, #+0]
    486                }
    487              }
    488            }  
    489            
    490          } /* end SdCardSM_IdleNoCard() */
   \                     ??SdCardSM_IdleNoCard_0: (+1)
   \       0x84   0xBD10             POP      {R4,PC}          ;; return
    491          
    492          
    493          /*-------------------------------------------------------------------------------------------------------------------*/
    494          /* Wait for the dummies to be sent to wake up card. Data that will clock in to RxBuffer is ignored. */

   \                                 In section .text, align 4, keep-with-next
    495          static void SdCardSM_Dummies(void)
    496          {
   \                     SdCardSM_Dummies: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    497            if( SspQueryReceiveStatus(SD_Ssp) == SSP_RX_COMPLETE )
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable26_9
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x.... 0x....      BL       SspQueryReceiveStatus
   \        0xC   0x2803             CMP      R0,#+3
   \        0xE   0xD108             BNE.N    ??SdCardSM_Dummies_0
    498            { 
    499              /* Queue CMD0 to be sent. SdCommand sets SD_pfStateMachine for the next state. */
    500              SdCommand(&SD_au8CMD0[0]);
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable26_17
   \       0x14   0x.... 0x....      BL       SdCommand
    501              SD_pfWaitReturnState = SdCardSM_ResponseCMD0;
   \       0x18   0x.... 0x....      ADR.W    R0,SdCardSM_ResponseCMD0
   \       0x1C   0x.... 0x....      LDR.W    R1,??DataTable26_16
   \       0x20   0x6008             STR      R0,[R1, #+0]
    502            }
    503          } /* end SdCardSM_Dummies() */
   \                     ??SdCardSM_Dummies_0: (+1)
   \       0x22   0xBD01             POP      {R0,PC}          ;; return
    504          
    505          
    506          /*-------------------------------------------------------------------------------------------------------------------*/
    507          /* Check the response to CMD0. SD_pu8RxBufferParser is pointing to the RxBuffer where a response R1 is sitting */
    508          /* This is not a state but more a call-back after CMD0 */
    509          

   \                                 In section .text, align 4, keep-with-next
    510          static void SdCardSM_ResponseCMD0(void)
    511          {
   \                     SdCardSM_ResponseCMD0: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    512            /* CS is deasserted after CMD0 */
    513            SspDeAssertCS(SD_Ssp);
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable26_9
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x.... 0x....      BL       SspDeAssertCS
    514          
    515            /* Process the received byte */
    516            if(SD_au8RxBuffer[0] == SD_STATUS_IDLE)
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable26_4
   \       0x10   0x7800             LDRB     R0,[R0, #+0]
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD109             BNE.N    ??SdCardSM_ResponseCMD0_0
    517            {
    518              /* Card is in Idle state, so issue CMD8 */
    519              SdCommand(&SD_au8CMD8[0]);
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable26_18
   \       0x1A   0x.... 0x....      BL       SdCommand
    520              SD_pfWaitReturnState = SdCardSM_ResponseCMD8;
   \       0x1E   0x.... 0x....      ADR.W    R0,SdCardSM_ResponseCMD8
   \       0x22   0x.... 0x....      LDR.W    R1,??DataTable26_16
   \       0x26   0x6008             STR      R0,[R1, #+0]
   \       0x28   0xE008             B.N      ??SdCardSM_ResponseCMD0_1
    521            }
    522            else
    523            {
    524              /* Unexpected response, go to error */
    525              SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
   \                     ??SdCardSM_ResponseCMD0_0: (+1)
   \       0x2A   0x2003             MOVS     R0,#+3
   \       0x2C   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \       0x30   0x7008             STRB     R0,[R1, #+0]
    526              SD_pfStateMachine = SdCardSM_Error;
   \       0x32   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x36   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x3A   0x6008             STR      R0,[R1, #+0]
    527            }
    528            
    529            /* In any case, advance the buffer pointer */
    530            //AdvanceSD_pu8RxBufferParser(1);
    531                 
    532          } /* end SdCardSM_ResponseCMD0() */
   \                     ??SdCardSM_ResponseCMD0_1: (+1)
   \       0x3C   0xBD01             POP      {R0,PC}          ;; return
    533          
    534          
    535          /*-------------------------------------------------------------------------------------------------------------------*/
    536          /* Queue a read to get the CMD8 data. */
    537          /* This is not a state but more a call-back after CMD8 */

   \                                 In section .text, align 4, keep-with-next
    538          static void SdCardSM_ResponseCMD8(void)
    539          {
   \                     SdCardSM_ResponseCMD8: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    540            /* Check the response byte (response R1) */
    541            if(SD_au8RxBuffer[0] == SD_STATUS_IDLE)
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable26_4
   \        0x6   0x7800             LDRB     R0,[R0, #+0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD11D             BNE.N    ??SdCardSM_ResponseCMD8_0
    542            {
    543              /* Command is good which means the card is at least SDv2 so we can read 4 more bytes of the CMD8 response. */
    544              SD_u32Flags |= _SD_TYPE_SD2;
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0xF051 0x0110      ORRS     R1,R1,#0x10
   \       0x16   0x6001             STR      R1,[R0, #+0]
    545              
    546              /* CS is still asserted since we are reading data */
    547              if(SspReadData(SD_Ssp, 4))
   \       0x18   0x2104             MOVS     R1,#+4
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable26_9
   \       0x1E   0x6800             LDR      R0,[R0, #+0]
   \       0x20   0x.... 0x....      BL       SspReadData
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD005             BEQ.N    ??SdCardSM_ResponseCMD8_1
    548              {
    549                SD_pfStateMachine = SdCardSM_ReadCMD8;
   \       0x28   0x.... 0x....      ADR.W    R0,SdCardSM_ReadCMD8
   \       0x2C   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x30   0x6008             STR      R0,[R1, #+0]
   \       0x32   0xE01D             B.N      ??SdCardSM_ResponseCMD8_2
    550              }
    551              else
    552              {
    553                /* SSP read error - we'll just abort */
    554                SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \                     ??SdCardSM_ResponseCMD8_1: (+1)
   \       0x34   0x2004             MOVS     R0,#+4
   \       0x36   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \       0x3A   0x7008             STRB     R0,[R1, #+0]
    555                SD_pfStateMachine = SdCardSM_Error;
   \       0x3C   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x40   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x44   0x6008             STR      R0,[R1, #+0]
   \       0x46   0xE013             B.N      ??SdCardSM_ResponseCMD8_2
    556              }
    557            }
    558            /* CMD8 not supported => not SDv2 */
    559            else
    560            {
    561              /* The card does not support CMD8 so Deassert CS and go directly to ACMD41 */
    562              SD_u32Flags &= ~_SD_TYPE_SD2;
   \                     ??SdCardSM_ResponseCMD8_0: (+1)
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \       0x4C   0x6801             LDR      R1,[R0, #+0]
   \       0x4E   0xF031 0x0110      BICS     R1,R1,#0x10
   \       0x52   0x6001             STR      R1,[R0, #+0]
    563              SspDeAssertCS(SD_Ssp);
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable26_9
   \       0x58   0x6800             LDR      R0,[R0, #+0]
   \       0x5A   0x.... 0x....      BL       SspDeAssertCS
    564              /* Do we need a delay here since CS will be asserted almost immediately in SdCommand? */
    565              
    566              SdCommand(&SD_au8ACMD41[0]);
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable26_19
   \       0x62   0x.... 0x....      BL       SdCommand
    567              SD_pfWaitReturnState = SdCardSM_ResponseCMD55;
   \       0x66   0x.... 0x....      ADR.W    R0,SdCardSM_ResponseCMD55
   \       0x6A   0x.... 0x....      LDR.W    R1,??DataTable26_16
   \       0x6E   0x6008             STR      R0,[R1, #+0]
    568            }
    569              
    570            /* In either case, advance the buffer pointer */
    571            //AdvanceSD_pu8RxBufferParser(1);
    572             
    573          } /* end SdCardSM_ResponseCMD8() */
   \                     ??SdCardSM_ResponseCMD8_2: (+1)
   \       0x70   0xBD01             POP      {R0,PC}          ;; return
    574               
    575          
    576          /*-------------------------------------------------------------------------------------------------------------------*/
    577          /* Wait for the 4 payload bytes from CMD8. */

   \                                 In section .text, align 4, keep-with-next
    578          static void SdCardSM_ReadCMD8(void)
    579          {
   \                     SdCardSM_ReadCMD8: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    580            /* Check to see if the SSP peripheral has sent the data request */
    581          //  if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
    582            if(SspQueryReceiveStatus(SD_Ssp) == SSP_RX_COMPLETE)
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable26_9
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x.... 0x....      BL       SspQueryReceiveStatus
   \        0xC   0x2803             CMP      R0,#+3
   \        0xE   0xD11D             BNE.N    ??SdCardSM_ReadCMD8_0
    583            {
    584              /* CMD8 is finished so deassert CS */
    585              SspDeAssertCS(SD_Ssp);
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x.... 0x....      BL       SspDeAssertCS
    586              
    587              /* Process the four response bytes (only the last two matter) */
    588              //SD_pu8RxBufferParser = ;
    589              if(SD_au8RxBuffer[SD_CMD8_INDEX_VHS] == SD_VHS_VALUE)
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable26_4
   \       0x1A   0x7881             LDRB     R1,[R0, #+2]
   \       0x1C   0x2901             CMP      R1,#+1
   \       0x1E   0xD10C             BNE.N    ??SdCardSM_ReadCMD8_1
    590              {
    591                //AdvanceSD_pu8RxBufferParser(1);
    592                if(SD_au8RxBuffer[SD_CMD8_INDEX_CHECK] == SD_CHECK_PATTERN)
   \       0x20   0x78C0             LDRB     R0,[R0, #+3]
   \       0x22   0x28AA             CMP      R0,#+170
   \       0x24   0xD112             BNE.N    ??SdCardSM_ReadCMD8_0
    593                {
    594                  /* Card supports VCC 2.7 - 3.6V so we're good to go */
    595                  /* Next we need to send CMD55 so we can send ACMD41 */
    596                  SdCommand(&SD_au8CMD55[0]);
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable26_20
   \       0x2A   0x.... 0x....      BL       SdCommand
    597                  SD_pfWaitReturnState = SdCardSM_ResponseCMD55;
   \       0x2E   0x.... 0x....      ADR.W    R0,SdCardSM_ResponseCMD55
   \       0x32   0x.... 0x....      LDR.W    R1,??DataTable26_16
   \       0x36   0x6008             STR      R0,[R1, #+0]
   \       0x38   0xE008             B.N      ??SdCardSM_ReadCMD8_0
    598                }
    599                //AdvanceSD_pu8RxBufferParser(1);
    600              }
    601              else
    602              {
    603                /* The card does not support the voltage range so is not usable */
    604                SD_u8ErrorCode = SD_ERROR_CARD_VOLTAGE;
   \                     ??SdCardSM_ReadCMD8_1: (+1)
   \       0x3A   0x2002             MOVS     R0,#+2
   \       0x3C   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \       0x40   0x7008             STRB     R0,[R1, #+0]
    605                SD_pfStateMachine = SdCardSM_Error;
   \       0x42   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x46   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x4A   0x6008             STR      R0,[R1, #+0]
    606              }
    607            }
    608            
    609            /* Watch for SSP timeout */
    610            CheckTimeout(SD_SPI_WAIT_TIME_MS);
   \                     ??SdCardSM_ReadCMD8_0: (+1)
   \       0x4C   0xF44F 0x70FA      MOV      R0,#+500
   \       0x50   0x.... 0x....      BL       CheckTimeout
    611               
    612          } /* end SdCardSM_ReadCMD8() */
   \       0x54   0xBD10             POP      {R4,PC}          ;; return
    613          
    614               
    615          /*-------------------------------------------------------------------------------------------------------------------*/
    616          /* Check the response to CMD55. */
    617          /* This is really a call-back to CMD55 */

   \                                 In section .text, align 4, keep-with-next
    618          static void SdCardSM_ResponseCMD55(void)
    619          {
   \                     SdCardSM_ResponseCMD55: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    620            /* CMD55 is finished so deassert CS */
    621            SspDeAssertCS(SD_Ssp);
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable26_9
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x.... 0x....      BL       SspDeAssertCS
    622          
    623            /* Process the received byte from CMD55 */
    624            if(SD_au8RxBuffer[0] == SD_STATUS_IDLE)
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable26_4
   \       0x10   0x7800             LDRB     R0,[R0, #+0]
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD114             BNE.N    ??SdCardSM_ResponseCMD55_0
    625            {
    626              /* Card is ready for ACMD41 to configure Host Capacity Support (HCS) bit */
    627              if(SD_u32Flags & _SD_TYPE_SD2)
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \       0x1A   0x7800             LDRB     R0,[R0, #+0]
   \       0x1C   0x06C0             LSLS     R0,R0,#+27
   \       0x1E   0xD505             BPL.N    ??SdCardSM_ResponseCMD55_1
    628              {
    629                SD_au8ACMD41[1] |= BIT6;
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable26_19
   \       0x24   0x7841             LDRB     R1,[R0, #+1]
   \       0x26   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0x2A   0x7041             STRB     R1,[R0, #+1]
    630              }
    631              SdCommand(&SD_au8ACMD41[0]);
   \                     ??SdCardSM_ResponseCMD55_1: (+1)
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable26_19
   \       0x30   0x.... 0x....      BL       SdCommand
    632              SD_pfWaitReturnState = SdCardSM_ResponseACMD41;
   \       0x34   0x.... 0x....      ADR.W    R0,SdCardSM_ResponseACMD41
   \       0x38   0x.... 0x....      LDR.W    R1,??DataTable26_16
   \       0x3C   0x6008             STR      R0,[R1, #+0]
   \       0x3E   0xE008             B.N      ??SdCardSM_ResponseCMD55_2
    633            }
    634            else
    635            {
    636              /* Unexpected response, go to error */
    637              SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
   \                     ??SdCardSM_ResponseCMD55_0: (+1)
   \       0x40   0x2003             MOVS     R0,#+3
   \       0x42   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \       0x46   0x7008             STRB     R0,[R1, #+0]
    638              SD_pfStateMachine = SdCardSM_Error;
   \       0x48   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x4C   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x50   0x6008             STR      R0,[R1, #+0]
    639            }
    640            
    641            /* In any case, advance the buffer pointer */
    642            //AdvanceSD_pu8RxBufferParser(1);
    643                 
    644          } /* end SdCardSM_ResponseCMD55() */
   \                     ??SdCardSM_ResponseCMD55_2: (+1)
   \       0x52   0xBD01             POP      {R0,PC}          ;; return
    645               
    646               
    647          /*-------------------------------------------------------------------------------------------------------------------*/
    648          /* Check the response to ACMD41 which is waiting for the card to NOT be in idle (repeat CMD55 + ACMD41 sequence).
    649          Once the card is ready, can send CMD58.  The next step is different for version 1 and version 2 cards.  MMC will not be supported. */

   \                                 In section .text, align 4, keep-with-next
    650          static void SdCardSM_ResponseACMD41(void)
    651          {
   \                     SdCardSM_ResponseACMD41: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    652            /* ACMD41 is finished so deassert CS */
    653            SspDeAssertCS(SD_Ssp);
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable26_9
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x.... 0x....      BL       SspDeAssertCS
    654          
    655            /* Process the received byte based on card type */
    656            if(SD_au8RxBuffer[0] == SD_STATUS_READY)
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable26_4
   \       0x10   0x7800             LDRB     R0,[R0, #+0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD11C             BNE.N    ??SdCardSM_ResponseACMD41_0
    657            {
    658              /* Card is ready for next command */
    659              if(SD_u32Flags & _SD_TYPE_SD2)
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \       0x1A   0x7801             LDRB     R1,[R0, #+0]
   \       0x1C   0x06C9             LSLS     R1,R1,#+27
   \       0x1E   0xD509             BPL.N    ??SdCardSM_ResponseACMD41_1
    660              {
    661                /* SDv2 cards use CMD58 */
    662                SdCommand(&SD_au8CMD58[0]);
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable26_21
   \       0x24   0x.... 0x....      BL       SdCommand
    663                SD_pfWaitReturnState = SdCardSM_ResponseCMD58;
   \       0x28   0x.... 0x....      ADR.W    R0,SdCardSM_ResponseCMD58
   \       0x2C   0x.... 0x....      LDR.W    R1,??DataTable26_16
   \       0x30   0x6008             STR      R0,[R1, #+0]
   \       0x32   0xE016             B.N      ??SdCardSM_ResponseACMD41_2
    664              }
    665              else
    666              {
    667                /* SDv1 card: set flag and block access size */
    668                SD_u32Flags |= _SD_TYPE_SD1;
   \                     ??SdCardSM_ResponseACMD41_1: (+1)
   \       0x34   0x6801             LDR      R1,[R0, #+0]
   \       0x36   0xF051 0x0108      ORRS     R1,R1,#0x8
   \       0x3A   0x6001             STR      R1,[R0, #+0]
    669                
    670                /* SDv1 cards are always low capacity, but can have variable block access.   
    671                Set to 512 to match SDv2. */
    672                SdCommand(&SD_au8CMD16[0]);
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable26_22
   \       0x40   0x.... 0x....      BL       SdCommand
    673                SD_pfWaitReturnState = SdCardSM_ResponseCMD16;
   \       0x44   0x.... 0x....      ADR.W    R0,SdCardSM_ResponseCMD16
   \       0x48   0x.... 0x....      LDR.W    R1,??DataTable26_16
   \       0x4C   0x6008             STR      R0,[R1, #+0]
   \       0x4E   0xE008             B.N      ??SdCardSM_ResponseACMD41_2
    674              }
    675            }
    676            else 
    677            {
    678              /* Card is not idle yet, so repeat */
    679              SdCommand(&SD_au8CMD55[0]);
   \                     ??SdCardSM_ResponseACMD41_0: (+1)
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable26_20
   \       0x54   0x.... 0x....      BL       SdCommand
    680              SD_pfWaitReturnState = SdCardSM_ResponseCMD55;
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable26_23
   \       0x5C   0x.... 0x....      LDR.W    R1,??DataTable26_16
   \       0x60   0x6008             STR      R0,[R1, #+0]
    681            }
    682            
    683            /* In any case, advance the buffer pointer */
    684            //AdvanceSD_pu8RxBufferParser(1);
    685                 
    686          } /* end SdCardSM_ResponseCMD55() */     
   \                     ??SdCardSM_ResponseACMD41_2: (+1)
   \       0x62   0xBD01             POP      {R0,PC}          ;; return
    687          
    688          
    689          /*-------------------------------------------------------------------------------------------------------------------*/
    690          /* Queue a read to get the CMD58 data. RxBuffer has R1 response byte. */

   \                                 In section .text, align 4, keep-with-next
    691          static void SdCardSM_ResponseCMD58(void)
    692          {
   \                     SdCardSM_ResponseCMD58: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    693            /* Check the response byte (response R1) */
    694            if(SD_au8RxBuffer[0] == SD_STATUS_READY)
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable26_4
   \        0x6   0x7800             LDRB     R0,[R0, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD117             BNE.N    ??SdCardSM_ResponseCMD58_0
    695            {
    696              /* Command is good so we can read 4 more bytes of the CMD58 response */
    697              /* CS is still asserted since we are reading data */
    698              if(SspReadData(SD_Ssp, 4))
   \        0xC   0x2104             MOVS     R1,#+4
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable26_9
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x.... 0x....      BL       SspReadData
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD005             BEQ.N    ??SdCardSM_ResponseCMD58_1
    699              {
    700                SD_pfStateMachine = SdCardSM_ReadCMD58;
   \       0x1C   0x.... 0x....      ADR.W    R0,SdCardSM_ReadCMD58
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x24   0x6008             STR      R0,[R1, #+0]
   \       0x26   0xE012             B.N      ??SdCardSM_ResponseCMD58_2
    701              }
    702              else
    703              {
    704                /* SSP read error - we'll just abort */
    705                SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \                     ??SdCardSM_ResponseCMD58_1: (+1)
   \       0x28   0x2004             MOVS     R0,#+4
   \       0x2A   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \       0x2E   0x7008             STRB     R0,[R1, #+0]
    706                SD_pfStateMachine = SdCardSM_Error;
   \       0x30   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x34   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x38   0x6008             STR      R0,[R1, #+0]
   \       0x3A   0xE008             B.N      ??SdCardSM_ResponseCMD58_2
    707              }
    708            }
    709            else
    710            {
    711              SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
   \                     ??SdCardSM_ResponseCMD58_0: (+1)
   \       0x3C   0x2003             MOVS     R0,#+3
   \       0x3E   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \       0x42   0x7008             STRB     R0,[R1, #+0]
    712              SD_pfStateMachine = SdCardSM_Error;
   \       0x44   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x48   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x4C   0x6008             STR      R0,[R1, #+0]
    713            }
    714              
    715            /* In either case, advance the buffer pointer */
    716            //AdvanceSD_pu8RxBufferParser(1);
    717                 
    718          } /* end SdCardSM_ResponseCMD8() */
   \                     ??SdCardSM_ResponseCMD58_2: (+1)
   \       0x4E   0xBD01             POP      {R0,PC}          ;; return
    719               
    720          
    721          /*-------------------------------------------------------------------------------------------------------------------*/
    722          /* Process response to CMD16. */
    723          /* Not a state, just a call back for CMD16 */

   \                                 In section .text, align 4, keep-with-next
    724          static void SdCardSM_ResponseCMD16(void)
    725          {
   \                     SdCardSM_ResponseCMD16: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    726            /* Check the response byte (response R1) */
    727            if(SD_au8RxBuffer[0] == SD_STATUS_READY)
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable26_4
   \        0x6   0x7800             LDRB     R0,[R0, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD115             BNE.N    ??SdCardSM_ResponseCMD16_0
    728            {
    729              /* Success! Card is ready for read/write operations.  We can release the SSP resource for now. */
    730              SspDeAssertCS(SD_Ssp);
   \        0xC   0x.... 0x....      LDR.W    R4,??DataTable26_9
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x.... 0x....      BL       SspDeAssertCS
    731              SspRelease(SD_Ssp);
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x.... 0x....      BL       SspRelease
    732          
    733              SD_CardState = SD_IDLE;
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0x.... 0x....      LDR.W    R1,??DataTable26_2
   \       0x22   0x7008             STRB     R0,[R1, #+0]
    734              DebugPrintf(SD_au8CardReady);
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable26_24
   \       0x28   0x.... 0x....      BL       DebugPrintf
    735          
    736              SD_pfStateMachine = SdCardSM_ReadyIdle;
   \       0x2C   0x.... 0x....      ADR.W    R0,SdCardSM_ReadyIdle
   \       0x30   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x34   0x6008             STR      R0,[R1, #+0]
   \       0x36   0xE008             B.N      ??SdCardSM_ResponseCMD16_1
    737            }
    738            else
    739            {
    740              SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
   \                     ??SdCardSM_ResponseCMD16_0: (+1)
   \       0x38   0x2003             MOVS     R0,#+3
   \       0x3A   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \       0x3E   0x7008             STRB     R0,[R1, #+0]
    741              SD_pfStateMachine = SdCardSM_Error;
   \       0x40   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x44   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x48   0x6008             STR      R0,[R1, #+0]
    742            }
    743              
    744            /* In either case, advance the buffer pointer */
    745            //AdvanceSD_pu8RxBufferParser(1);
    746                 
    747          } /* end SdCardSM_ResponseCMD8() */
   \                     ??SdCardSM_ResponseCMD16_1: (+1)
   \       0x4A   0xBD10             POP      {R4,PC}          ;; return
    748               
    749          
    750          /*-------------------------------------------------------------------------------------------------------------------*/
    751          /* Wait for a data for CMD58. RxBuffer will have four response bytes when SSP is complete. */

   \                                 In section .text, align 4, keep-with-next
    752          static void SdCardSM_ReadCMD58(void)
    753          {
   \                     SdCardSM_ReadCMD58: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    754            /* Check to see if the SSP peripheral has sent the command */
    755          //  if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
    756            if(SspQueryReceiveStatus(SD_Ssp) == SSP_RX_COMPLETE)
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable26_9
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x.... 0x....      BL       SspQueryReceiveStatus
   \        0xC   0x2803             CMP      R0,#+3
   \        0xE   0xD12B             BNE.N    ??SdCardSM_ReadCMD58_0
    757            {
    758              /* CMD58 is finished so deassert CS */
    759              SspDeAssertCS(SD_Ssp);
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x.... 0x....      BL       SspDeAssertCS
    760          
    761              /* Determine card capacity */
    762              SD_u32Flags &= ~_SD_CARD_HC;
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \       0x1A   0x6801             LDR      R1,[R0, #+0]
   \       0x1C   0xF031 0x0104      BICS     R1,R1,#0x4
   \       0x20   0x6001             STR      R1,[R0, #+0]
    763              if(SD_au8RxBuffer[0] & _SD_OCR_CCS_BIT)
   \       0x22   0x.... 0x....      LDR.W    R1,??DataTable26_4
   \       0x26   0x7809             LDRB     R1,[R1, #+0]
   \       0x28   0x0649             LSLS     R1,R1,#+25
   \       0x2A   0xD514             BPL.N    ??SdCardSM_ReadCMD58_1
    764              {
    765                SD_u32Flags |= _SD_CARD_HC;
   \       0x2C   0x6801             LDR      R1,[R0, #+0]
   \       0x2E   0xF051 0x0104      ORRS     R1,R1,#0x4
   \       0x32   0x6001             STR      R1,[R0, #+0]
    766                
    767                /* Success! Card is ready for read/write operations */
    768                SspRelease(SD_Ssp);
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x.... 0x....      BL       SspRelease
    769            
    770                SD_CardState = SD_IDLE;
   \       0x3A   0x2002             MOVS     R0,#+2
   \       0x3C   0x.... 0x....      LDR.W    R1,??DataTable26_2
   \       0x40   0x7008             STRB     R0,[R1, #+0]
    771                DebugPrintf(SD_au8CardReady);
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable26_24
   \       0x46   0x.... 0x....      BL       DebugPrintf
    772              
    773                SD_pfStateMachine = SdCardSM_ReadyIdle;
   \       0x4A   0x.... 0x....      ADR.W    R0,SdCardSM_ReadyIdle
   \       0x4E   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x52   0x6008             STR      R0,[R1, #+0]
   \       0x54   0xE008             B.N      ??SdCardSM_ReadCMD58_0
    774              }
    775              /* For standard capacity, make sure block size is 512 */
    776              else
    777              {
    778                SdCommand(&SD_au8CMD16[0]);
   \                     ??SdCardSM_ReadCMD58_1: (+1)
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable26_22
   \       0x5A   0x.... 0x....      BL       SdCommand
    779                SD_pfWaitReturnState = SdCardSM_ResponseCMD16;
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable26_25
   \       0x62   0x.... 0x....      LDR.W    R1,??DataTable26_16
   \       0x66   0x6008             STR      R0,[R1, #+0]
    780              }
    781              
    782              /* Ignore the other 3 response bytes */
    783              //AdvanceSD_pu8RxBufferParser(4);
    784            }
    785            
    786            /* Watch for SSP timeout */
    787            CheckTimeout(SD_SPI_WAIT_TIME_MS);
   \                     ??SdCardSM_ReadCMD58_0: (+1)
   \       0x68   0xF44F 0x70FA      MOV      R0,#+500
   \       0x6C   0x.... 0x....      BL       CheckTimeout
    788               
    789          } /* end SdCardSM_ReadCMD58() */
   \       0x70   0xBD10             POP      {R4,PC}          ;; return
    790                     
    791          #if 0     
    792          /*-------------------------------------------------------------------------------------------------------------------*/
    793          /* Kill time waiting for the SD card to indicate it is ready after CS.
    794          SD_NextCommand is queue with the command that will be sent once
    795          the card is ready. */
    796               
    797          static void SdCardSM_WaitReady(void)
    798          {
    799            if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
    800            {  
    801              if( *SD_pu8RxBufferParser != 0xFF )
    802              {
    803                if(!SspReadByte(SD_Ssp))
    804                {
    805                  /* We didn't get a return token, so abort */
    806                  SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
    807                  SD_pfStateMachine = SdCardSM_Error;
    808                }
    809              }
    810              /* The card is ready for the command */
    811              else
    812              {
    813                SD_u32CurrentMsgToken = SspWriteData(SD_Ssp, SD_CMD_SIZE, SD_NextCommand);
    814                
    815                /* Pre-emptively move RxBufferParser so it will point to command response */
    816                //AdvanceSD_pu8RxBufferParser(SD_CMD_SIZE);
    817              
    818                /* Set up time-outs and next state */
    819                SD_u32Timeout = G_u32SystemTime1ms;
    820                SD_pfStateMachine = SdCardSM_WaitCommand;
    821              }
    822            }
    823            
    824            /* Watch for SSP timeout */
    825            CheckTimeout(SD_SPI_WAIT_TIME_MS);
    826               
    827          } /* end SdCardSM_WaitReady() */
    828          #endif
    829          
    830          /*-------------------------------------------------------------------------------------------------------------------*/
    831          /* Kill time waiting for a command to finish sending; the first byte from all completed commands
    832          is response R1 which has BIT7 clear.
    833               
    834          REQUIRES: 
    835            - SD_u32CurrentMsgToken references the message that is being sent
    836               
    837          PROMISES: 
    838            - State machine set to either SdCardSM_WaitResponse or SdCardSM_Error
    839          */

   \                                 In section .text, align 4, keep-with-next
    840          static void SdCardSM_WaitCommand(void)
    841          {
   \                     SdCardSM_WaitCommand: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    842            /* Check to see if the SSP peripheral has sent the command */
    843            if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable26_8
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x.... 0x....      BL       QueryMessageStatus
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD115             BNE.N    ??SdCardSM_WaitCommand_0
    844            {
    845              /* Request 1 byte (response byte from card) */  
    846              if( SspReadByte(SD_Ssp) )
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable26_9
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x.... 0x....      BL       SspReadByte
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD005             BEQ.N    ??SdCardSM_WaitCommand_1
    847              {
    848                SD_pfStateMachine = SdCardSM_WaitResponse;
   \       0x1E   0x.... 0x....      ADR.W    R0,SdCardSM_WaitResponse
   \       0x22   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x26   0x6008             STR      R0,[R1, #+0]
   \       0x28   0xE008             B.N      ??SdCardSM_WaitCommand_0
    849              }
    850              else
    851              {
    852                /* We didn't get a return token, so abort */
    853                SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \                     ??SdCardSM_WaitCommand_1: (+1)
   \       0x2A   0x2004             MOVS     R0,#+4
   \       0x2C   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \       0x30   0x7008             STRB     R0,[R1, #+0]
    854                SD_pfStateMachine = SdCardSM_Error;
   \       0x32   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x36   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x3A   0x6008             STR      R0,[R1, #+0]
    855              }
    856            }
    857          
    858            /* Monitor time out */
    859            if( IsTimeUp(&SD_u32Timeout, SD_WAIT_TIME) )
   \                     ??SdCardSM_WaitCommand_0: (+1)
   \       0x3C   0xF44F 0x717A      MOV      R1,#+1000
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable26_11
   \       0x44   0x.... 0x....      BL       IsTimeUp
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD008             BEQ.N    ??SdCardSM_WaitCommand_2
    860            {
    861              SD_u8ErrorCode = SD_ERROR_TIMEOUT;
   \       0x4C   0x2001             MOVS     R0,#+1
   \       0x4E   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \       0x52   0x7008             STRB     R0,[R1, #+0]
    862              SD_pfStateMachine = SdCardSM_Error;
   \       0x54   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x58   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \       0x5C   0x6008             STR      R0,[R1, #+0]
    863            }
    864               
    865          } /* end SdCardSM_WaitCommand() */
   \                     ??SdCardSM_WaitCommand_2: (+1)
   \       0x5E   0xBD01             POP      {R0,PC}          ;; return
    866          
    867          
    868          /*-------------------------------------------------------------------------------------------------------------------*/
    869          /* Kill time waiting for a response read to finish; the first byte from all completed commands
    870          is response R1 which has BIT7 clear.  This response will be at SD_au8RxBuffer[0].
    871               
    872          REQUIRES: 
    873            - SD_pfWaitReturnState points to the function that should be accessed next.
    874               
    875          PROMISES: 
    876            - State machine set to either SD_pfWaitReturnState or SdCardSM_Error
    877            - RxBuffer holds response byte 
    878          */

   \                                 In section .text, align 4, keep-with-next
    879          static void SdCardSM_WaitResponse(void)
    880          {
   \                     SdCardSM_WaitResponse: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    881            static u8 u8Retries = SD_CMD_RETRIES;
    882            
    883            /* Check to see if the SSP peripheral has sent the read request */
    884            if(SspQueryReceiveStatus(SD_Ssp) == SSP_RX_COMPLETE)
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable26_9
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x.... 0x....      BL       SspQueryReceiveStatus
   \        0xC   0x2803             CMP      R0,#+3
   \        0xE   0xD12D             BNE.N    ??SdCardSM_WaitResponse_0
    885            {
    886              /* If no response but retries left, queue another read */
    887              if( (SD_au8RxBuffer[0] & BIT7) && (u8Retries != 0) )
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable26_4
   \       0x14   0x7800             LDRB     R0,[R0, #+0]
   \       0x16   0x0600             LSLS     R0,R0,#+24
   \       0x18   0xD520             BPL.N    ??SdCardSM_WaitResponse_1
   \       0x1A   0x.... 0x....      LDR.W    R1,??DataTable26_26
   \       0x1E   0x7808             LDRB     R0,[R1, #+0]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD01B             BEQ.N    ??SdCardSM_WaitResponse_1
    888              {
    889                u8Retries--;
   \       0x24   0x7808             LDRB     R0,[R1, #+0]
   \       0x26   0x1E40             SUBS     R0,R0,#+1
   \       0x28   0x7008             STRB     R0,[R1, #+0]
    890                
    891                if(u8Retries == 0)
   \       0x2A   0x7808             LDRB     R0,[R1, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD108             BNE.N    ??SdCardSM_WaitResponse_2
    892                {
    893                  SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
   \       0x30   0x2003             MOVS     R0,#+3
   \       0x32   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \       0x36   0x7008             STRB     R0,[R1, #+0]
    894                  SD_pfStateMachine = SdCardSM_Error;
   \       0x38   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x3C   0x....             LDR.N    R1,??DataTable26_7
   \       0x3E   0x6008             STR      R0,[R1, #+0]
   \       0x40   0xE014             B.N      ??SdCardSM_WaitResponse_0
    895                }
    896                else if( !SspReadByte(SD_Ssp) )
   \                     ??SdCardSM_WaitResponse_2: (+1)
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x.... 0x....      BL       SspReadByte
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD10F             BNE.N    ??SdCardSM_WaitResponse_0
    897                {
    898                  /* We didn't get a return token, so abort */
    899                  SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \       0x4C   0x2004             MOVS     R0,#+4
   \       0x4E   0x....             LDR.N    R1,??DataTable26_12
   \       0x50   0x7008             STRB     R0,[R1, #+0]
    900                  SD_pfStateMachine = SdCardSM_Error;
   \       0x52   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x56   0x....             LDR.N    R1,??DataTable26_7
   \       0x58   0x6008             STR      R0,[R1, #+0]
   \       0x5A   0xE007             B.N      ??SdCardSM_WaitResponse_0
    901                }
    902              }
    903              else
    904              {
    905                /* Otherwise we have a good response, so return now */
    906                u8Retries = SD_CMD_RETRIES;
   \                     ??SdCardSM_WaitResponse_1: (+1)
   \       0x5C   0x2014             MOVS     R0,#+20
   \       0x5E   0x.... 0x....      LDR.W    R1,??DataTable26_26
   \       0x62   0x7008             STRB     R0,[R1, #+0]
    907                SD_pfStateMachine = SD_pfWaitReturnState;
   \       0x64   0x....             LDR.N    R0,??DataTable26_16
   \       0x66   0x6800             LDR      R0,[R0, #+0]
   \       0x68   0x....             LDR.N    R1,??DataTable26_7
   \       0x6A   0x6008             STR      R0,[R1, #+0]
    908              }
    909            }
    910          
    911            /* Monitor time out */
    912            if( IsTimeUp(&SD_u32Timeout, SD_WAIT_TIME) )
   \                     ??SdCardSM_WaitResponse_0: (+1)
   \       0x6C   0xF44F 0x717A      MOV      R1,#+1000
   \       0x70   0x....             LDR.N    R0,??DataTable26_11
   \       0x72   0x.... 0x....      BL       IsTimeUp
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD009             BEQ.N    ??SdCardSM_WaitResponse_3
    913            {
    914              u8Retries = SD_CMD_RETRIES;
   \       0x7A   0x2014             MOVS     R0,#+20
   \       0x7C   0x....             LDR.N    R1,??DataTable26_26
   \       0x7E   0x7008             STRB     R0,[R1, #+0]
    915              SD_u8ErrorCode = SD_ERROR_TIMEOUT;
   \       0x80   0x2001             MOVS     R0,#+1
   \       0x82   0x....             LDR.N    R1,??DataTable26_12
   \       0x84   0x7008             STRB     R0,[R1, #+0]
    916              SD_pfStateMachine = SdCardSM_Error;
   \       0x86   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x8A   0x....             LDR.N    R1,??DataTable26_7
   \       0x8C   0x6008             STR      R0,[R1, #+0]
    917            }
    918               
    919          } /* end SdCardSM_WaitResponse() */
   \                     ??SdCardSM_WaitResponse_3: (+1)
   \       0x8E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .data, align 1
   \                     `SdCardSM_WaitResponse::u8Retries`:
   \        0x0   0x14               DC8 20
    920          
    921            
    922          /*-------------------------------------------------------------------------------------------------------------------*/
    923          /* Kill time before checking SSP availability again */

   \                                 In section .text, align 4, keep-with-next
    924          static void SdCardSM_WaitSSP(void)          
    925          {
   \                     SdCardSM_WaitSSP: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    926            if( IsTimeUp(&SD_u32Timeout, SD_SPI_WAIT_TIME_MS) )
   \        0x2   0xF44F 0x71FA      MOV      R1,#+500
   \        0x6   0x....             LDR.N    R0,??DataTable26_11
   \        0x8   0x.... 0x....      BL       IsTimeUp
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD003             BEQ.N    ??SdCardSM_WaitSSP_0
    927            {
    928              SD_pfStateMachine = SD_pfWaitReturnState;
   \       0x10   0x....             LDR.N    R0,??DataTable26_16
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x....             LDR.N    R1,??DataTable26_7
   \       0x16   0x6008             STR      R0,[R1, #+0]
    929            }
    930            
    931          } /* end SdCardSM_WaitSSP() */
   \                     ??SdCardSM_WaitSSP_0: (+1)
   \       0x18   0xBD01             POP      {R0,PC}          ;; return
    932               
    933               
    934          /*-------------------------------------------------------------------------------------------------------------------*/
    935          /* SD card is initialized: wait for action request. */

   \                                 In section .text, align 4, keep-with-next
    936          static void SdCardSM_ReadyIdle(void)          
    937          {
   \                     SdCardSM_ReadyIdle: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    938            /* Check if the card is still in; if not return through WaitSSP to allow some debounce time */
    939            if( !SdIsCardInserted() )
   \        0x2   0x.... 0x....      BL       SdIsCardInserted
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD10F             BNE.N    ??SdCardSM_ReadyIdle_0
    940            {
    941              SD_u32Flags &= SD_CLEAR_CARD_TYPE_BITS;
   \        0xA   0x....             LDR.N    R0,??DataTable26_1
   \        0xC   0x6801             LDR      R1,[R0, #+0]
   \        0xE   0xF031 0x017C      BICS     R1,R1,#0x7C
   \       0x12   0x6001             STR      R1,[R0, #+0]
    942              
    943              /* Exit through a wait state for effective debouncing */
    944              SD_u32Timeout = G_u32SystemTime1ms;
   \       0x14   0x....             LDR.N    R0,??DataTable26_10
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x....             LDR.N    R1,??DataTable26_11
   \       0x1A   0x6008             STR      R0,[R1, #+0]
    945              SD_pfWaitReturnState = SdCardSM_IdleNoCard;
   \       0x1C   0x....             LDR.N    R0,??DataTable26_15
   \       0x1E   0x....             LDR.N    R1,??DataTable26_16
   \       0x20   0x6008             STR      R0,[R1, #+0]
    946              SD_pfStateMachine = SdCardSM_WaitSSP;
   \       0x22   0x....             LDR.N    R0,??DataTable26_27
   \       0x24   0x....             LDR.N    R1,??DataTable26_7
   \       0x26   0x6008             STR      R0,[R1, #+0]
   \       0x28   0xE038             B.N      ??SdCardSM_ReadyIdle_1
    947            }
    948            else
    949            {
    950              /* Look for a request to read or write file data */
    951              if( (SD_CardState == SD_WRITING) || (SD_CardState == SD_READING) )
   \                     ??SdCardSM_ReadyIdle_0: (+1)
   \       0x2A   0x....             LDR.N    R4,??DataTable26_2
   \       0x2C   0x7820             LDRB     R0,[R4, #+0]
   \       0x2E   0x2805             CMP      R0,#+5
   \       0x30   0xD002             BEQ.N    ??SdCardSM_ReadyIdle_2
   \       0x32   0x7820             LDRB     R0,[R4, #+0]
   \       0x34   0x2803             CMP      R0,#+3
   \       0x36   0xD131             BNE.N    ??SdCardSM_ReadyIdle_1
    952              {
    953                /* Request the SSP resource to talk to the card */
    954                SD_Ssp = SspRequest(&SD_sSspConfig);
   \                     ??SdCardSM_ReadyIdle_2: (+1)
   \       0x38   0x....             LDR.N    R5,??DataTable26_9
   \       0x3A   0x....             LDR.N    R0,??DataTable26_13
   \       0x3C   0x.... 0x....      BL       SspRequest
   \       0x40   0x6028             STR      R0,[R5, #+0]
    955                if(SD_Ssp == NULL)
   \       0x42   0x6828             LDR      R0,[R5, #+0]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD10D             BNE.N    ??SdCardSM_ReadyIdle_3
    956                {
    957                  /* Go to wait state if SSP is not available */
    958                  DebugPrintf(SD_au8SspRequestFailed);
   \       0x48   0x....             LDR.N    R0,??DataTable26_14
   \       0x4A   0x.... 0x....      BL       DebugPrintf
    959                  SD_u32Timeout = G_u32SystemTime1ms;
   \       0x4E   0x....             LDR.N    R0,??DataTable26_10
   \       0x50   0x6800             LDR      R0,[R0, #+0]
   \       0x52   0x....             LDR.N    R1,??DataTable26_11
   \       0x54   0x6008             STR      R0,[R1, #+0]
    960                  SD_pfWaitReturnState = SdCardSM_ReadyIdle;
   \       0x56   0x....             LDR.N    R0,??DataTable26_28
   \       0x58   0x....             LDR.N    R1,??DataTable26_16
   \       0x5A   0x6008             STR      R0,[R1, #+0]
    961                  SD_pfStateMachine = SdCardSM_WaitSSP;
   \       0x5C   0x....             LDR.N    R0,??DataTable26_27
   \       0x5E   0x....             LDR.N    R1,??DataTable26_7
   \       0x60   0x6008             STR      R0,[R1, #+0]
   \       0x62   0xE01B             B.N      ??SdCardSM_ReadyIdle_1
    962                }
    963                else
    964                {
    965                  /* Got SSP, so start read or write */
    966                  if(SD_CardState == SD_WRITING)
   \                     ??SdCardSM_ReadyIdle_3: (+1)
   \       0x64   0x7820             LDRB     R0,[R4, #+0]
   \       0x66   0x2805             CMP      R0,#+5
   \       0x68   0xD105             BNE.N    ??SdCardSM_ReadyIdle_4
    967                  {
    968                    /* Not yet implemented */
    969                    SD_pfStateMachine = SdCardSM_ReadyIdle;
   \       0x6A   0x....             LDR.N    R0,??DataTable26_28
   \       0x6C   0x....             LDR.N    R1,??DataTable26_7
   \       0x6E   0x6008             STR      R0,[R1, #+0]
    970                    SD_CardState = SD_IDLE;
   \       0x70   0x2002             MOVS     R0,#+2
   \       0x72   0x7020             STRB     R0,[R4, #+0]
   \       0x74   0xE012             B.N      ??SdCardSM_ReadyIdle_1
    971                  }
    972                  else
    973                  {
    974                    /* Parse out the bytes of the address into the command array */
    975                    SD_au8CMD17[1] = (u8)(SD_u32Address >> 24);
   \                     ??SdCardSM_ReadyIdle_4: (+1)
   \       0x76   0x....             LDR.N    R0,??DataTable26_29
   \       0x78   0x....             LDR.N    R1,??DataTable26_3
   \       0x7A   0x680A             LDR      R2,[R1, #+0]
   \       0x7C   0x0E12             LSRS     R2,R2,#+24
   \       0x7E   0x7042             STRB     R2,[R0, #+1]
    976                    SD_au8CMD17[2] = (u8)(SD_u32Address >> 16);
   \       0x80   0x680A             LDR      R2,[R1, #+0]
   \       0x82   0x0C12             LSRS     R2,R2,#+16
   \       0x84   0x7082             STRB     R2,[R0, #+2]
    977                    SD_au8CMD17[3] = (u8)(SD_u32Address >> 8);
   \       0x86   0x680A             LDR      R2,[R1, #+0]
   \       0x88   0x0A12             LSRS     R2,R2,#+8
   \       0x8A   0x70C2             STRB     R2,[R0, #+3]
    978                    SD_au8CMD17[4] = (u8)SD_u32Address;
   \       0x8C   0x6809             LDR      R1,[R1, #+0]
   \       0x8E   0x7101             STRB     R1,[R0, #+4]
    979                    
    980                    SdCommand(&SD_au8CMD17[0]);
   \       0x90   0x.... 0x....      BL       SdCommand
    981                    SD_pfWaitReturnState = SdCardSM_ResponseCMD17;
   \       0x94   0x.... 0x....      ADR.W    R0,SdCardSM_ResponseCMD17
   \       0x98   0x....             LDR.N    R1,??DataTable26_16
   \       0x9A   0x6008             STR      R0,[R1, #+0]
    982                  }
    983                }
    984              }
    985            }
    986          } /* end SdCardSM_ReadyIdle() */
   \                     ??SdCardSM_ReadyIdle_1: (+1)
   \       0x9C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    987               
    988          
    989          /*-------------------------------------------------------------------------------------------------------------------*/
    990          /* Start read sequence */

   \                                 In section .text, align 4, keep-with-next
    991          static void SdCardSM_ResponseCMD17(void)
    992          {
   \                     SdCardSM_ResponseCMD17: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    993            /* Check the response byte (response R1) */
    994            if(SD_au8RxBuffer[0] == SD_STATUS_READY)
   \        0x2   0x....             LDR.N    R0,??DataTable26_4
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD116             BNE.N    ??SdCardSM_ResponseCMD17_0
    995            {
    996              /* Queue a read looking to get TOKEN_START_BLOCK back from the card */
    997              //SD_u32CurrentMsgToken = SspReadByte(SD_Ssp);
    998              if(SspReadByte(SD_Ssp))
   \        0xA   0x....             LDR.N    R0,??DataTable26_9
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x.... 0x....      BL       SspReadByte
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD008             BEQ.N    ??SdCardSM_ResponseCMD17_1
    999              {
   1000                SD_u32Timeout = G_u32SystemTime1ms;
   \       0x16   0x....             LDR.N    R0,??DataTable26_10
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x....             LDR.N    R1,??DataTable26_11
   \       0x1C   0x6008             STR      R0,[R1, #+0]
   1001                SD_pfStateMachine = SdCardSM_WaitStartToken;
   \       0x1E   0x.... 0x....      ADR.W    R0,SdCardSM_WaitStartToken
   \       0x22   0x....             LDR.N    R1,??DataTable26_7
   \       0x24   0x6008             STR      R0,[R1, #+0]
   \       0x26   0xE00E             B.N      ??SdCardSM_ResponseCMD17_2
   1002              }
   1003              else
   1004              {
   1005                /* SSP read error - we'll just abort */
   1006                SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \                     ??SdCardSM_ResponseCMD17_1: (+1)
   \       0x28   0x2004             MOVS     R0,#+4
   \       0x2A   0x....             LDR.N    R1,??DataTable26_12
   \       0x2C   0x7008             STRB     R0,[R1, #+0]
   1007                SD_pfStateMachine = SdCardSM_Error;
   \       0x2E   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x32   0x....             LDR.N    R1,??DataTable26_7
   \       0x34   0x6008             STR      R0,[R1, #+0]
   \       0x36   0xE006             B.N      ??SdCardSM_ResponseCMD17_2
   1008              }
   1009            }
   1010            else
   1011            {
   1012              /* Incorrect response from the SD card, so abort */
   1013              SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
   \                     ??SdCardSM_ResponseCMD17_0: (+1)
   \       0x38   0x2003             MOVS     R0,#+3
   \       0x3A   0x....             LDR.N    R1,??DataTable26_12
   \       0x3C   0x7008             STRB     R0,[R1, #+0]
   1014              SD_pfStateMachine = SdCardSM_FailedDataTransfer;
   \       0x3E   0x.... 0x....      ADR.W    R0,SdCardSM_FailedDataTransfer
   \       0x42   0x....             LDR.N    R1,??DataTable26_7
   \       0x44   0x6008             STR      R0,[R1, #+0]
   1015            }
   1016          
   1017            /* Either way, advance the RxBuffer pointer */  
   1018            //AdvanceSD_pu8RxBufferParser(1);
   1019          
   1020          } /* end SdCardSM_ResponseCMD17() */
   \                     ??SdCardSM_ResponseCMD17_2: (+1)
   \       0x46   0xBD01             POP      {R0,PC}          ;; return
   1021          
   1022          
   1023          /*-------------------------------------------------------------------------------------------------------------------*/
   1024          /* Look for the returned token that indicates the read or write process has begun */

   \                                 In section .text, align 4, keep-with-next
   1025          static void SdCardSM_WaitStartToken(void)          
   1026          {
   \                     SdCardSM_WaitStartToken: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1027            /* Check if the SSP peripheral has sent the data request */
   1028          //  if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
   1029            if(SspQueryReceiveStatus(SD_Ssp) == SSP_RX_COMPLETE)
   \        0x2   0x....             LDR.N    R4,??DataTable26_9
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x.... 0x....      BL       SspQueryReceiveStatus
   \        0xA   0x2803             CMP      R0,#+3
   \        0xC   0xD127             BNE.N    ??SdCardSM_WaitStartToken_0
   1030            {
   1031              /* Check the response byte */
   1032              if(SD_au8RxBuffer[0] == TOKEN_START_BLOCK)
   \        0xE   0x....             LDR.N    R0,??DataTable26_4
   \       0x10   0x7800             LDRB     R0,[R0, #+0]
   \       0x12   0x28FE             CMP      R0,#+254
   \       0x14   0xD113             BNE.N    ??SdCardSM_WaitStartToken_1
   1033              {
   1034                /* Set the RxBuffer pointers to the start of the RxBuffer so the sector data occupies the beginning */
   1035                //SD_pu8RxBufferNextByte = &SD_au8RxBuffer[0];
   1036                //SD_pu8RxBufferParser   = &SD_au8RxBuffer[0];
   1037                
   1038                /* Queue a read for the entire sector plus two checksum bytes */
   1039                /* CS is still asserted since we are reading data */
   1040                if(SspReadData(SD_Ssp, 514))
   \       0x16   0xF240 0x2102      MOVW     R1,#+514
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x.... 0x....      BL       SspReadData
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD004             BEQ.N    ??SdCardSM_WaitStartToken_2
   1041                {
   1042                  SD_pfStateMachine = SdCardSM_DataTransfer;
   \       0x24   0x.... 0x....      ADR.W    R0,SdCardSM_DataTransfer
   \       0x28   0x....             LDR.N    R1,??DataTable26_7
   \       0x2A   0x6008             STR      R0,[R1, #+0]
   \       0x2C   0xE017             B.N      ??SdCardSM_WaitStartToken_0
   1043                }
   1044                else
   1045                {
   1046                  /* SSP read error - we'll just abort */
   1047                  SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \                     ??SdCardSM_WaitStartToken_2: (+1)
   \       0x2E   0x2004             MOVS     R0,#+4
   \       0x30   0x....             LDR.N    R1,??DataTable26_12
   \       0x32   0x7008             STRB     R0,[R1, #+0]
   1048                  SD_pfStateMachine = SdCardSM_Error;
   \       0x34   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x38   0x....             LDR.N    R1,??DataTable26_7
   \       0x3A   0x6008             STR      R0,[R1, #+0]
   \       0x3C   0xE00F             B.N      ??SdCardSM_WaitStartToken_0
   1049                }
   1050              }
   1051              else
   1052              {
   1053                /* Didn't get the start token so retry */
   1054                if(SspReadByte(SD_Ssp))
   \                     ??SdCardSM_WaitStartToken_1: (+1)
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x.... 0x....      BL       SspReadByte
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD003             BEQ.N    ??SdCardSM_WaitStartToken_3
   1055                {
   1056                  SD_pfStateMachine = SdCardSM_WaitStartToken;
   \       0x48   0x....             LDR.N    R0,??DataTable26_30
   \       0x4A   0x....             LDR.N    R1,??DataTable26_7
   \       0x4C   0x6008             STR      R0,[R1, #+0]
   \       0x4E   0xE006             B.N      ??SdCardSM_WaitStartToken_0
   1057                }
   1058                else
   1059                {
   1060                  /* SSP read error - we'll just abort */
   1061                  SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \                     ??SdCardSM_WaitStartToken_3: (+1)
   \       0x50   0x2004             MOVS     R0,#+4
   \       0x52   0x....             LDR.N    R1,??DataTable26_12
   \       0x54   0x7008             STRB     R0,[R1, #+0]
   1062                  SD_pfStateMachine = SdCardSM_Error;
   \       0x56   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x5A   0x....             LDR.N    R1,??DataTable26_7
   \       0x5C   0x6008             STR      R0,[R1, #+0]
   1063                }
   1064              }
   1065            }
   1066            
   1067            /* Monitor time */
   1068            if(IsTimeUp(&SD_u32Timeout, SD_READ_TOKEN_MS))
   \                     ??SdCardSM_WaitStartToken_0: (+1)
   \       0x5E   0x21C8             MOVS     R1,#+200
   \       0x60   0x....             LDR.N    R0,??DataTable26_11
   \       0x62   0x.... 0x....      BL       IsTimeUp
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD006             BEQ.N    ??SdCardSM_WaitStartToken_4
   1069            {
   1070              SD_u8ErrorCode = SD_ERROR_TIMEOUT;
   \       0x6A   0x2001             MOVS     R0,#+1
   \       0x6C   0x....             LDR.N    R1,??DataTable26_12
   \       0x6E   0x7008             STRB     R0,[R1, #+0]
   1071              SD_pfStateMachine = SdCardSM_FailedDataTransfer;
   \       0x70   0x.... 0x....      ADR.W    R0,SdCardSM_FailedDataTransfer
   \       0x74   0x....             LDR.N    R1,??DataTable26_7
   \       0x76   0x6008             STR      R0,[R1, #+0]
   1072            }
   1073            
   1074          } /* end SdCardSM_WaitStartToken() */
   \                     ??SdCardSM_WaitStartToken_4: (+1)
   \       0x78   0xBD10             POP      {R4,PC}          ;; return
   1075          
   1076          
   1077          /*-------------------------------------------------------------------------------------------------------------------*/
   1078          /* Read the sector */

   \                                 In section .text, align 4, keep-with-next
   1079          static void SdCardSM_DataTransfer(void)
   1080          {
   \                     SdCardSM_DataTransfer: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1081            /* Check if the SSP peripheral is finished with the data request */
   1082            if(SspQueryReceiveStatus(SD_Ssp) == SSP_RX_COMPLETE)
   \        0x2   0x....             LDR.N    R4,??DataTable26_9
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x.... 0x....      BL       SspQueryReceiveStatus
   \        0xA   0x2803             CMP      R0,#+3
   \        0xC   0xD10B             BNE.N    ??SdCardSM_DataTransfer_0
   1083            {
   1084              SD_CardState = SD_DATA_READY;
   \        0xE   0x2004             MOVS     R0,#+4
   \       0x10   0x....             LDR.N    R1,??DataTable26_2
   \       0x12   0x7008             STRB     R0,[R1, #+0]
   1085          
   1086              SspDeAssertCS(SD_Ssp);
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x.... 0x....      BL       SspDeAssertCS
   1087              SspRelease(SD_Ssp);
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x.... 0x....      BL       SspRelease
   1088          
   1089              /* Reset the RxBuffer pointers to the start of the RxBuffer */
   1090              //SD_pu8RxBufferNextByte = &SD_au8RxBuffer[0];
   1091              //SD_pu8RxBufferParser   = &SD_au8RxBuffer[0];
   1092          
   1093              SD_pfStateMachine = SdCardSM_ReadyIdle;
   \       0x20   0x....             LDR.N    R0,??DataTable26_28
   \       0x22   0x....             LDR.N    R1,??DataTable26_7
   \       0x24   0x6008             STR      R0,[R1, #+0]
   1094            }
   1095          
   1096            /* Monitor time */
   1097            if(IsTimeUp(&SD_u32Timeout, SD_SECTOR_READ_TIMEOUT_MS))
   \                     ??SdCardSM_DataTransfer_0: (+1)
   \       0x26   0xF44F 0x717A      MOV      R1,#+1000
   \       0x2A   0x....             LDR.N    R0,??DataTable26_11
   \       0x2C   0x.... 0x....      BL       IsTimeUp
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD006             BEQ.N    ??SdCardSM_DataTransfer_1
   1098            {
   1099              SD_u8ErrorCode = SD_ERROR_TIMEOUT;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0x....             LDR.N    R1,??DataTable26_12
   \       0x38   0x7008             STRB     R0,[R1, #+0]
   1100              SD_pfStateMachine = SdCardSM_Error;
   \       0x3A   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \       0x3E   0x....             LDR.N    R1,??DataTable26_7
   \       0x40   0x6008             STR      R0,[R1, #+0]
   1101            }
   1102          
   1103          } /* end SdCardSM_DataTransfer() */
   \                     ??SdCardSM_DataTransfer_1: (+1)
   \       0x42   0xBD10             POP      {R4,PC}          ;; return
   1104          
   1105          
   1106          /*-------------------------------------------------------------------------------------------------------------------*/
   1107          /* Handle a failed data transfer */

   \                                 In section .text, align 4, keep-with-next
   1108          static void SdCardSM_FailedDataTransfer(void)
   1109          {
   \                     SdCardSM_FailedDataTransfer: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1110            /* Reset the system variables */
   1111            SspDeAssertCS(SD_Ssp);
   \        0x2   0x....             LDR.N    R4,??DataTable26_9
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x.... 0x....      BL       SspDeAssertCS
   1112            SspRelease(SD_Ssp);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x.... 0x....      BL       SspRelease
   1113            //FlushSdRxBuffer();
   1114            SD_CardState = SD_CARD_ERROR;
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x....             LDR.N    R1,??DataTable26_2
   \       0x14   0x7008             STRB     R0,[R1, #+0]
   1115            
   1116            SD_u32Timeout = G_u32SystemTime1ms;
   \       0x16   0x....             LDR.N    R0,??DataTable26_10
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x....             LDR.N    R1,??DataTable26_11
   \       0x1C   0x6008             STR      R0,[R1, #+0]
   1117            SD_pfStateMachine = SdCardSM_WaitSSP;
   \       0x1E   0x....             LDR.N    R0,??DataTable26_27
   \       0x20   0x....             LDR.N    R1,??DataTable26_7
   \       0x22   0x6008             STR      R0,[R1, #+0]
   1118            
   1119          } /* end SdCardSM_FailedDataTransfer() */
   \       0x24   0xBD10             POP      {R4,PC}          ;; return
   1120          
   1121          
   1122          /*-------------------------------------------------------------------------------------------------------------------*/
   1123          /* Handle an error */

   \                                 In section .text, align 4, keep-with-next
   1124          static void SdCardSM_Error(void)          
   1125          {
   \                     SdCardSM_Error: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1126            u8* pu8ErrorMessage;
   1127            //u8 u8MessageSize;
   1128            
   1129            /* Reset the system variables */
   1130            SspDeAssertCS(SD_Ssp);
   \        0x2   0x....             LDR.N    R4,??DataTable26_9
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x.... 0x....      BL       SspDeAssertCS
   1131            SspRelease(SD_Ssp);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x.... 0x....      BL       SspRelease
   1132            //FlushSdRxBuffer();
   1133          
   1134            /* Indicate error and return through the SSP delay state to give the system some recovery time */
   1135            DebugPrintf(SD_au8CardError);
   \       0x10   0x....             LDR.N    R0,??DataTable26_31
   \       0x12   0x.... 0x....      BL       DebugPrintf
   1136            switch (SD_u8ErrorCode)
   \       0x16   0x....             LDR.N    R0,??DataTable26_12
   \       0x18   0x7800             LDRB     R0,[R0, #+0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD007             BEQ.N    ??SdCardSM_Error_0
   \       0x1E   0xD310             BCC.N    ??SdCardSM_Error_1
   \       0x20   0x2803             CMP      R0,#+3
   \       0x22   0xD008             BEQ.N    ??SdCardSM_Error_2
   \       0x24   0xD305             BCC.N    ??SdCardSM_Error_3
   \       0x26   0x2805             CMP      R0,#+5
   \       0x28   0xD009             BEQ.N    ??SdCardSM_Error_4
   \       0x2A   0xD306             BCC.N    ??SdCardSM_Error_5
   \       0x2C   0xE009             B.N      ??SdCardSM_Error_1
   1137            {
   1138              case SD_ERROR_TIMEOUT:
   1139              {
   1140                //u8MessageSize = sizeof(SD_au8CardError1) - 1;
   1141                pu8ErrorMessage = SD_au8CardError1;
   \                     ??SdCardSM_Error_0: (+1)
   \       0x2E   0x....             LDR.N    R4,??DataTable26_32
   1142                break;
   \       0x30   0xE008             B.N      ??SdCardSM_Error_6
   1143              }
   1144              
   1145              case SD_ERROR_CARD_VOLTAGE:
   1146              {
   1147                //u8MessageSize = sizeof(SD_au8CardError2) - 1;
   1148                pu8ErrorMessage = SD_au8CardError2;
   \                     ??SdCardSM_Error_3: (+1)
   \       0x32   0x....             LDR.N    R4,??DataTable26_33
   1149                break;
   \       0x34   0xE006             B.N      ??SdCardSM_Error_6
   1150              }
   1151          
   1152              case SD_ERROR_BAD_RESPONSE:
   1153              {
   1154                //u8MessageSize = sizeof(SD_au8CardError3) - 1;
   1155                pu8ErrorMessage = SD_au8CardError3;
   \                     ??SdCardSM_Error_2: (+1)
   \       0x36   0x....             LDR.N    R4,??DataTable26_34
   1156                break;
   \       0x38   0xE004             B.N      ??SdCardSM_Error_6
   1157              }
   1158          
   1159              case SD_ERROR_NO_TOKEN:
   1160              {
   1161                //u8MessageSize = sizeof(SD_au8CardError4) - 1;
   1162                pu8ErrorMessage = SD_au8CardError4;
   \                     ??SdCardSM_Error_5: (+1)
   \       0x3A   0x....             LDR.N    R4,??DataTable26_35
   1163                break;
   \       0x3C   0xE002             B.N      ??SdCardSM_Error_6
   1164              }
   1165          
   1166              case SD_ERROR_NO_SD_TOKEN:
   1167              {
   1168                //u8MessageSize = sizeof(SD_au8CardError5) - 1;
   1169                pu8ErrorMessage = SD_au8CardError5;
   \                     ??SdCardSM_Error_4: (+1)
   \       0x3E   0x....             LDR.N    R4,??DataTable26_36
   1170                break;
   \       0x40   0xE000             B.N      ??SdCardSM_Error_6
   1171              }
   1172              
   1173             default:
   1174             {
   1175              //u8MessageSize = sizeof(SD_au8CardError0) - 1;
   1176              pu8ErrorMessage = SD_au8CardError0;
   \                     ??SdCardSM_Error_1: (+1)
   \       0x42   0x....             LDR.N    R4,??DataTable26_37
   1177              break;
   1178            }
   1179             
   1180            } /* end switch */
   1181            
   1182            DebugPrintf(pu8ErrorMessage);
   \                     ??SdCardSM_Error_6: (+1)
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x.... 0x....      BL       DebugPrintf
   1183            
   1184            SD_CardState = SD_NO_CARD;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x....             LDR.N    R1,??DataTable26_2
   \       0x4E   0x7008             STRB     R0,[R1, #+0]
   1185            SD_u32Timeout = G_u32SystemTime1ms;
   \       0x50   0x....             LDR.N    R0,??DataTable26_10
   \       0x52   0x6800             LDR      R0,[R0, #+0]
   \       0x54   0x....             LDR.N    R1,??DataTable26_11
   \       0x56   0x6008             STR      R0,[R1, #+0]
   1186            SD_pfWaitReturnState = SdCardSM_IdleNoCard;
   \       0x58   0x....             LDR.N    R0,??DataTable26_15
   \       0x5A   0x....             LDR.N    R1,??DataTable26_16
   \       0x5C   0x6008             STR      R0,[R1, #+0]
   1187            SD_pfStateMachine = SdCardSM_WaitSSP;
   \       0x5E   0x....             LDR.N    R0,??DataTable26_27
   \       0x60   0x....             LDR.N    R1,??DataTable26_7
   \       0x62   0x6008             STR      R0,[R1, #+0]
   1188            
   1189          } /* end SdCardSM_Error() */
   \       0x64   0xBD10             POP      {R4,PC}          ;; return
   1190          
   1191          
   1192          #ifndef ENABLE_SD 
   1193          /*-------------------------------------------------------------------------------------------------------------------*/
   1194          /* SD card disbled state */

   \                                 In section .text, align 4, keep-with-next
   1195          static void SdCardSM_Disabled(void)
   1196          {
   1197            
   1198          } /* end SdCardSM_Disabled */
   \                     SdCardSM_Disabled: (+1)
   \        0x0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \        0x0   0x400E'0C3C        DC32     0x400e0c3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \        0x0   0x....'....        DC32     SD_u32Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \        0x0   0x....'....        DC32     SD_CardState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \        0x0   0x....'....        DC32     SD_u32Address

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_4:
   \        0x0   0x....'....        DC32     SD_au8RxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_5:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_6:
   \        0x0   0x....'....        DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_7:
   \        0x0   0x....'....        DC32     SD_pfStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_8:
   \        0x0   0x....'....        DC32     SD_u32CurrentMsgToken

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_9:
   \        0x0   0x....'....        DC32     SD_Ssp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_10:
   \        0x0   0x....'....        DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_11:
   \        0x0   0x....'....        DC32     SD_u32Timeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_12:
   \        0x0   0x....'....        DC32     SD_u8ErrorCode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_13:
   \        0x0   0x....'....        DC32     SD_sSspConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_14:
   \        0x0   0x....'....        DC32     SD_au8SspRequestFailed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_15:
   \        0x0   0x....'....        DC32     SdCardSM_IdleNoCard

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_16:
   \        0x0   0x....'....        DC32     SD_pfWaitReturnState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_17:
   \        0x0   0x....'....        DC32     SD_au8CMD0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_18:
   \        0x0   0x....'....        DC32     SD_au8CMD8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_19:
   \        0x0   0x....'....        DC32     SD_au8ACMD41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_20:
   \        0x0   0x....'....        DC32     SD_au8CMD55

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_21:
   \        0x0   0x....'....        DC32     SD_au8CMD58

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_22:
   \        0x0   0x....'....        DC32     SD_au8CMD16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_23:
   \        0x0   0x....'....        DC32     SdCardSM_ResponseCMD55

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_24:
   \        0x0   0x....'....        DC32     SD_au8CardReady

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_25:
   \        0x0   0x....'....        DC32     SdCardSM_ResponseCMD16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_26:
   \        0x0   0x....'....        DC32     `SdCardSM_WaitResponse::u8Retries`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_27:
   \        0x0   0x....'....        DC32     SdCardSM_WaitSSP

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_28:
   \        0x0   0x....'....        DC32     SdCardSM_ReadyIdle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_29:
   \        0x0   0x....'....        DC32     SD_au8CMD17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_30:
   \        0x0   0x....'....        DC32     SdCardSM_WaitStartToken

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_31:
   \        0x0   0x....'....        DC32     SD_au8CardError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_32:
   \        0x0   0x....'....        DC32     SD_au8CardError1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_33:
   \        0x0   0x....'....        DC32     SD_au8CardError2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_34:
   \        0x0   0x....'....        DC32     SD_au8CardError3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_35:
   \        0x0   0x....'....        DC32     SD_au8CardError4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_36:
   \        0x0   0x....'....        DC32     SD_au8CardError5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_37:
   \        0x0   0x....'....        DC32     SD_au8CardError0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x53 0x64          DC8 "SdCard task disabled\012\015"
   \              0x43 0x61    
   \              0x72 0x64    
   \              0x20 0x74    
   \              0x61 0x73    
   \              0x6B 0x20    
   \              0x64 0x69    
   \              0x73 0x61    
   \              0x62 0x6C    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \       0x17   0x00               DC8 0
   1199          #endif /* ENABLE_SD */
   1200          
   1201          
   1202          
   1203          /*--------------------------------------------------------------------------------------------------------------------*/
   1204          /* End of File */
   1205          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CheckTimeout
         8   -> IsTimeUp
      32   SdCardInitialize
        32   -> DebugPrintf
        32   -> __aeabi_memcpy
       8   SdCardRunActiveState
         8   -- Indirect call
       8   SdCardSM_DataTransfer
         8   -> IsTimeUp
         8   -> SspDeAssertCS
         8   -> SspQueryReceiveStatus
         8   -> SspRelease
       0   SdCardSM_Disabled
       8   SdCardSM_Dummies
         8   -> SdCommand
         8   -> SspQueryReceiveStatus
       8   SdCardSM_Error
         8   -> DebugPrintf
         8   -> SspDeAssertCS
         8   -> SspRelease
       8   SdCardSM_FailedDataTransfer
         8   -> SspDeAssertCS
         8   -> SspRelease
       8   SdCardSM_IdleNoCard
         8   -> DebugPrintf
         8   -> SdIsCardInserted
         8   -> SspDeAssertCS
         8   -> SspReadData
         8   -> SspRequest
       8   SdCardSM_ReadCMD58
         8   -> CheckTimeout
         8   -> DebugPrintf
         8   -> SdCommand
         8   -> SspDeAssertCS
         8   -> SspQueryReceiveStatus
         8   -> SspRelease
       8   SdCardSM_ReadCMD8
         8   -> CheckTimeout
         8   -> SdCommand
         8   -> SspDeAssertCS
         8   -> SspQueryReceiveStatus
      16   SdCardSM_ReadyIdle
        16   -> DebugPrintf
        16   -> SdCommand
        16   -> SdIsCardInserted
        16   -> SspRequest
       8   SdCardSM_ResponseACMD41
         8   -> SdCommand
         8   -> SspDeAssertCS
       8   SdCardSM_ResponseCMD0
         8   -> SdCommand
         8   -> SspDeAssertCS
       8   SdCardSM_ResponseCMD16
         8   -> DebugPrintf
         8   -> SspDeAssertCS
         8   -> SspRelease
       8   SdCardSM_ResponseCMD17
         8   -> SspReadByte
       8   SdCardSM_ResponseCMD55
         8   -> SdCommand
         8   -> SspDeAssertCS
       8   SdCardSM_ResponseCMD58
         8   -> SspReadData
       8   SdCardSM_ResponseCMD8
         8   -> SdCommand
         8   -> SspDeAssertCS
         8   -> SspReadData
       8   SdCardSM_WaitCommand
         8   -> IsTimeUp
         8   -> QueryMessageStatus
         8   -> SspReadByte
       8   SdCardSM_WaitResponse
         8   -> IsTimeUp
         8   -> SspQueryReceiveStatus
         8   -> SspReadByte
       8   SdCardSM_WaitSSP
         8   -> IsTimeUp
       8   SdCardSM_WaitStartToken
         8   -> IsTimeUp
         8   -> SspQueryReceiveStatus
         8   -> SspReadByte
         8   -> SspReadData
      16   SdCommand
        16   -> SspAssertCS
        16   -> SspWriteData
       0   SdGetReadData
       0   SdGetStatus
       0   SdIsCardInserted
       4   SdReadBlock
       0   SdWriteBlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_10
       4  ??DataTable26_11
       4  ??DataTable26_12
       4  ??DataTable26_13
       4  ??DataTable26_14
       4  ??DataTable26_15
       4  ??DataTable26_16
       4  ??DataTable26_17
       4  ??DataTable26_18
       4  ??DataTable26_19
       4  ??DataTable26_2
       4  ??DataTable26_20
       4  ??DataTable26_21
       4  ??DataTable26_22
       4  ??DataTable26_23
       4  ??DataTable26_24
       4  ??DataTable26_25
       4  ??DataTable26_26
       4  ??DataTable26_27
       4  ??DataTable26_28
       4  ??DataTable26_29
       4  ??DataTable26_3
       4  ??DataTable26_30
       4  ??DataTable26_31
       4  ??DataTable26_32
       4  ??DataTable26_33
       4  ??DataTable26_34
       4  ??DataTable26_35
       4  ??DataTable26_36
       4  ??DataTable26_37
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable26_6
       4  ??DataTable26_7
       4  ??DataTable26_8
       4  ??DataTable26_9
      24  ?_0
      38  CheckTimeout
       4  G_u32SdCardFlags
       1  SD_CardState
       4  SD_Ssp
       8  SD_au8ACMD41
       8  SD_au8CMD0
       8  SD_au8CMD16
       8  SD_au8CMD17
       8  SD_au8CMD55
       8  SD_au8CMD58
       8  SD_au8CMD8
      12  SD_au8CardError
      12  SD_au8CardError0
      12  SD_au8CardError1
      16  SD_au8CardError2
      16  SD_au8CardError3
      12  SD_au8CardError4
      16  SD_au8CardError5
      12  SD_au8CardReady
     548  SD_au8RxBuffer
      20  SD_au8SspRequestFailed
       4  SD_pfStateMachine
       4  SD_pfWaitReturnState
      36  SD_sSspConfig
       4  SD_u32Address
       4  SD_u32CurrentMsgToken
       4  SD_u32Flags
       4  SD_u32Timeout
       1  SD_u8ErrorCode
      48  SdCardInitialize
      12  SdCardRunActiveState
      68  SdCardSM_DataTransfer
       2  SdCardSM_Disabled
      36  SdCardSM_Dummies
     102  SdCardSM_Error
      38  SdCardSM_FailedDataTransfer
     134  SdCardSM_IdleNoCard
     114  SdCardSM_ReadCMD58
      86  SdCardSM_ReadCMD8
     158  SdCardSM_ReadyIdle
     100  SdCardSM_ResponseACMD41
      62  SdCardSM_ResponseCMD0
      76  SdCardSM_ResponseCMD16
      72  SdCardSM_ResponseCMD17
      84  SdCardSM_ResponseCMD55
      80  SdCardSM_ResponseCMD58
     114  SdCardSM_ResponseCMD8
      96  SdCardSM_WaitCommand
     144  SdCardSM_WaitResponse
      26  SdCardSM_WaitSSP
     122  SdCardSM_WaitStartToken
      80  SdCommand
      54  SdGetReadData
       8  SdGetStatus
      50  SdIsCardInserted
      54  SdReadBlock
       6  SdWriteBlock
       1  u8Retries

 
   618 bytes in section .bss
   185 bytes in section .data
    24 bytes in section .rodata
 2 216 bytes in section .text
 
 2 216 bytes of CODE  memory
    24 bytes of CONST memory
   803 bytes of DATA  memory

Errors: none
Warnings: 2
