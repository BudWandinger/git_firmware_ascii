###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.2.160/W32 for ARM         14/Oct/2018  14:43:38
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_common\drivers\sam3u_i2c.c
#    Command line =  
#        -f C:\Users\BUDWA_~1\AppData\Local\Temp\EWE0F5.tmp
#        (C:\Embedded\Firmware\git_Razor_Atmel\firmware_common\drivers\sam3u_i2c.c
#        -D EIE1 --preprocess=c
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List
#        -lC
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List
#        -o
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\ -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\bsp\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\drivers\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\application\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.1\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List\sam3u_i2c.lst
#    Object file  =  
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\Obj\sam3u_i2c.o
#
###############################################################################

C:\Embedded\Firmware\git_Razor_Atmel\firmware_common\drivers\sam3u_i2c.c
      1          /**********************************************************************************************************************
      2          File: sam3u_TWI.c                                                                
      3          
      4          Description: 
      5          Provides a driver to use TWI0 peripheral to send and receive data using interrupts.
      6          Currently Set at - 200kHz Master Mode.
      7          This is a simpler version of a serial system driver that does not use resource control
      8          through Request() and Release() calls
      9          
     10          
     11          ------------------------------------------------------------------------------------------------------------------------
     12          API:
     13          
     14          Public use Functions:
     15          
     16          bool TWI0ReadByte(u8 u8SlaveAddress_, u8* pu8RxBuffer_);
     17          bool TWI0ReadData(u8 u8SlaveAddress_, u8* pu8RxBuffer_, u32 u32Size_);
     18          u32 TWIWriteByte(TWIPeripheralType* psTWIPeripheral_, u8 u8Byte_, TWIStopType Send_);
     19          u32 TWIWriteData(TWIPeripheralType* psTWIPeripheral_, u32 u32Size_, u8* u8Data_, TWIStopType Send_);
     20          
     21          All of these functions return a value that should be checked to ensure the operation will be completed
     22          
     23          Both TWI0ReadByte and TWI0ReadData require that pu8RxBuffer is large enough to hold the data
     24          As well it is assumed, that since you know the amount of data to be sent, a stop can be sent
     25          when all bytes have benn received (and not tie the data and clock line low).
     26          
     27          WriteByte and WriteData have the option to hold the lines low as it waits for more data 
     28          to be queue. If a stop condition is not sent only Writes can follow until a stop condition is
     29          requested (as the current transmission isn't complete).
     30          
     31          !!!!! ISSUES: 
     32              - No Debugging of Read functionality
     33          
     34          **********************************************************************************************************************/
     35          
     36          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0x6   0x408A             LSLS     R2,R2,R1
   \        0x8   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0xe000e100
   \        0xC   0x0003             MOVS     R3,R0
   \        0xE   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \       0x10   0x095B             LSRS     R3,R3,#+5
   \       0x12   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \       0x16   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0x6   0x408A             LSLS     R2,R2,R1
   \        0x8   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0xe000e280
   \        0xC   0x0003             MOVS     R3,R0
   \        0xE   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \       0x10   0x095B             LSRS     R3,R3,#+5
   \       0x12   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \       0x16   0x4770             BX       LR               ;; return
     37          
     38          
     39          /***********************************************************************************************************************
     40          Global variable definitions with scope across entire project.
     41          All Global variable names shall start with "G_"
     42          ***********************************************************************************************************************/
     43          /* New variables */
     44          
     45          /*--------------------------------------------------------------------------------------------------------------------*/
     46          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     47          extern volatile u32 G_u32SystemTime1ms;        /* From board-specific source file */
     48          extern volatile u32 G_u32SystemTime1s;         /* From board-specific source file */
     49          
     50          extern volatile u32 G_u32SystemFlags;          /* From main.c */
     51          extern volatile u32 G_u32ApplicationFlags;     /* From main.c */
     52          
     53          
     54          /***********************************************************************************************************************
     55          Global variable definitions with scope limited to this local application.
     56          Variable names shall start with "TWI_" and be declared as static.
     57          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     58          static fnCode_type TWI_StateMachine;              /* The TWI application state machine function pointer */
   \                     TWI_StateMachine:
   \        0x0                      DS8 4
     59          

   \                                 In section .bss, align 4
     60          static u32 TWI_u32Timer;                          /* Counter used across states */
   \                     TWI_u32Timer:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     61          static u32 TWI_u32Flags;                          /* Application flags for TWI */
   \                     TWI_u32Flags:
   \        0x0                      DS8 4
     62          

   \                                 In section .bss, align 4
     63          static TWIPeripheralType TWI_Peripheral0;         /* TWI0 peripheral object */
   \                     TWI_Peripheral0:
   \        0x0                      DS8 16

   \                                 In section .bss, align 4
     64          static TWIPeripheralType* TWI0;
   \                     TWI0:
   \        0x0                      DS8 4
     65          

   \                                 In section .bss, align 4
     66          static u32 TWI_u32CurrentBytesRemaining;                        /* Down counter for number of bytes being clocked out */
   \                     TWI_u32CurrentBytesRemaining:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     67          static u8* TWI_pu8CurrentTxData;                                /* Pointer to current message being clocked out */
   \                     TWI_pu8CurrentTxData:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     68          static TWIMessageQueueType TWI_MessageBuffer[TX_QUEUE_SIZE];    /* A circular buffer that stores queued msgs stop condition */
   \                     TWI_MessageBuffer:
   \        0x0                      DS8 256

   \                                 In section .bss, align 1
     69          static u8 TWI_MessageBufferNextIndex;                           /* A pointer to the next position to place a message */
   \                     TWI_MessageBufferNextIndex:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
     70          static u8 TWI_MessageBufferCurIndex;                            /* A pointer to the current message that is being processed */
   \                     TWI_MessageBufferCurIndex:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
     71          static u8 TWI_MessageQueueLength;                               /* Counter to track the number of messages stored in the queue */
   \                     TWI_MessageQueueLength:
   \        0x0                      DS8 1
     72          
     73          
     74          /***********************************************************************************************************************
     75          Function Definitions
     76          ***********************************************************************************************************************/
     77          
     78          /*----------------------------------------------------------------------------------------------------------------------
     79          Function: TWI0ReadByte
     80          
     81          Description:
     82          Queues a TWI Read Message into TWI_MessageBuffer, will be processed after all msgs queued before it
     83            - Single byte
     84          
     85          Requires:
     86            - Initialization of the task
     87            - Requires that pu8RxBuffer has the space to save the data
     88          
     89          Promises:
     90            - Queues msg if there is space available
     91            - Returns TRUE if successful queue
     92          */

   \                                 In section .text, align 2, keep-with-next
     93          bool TWI0ReadByte(u8 u8SlaveAddress_, u8* pu8RxBuffer_)
     94          {
   \                     TWI0ReadByte: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
     95            if(TWI_MessageQueueLength == TX_QUEUE_SIZE || (TWI0->u32Flags & _TWI_TRANS_NOT_COMP))
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \        0xA   0x7801             LDRB     R1,[R0, #+0]
   \        0xC   0x2910             CMP      R1,#+16
   \        0xE   0xD005             BEQ.N    ??TWI0ReadByte_0
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \       0x14   0x6809             LDR      R1,[R1, #+0]
   \       0x16   0x7B09             LDRB     R1,[R1, #+12]
   \       0x18   0x0749             LSLS     R1,R1,#+29
   \       0x1A   0xD501             BPL.N    ??TWI0ReadByte_1
     96            {
     97              /* TWI Message Task Queue Full or the Tx transmit isn't complete */
     98              return FALSE;
   \                     ??TWI0ReadByte_0: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xE031             B.N      ??TWI0ReadByte_2
     99            }
    100            else
    101            {
    102              /* Queue Relevant data for TWI register setup */
    103              TWI_MessageBuffer[TWI_MessageBufferNextIndex].Direction     = READ;
   \                     ??TWI0ReadByte_1: (+1)
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \       0x24   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \       0x28   0x2301             MOVS     R3,#+1
   \       0x2A   0x780E             LDRB     R6,[R1, #+0]
   \       0x2C   0x0136             LSLS     R6,R6,#+4
   \       0x2E   0x5593             STRB     R3,[R2, R6]
    104              TWI_MessageBuffer[TWI_MessageBufferNextIndex].u32Size       = 1;
   \       0x30   0x780B             LDRB     R3,[R1, #+0]
   \       0x32   0x011B             LSLS     R3,R3,#+4
   \       0x34   0x4413             ADD      R3,R2,R3
   \       0x36   0x2601             MOVS     R6,#+1
   \       0x38   0x605E             STR      R6,[R3, #+4]
    105              TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Address     = u8SlaveAddress_;
   \       0x3A   0x780B             LDRB     R3,[R1, #+0]
   \       0x3C   0x011B             LSLS     R3,R3,#+4
   \       0x3E   0x4413             ADD      R3,R2,R3
   \       0x40   0x721C             STRB     R4,[R3, #+8]
    106              TWI_MessageBuffer[TWI_MessageBufferNextIndex].pu8RxBuffer   = pu8RxBuffer_;
   \       0x42   0x780B             LDRB     R3,[R1, #+0]
   \       0x44   0x011B             LSLS     R3,R3,#+4
   \       0x46   0x4413             ADD      R3,R2,R3
   \       0x48   0x60DD             STR      R5,[R3, #+12]
    107              TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Attempts    = 0;
   \       0x4A   0x780B             LDRB     R3,[R1, #+0]
   \       0x4C   0x011B             LSLS     R3,R3,#+4
   \       0x4E   0x4413             ADD      R3,R2,R3
   \       0x50   0x2600             MOVS     R6,#+0
   \       0x52   0x725E             STRB     R6,[R3, #+9]
    108              
    109              /* Not used by Receive */
    110              TWI_MessageBuffer[TWI_MessageBufferNextIndex].Stop = NA; 
   \       0x54   0x780B             LDRB     R3,[R1, #+0]
   \       0x56   0x011B             LSLS     R3,R3,#+4
   \       0x58   0x441A             ADD      R2,R2,R3
   \       0x5A   0x2302             MOVS     R3,#+2
   \       0x5C   0x7293             STRB     R3,[R2, #+10]
    111               
    112              /* Update array pointers and size */
    113              TWI_MessageBufferNextIndex++;
   \       0x5E   0x780A             LDRB     R2,[R1, #+0]
   \       0x60   0x1C52             ADDS     R2,R2,#+1
   \       0x62   0x700A             STRB     R2,[R1, #+0]
    114              TWI_MessageQueueLength++;
   \       0x64   0x7802             LDRB     R2,[R0, #+0]
   \       0x66   0x1C52             ADDS     R2,R2,#+1
   \       0x68   0x7002             STRB     R2,[R0, #+0]
    115              if(TWI_MessageBufferNextIndex == TX_QUEUE_SIZE)
   \       0x6A   0x7808             LDRB     R0,[R1, #+0]
   \       0x6C   0x2810             CMP      R0,#+16
   \       0x6E   0xD101             BNE.N    ??TWI0ReadByte_3
    116              {
    117                TWI_MessageBufferNextIndex = 0;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x7008             STRB     R0,[R1, #+0]
    118              }
    119              
    120              /* If the system is initializing, we want to manually cycle the TWI task through one iteration
    121                to send the message */
    122              if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \                     ??TWI0ReadByte_3: (+1)
   \       0x74   0x.... 0x....      LDR.W    R0,??DataTable14_6
   \       0x78   0x6800             LDR      R0,[R0, #+0]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD501             BPL.N    ??TWI0ReadByte_4
    123              {
    124                TWIManualMode();
   \       0x7E   0x.... 0x....      BL       TWIManualMode
    125              }
    126              
    127              return TRUE;
   \                     ??TWI0ReadByte_4: (+1)
   \       0x82   0x2001             MOVS     R0,#+1
   \                     ??TWI0ReadByte_2: (+1)
   \       0x84   0xBD70             POP      {R4-R6,PC}       ;; return
    128            }
    129          
    130          } /* end TWI0ReadByte() */
    131          
    132          
    133          /*----------------------------------------------------------------------------------------------------------------------
    134          Function: TWI0ReadData
    135          
    136          Description:
    137          Queues a TWI Read Message into TWI_MessageBuffer, will be processed after all msgs queued before it
    138          
    139          Requires:
    140            - Initialization of the task
    141            - Requires pu8RxBuffer has the space to save the data
    142          
    143          Promises:
    144            - Queues a multi byte command into the command array
    145            - Returns TRUE if the queue was successful
    146          */

   \                                 In section .text, align 2, keep-with-next
    147          bool TWI0ReadData(u8 u8SlaveAddress_, u8* pu8RxBuffer_, u32 u32Size_)
    148          {
   \                     TWI0ReadData: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    149            if(TWI_MessageQueueLength == TX_QUEUE_SIZE || (TWI0->u32Flags & _TWI_TRANS_NOT_COMP))
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \        0xC   0x7801             LDRB     R1,[R0, #+0]
   \        0xE   0x2910             CMP      R1,#+16
   \       0x10   0xD005             BEQ.N    ??TWI0ReadData_0
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \       0x16   0x6809             LDR      R1,[R1, #+0]
   \       0x18   0x7B09             LDRB     R1,[R1, #+12]
   \       0x1A   0x0749             LSLS     R1,R1,#+29
   \       0x1C   0xD501             BPL.N    ??TWI0ReadData_1
    150            {
    151              /* TWI Message Task Queue Full or the Tx transmit isn't complete */
    152              return FALSE;
   \                     ??TWI0ReadData_0: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xE030             B.N      ??TWI0ReadData_2
    153            }
    154            else
    155            {
    156              /* Queue Relevant data for TWI register setup */
    157              TWI_MessageBuffer[TWI_MessageBufferNextIndex].Direction     = READ;
   \                     ??TWI0ReadData_1: (+1)
   \       0x22   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \       0x26   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \       0x2A   0x2301             MOVS     R3,#+1
   \       0x2C   0x780F             LDRB     R7,[R1, #+0]
   \       0x2E   0x013F             LSLS     R7,R7,#+4
   \       0x30   0x55D3             STRB     R3,[R2, R7]
    158              TWI_MessageBuffer[TWI_MessageBufferNextIndex].u32Size       = u32Size_;
   \       0x32   0x780B             LDRB     R3,[R1, #+0]
   \       0x34   0x011B             LSLS     R3,R3,#+4
   \       0x36   0x4413             ADD      R3,R2,R3
   \       0x38   0x605E             STR      R6,[R3, #+4]
    159              TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Address     = u8SlaveAddress_;
   \       0x3A   0x780B             LDRB     R3,[R1, #+0]
   \       0x3C   0x011B             LSLS     R3,R3,#+4
   \       0x3E   0x4413             ADD      R3,R2,R3
   \       0x40   0x721C             STRB     R4,[R3, #+8]
    160              TWI_MessageBuffer[TWI_MessageBufferNextIndex].pu8RxBuffer   = pu8RxBuffer_;
   \       0x42   0x780B             LDRB     R3,[R1, #+0]
   \       0x44   0x011B             LSLS     R3,R3,#+4
   \       0x46   0x4413             ADD      R3,R2,R3
   \       0x48   0x60DD             STR      R5,[R3, #+12]
    161              TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Attempts    = 0;
   \       0x4A   0x780B             LDRB     R3,[R1, #+0]
   \       0x4C   0x011B             LSLS     R3,R3,#+4
   \       0x4E   0x4413             ADD      R3,R2,R3
   \       0x50   0x2700             MOVS     R7,#+0
   \       0x52   0x725F             STRB     R7,[R3, #+9]
    162              
    163              /* Not used by Receive */
    164              TWI_MessageBuffer[TWI_MessageBufferNextIndex].Stop = NA; 
   \       0x54   0x780B             LDRB     R3,[R1, #+0]
   \       0x56   0x011B             LSLS     R3,R3,#+4
   \       0x58   0x441A             ADD      R2,R2,R3
   \       0x5A   0x2302             MOVS     R3,#+2
   \       0x5C   0x7293             STRB     R3,[R2, #+10]
    165              
    166              /* Update array pointers and size */
    167              TWI_MessageBufferNextIndex++;
   \       0x5E   0x780A             LDRB     R2,[R1, #+0]
   \       0x60   0x1C52             ADDS     R2,R2,#+1
   \       0x62   0x700A             STRB     R2,[R1, #+0]
    168              TWI_MessageQueueLength++;
   \       0x64   0x7802             LDRB     R2,[R0, #+0]
   \       0x66   0x1C52             ADDS     R2,R2,#+1
   \       0x68   0x7002             STRB     R2,[R0, #+0]
    169              if(TWI_MessageBufferNextIndex == TX_QUEUE_SIZE)
   \       0x6A   0x7808             LDRB     R0,[R1, #+0]
   \       0x6C   0x2810             CMP      R0,#+16
   \       0x6E   0xD101             BNE.N    ??TWI0ReadData_3
    170              {
    171                TWI_MessageBufferNextIndex = 0;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x7008             STRB     R0,[R1, #+0]
    172              }
    173              
    174              /* If the system is initializing, we want to manually cycle the TWI task through one iteration
    175                to send the message */
    176              if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \                     ??TWI0ReadData_3: (+1)
   \       0x74   0x.... 0x....      LDR.W    R0,??DataTable14_6
   \       0x78   0x6800             LDR      R0,[R0, #+0]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD501             BPL.N    ??TWI0ReadData_4
    177              {
    178                TWIManualMode();
   \       0x7E   0x.... 0x....      BL       TWIManualMode
    179              }
    180              
    181              return TRUE;
   \                     ??TWI0ReadData_4: (+1)
   \       0x82   0x2001             MOVS     R0,#+1
   \                     ??TWI0ReadData_2: (+1)
   \       0x84   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    182            }
    183            
    184          } /* end TWI0ReadData() */
    185          
    186          
    187          /*----------------------------------------------------------------------------------------------------------------------
    188          Function: TWI0WriteByte
    189          
    190          Description:
    191          Queues a single byte for transfer on TWI0 peripheral.  
    192          
    193          Requires:
    194            - Initialization of the task
    195          
    196          Promises:
    197            - Creates a 1-byte message at TWI0->pTransmitBuffer that will be sent by the TWI application
    198              when it is available.
    199            - Returns the message token assigned to the message
    200          */

   \                                 In section .text, align 2, keep-with-next
    201          u32 TWI0WriteByte(u8 u8SlaveAddress_, u8 u8Byte_, TWIStopType Send_)
    202          {
   \                     TWI0WriteByte: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
    203            u32 u32Token;
    204            u8 u8Data = u8Byte_;
   \        0xA   0xF88D 0x6000      STRB     R6,[SP, #+0]
    205            
    206            if(TWI_MessageQueueLength == TX_QUEUE_SIZE)
   \        0xE   0x.... 0x....      LDR.W    R8,??DataTable14_2
   \       0x12   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x16   0x2810             CMP      R0,#+16
   \       0x18   0xD101             BNE.N    ??TWI0WriteByte_0
    207            {
    208              /* TWI Message Task Queue Full */
    209              return 0;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xE03E             B.N      ??TWI0WriteByte_1
    210            }
    211            else
    212            {
    213              /* Queue Message in message system */
    214              u32Token = QueueMessage(&TWI0->pTransmitBuffer, 1, &u8Data);
   \                     ??TWI0WriteByte_0: (+1)
   \       0x1E   0x466A             MOV      R2,SP
   \       0x20   0x2101             MOVS     R1,#+1
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \       0x26   0x6800             LDR      R0,[R0, #+0]
   \       0x28   0x1D00             ADDS     R0,R0,#+4
   \       0x2A   0x.... 0x....      BL       QueueMessage
   \       0x2E   0x0004             MOVS     R4,R0
    215              if(u32Token)
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD032             BEQ.N    ??TWI0WriteByte_2
    216              {
    217                /* Queue Relevant data for TWI register setup */
    218                TWI_MessageBuffer[TWI_MessageBufferNextIndex].Direction     = WRITE;
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \       0x38   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \       0x3C   0x2200             MOVS     R2,#+0
   \       0x3E   0x7803             LDRB     R3,[R0, #+0]
   \       0x40   0x011B             LSLS     R3,R3,#+4
   \       0x42   0x54CA             STRB     R2,[R1, R3]
    219                TWI_MessageBuffer[TWI_MessageBufferNextIndex].u32Size       = 1;
   \       0x44   0x7802             LDRB     R2,[R0, #+0]
   \       0x46   0x0112             LSLS     R2,R2,#+4
   \       0x48   0x440A             ADD      R2,R1,R2
   \       0x4A   0x2301             MOVS     R3,#+1
   \       0x4C   0x6053             STR      R3,[R2, #+4]
    220                TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Address     = u8SlaveAddress_;
   \       0x4E   0x7802             LDRB     R2,[R0, #+0]
   \       0x50   0x0112             LSLS     R2,R2,#+4
   \       0x52   0x440A             ADD      R2,R1,R2
   \       0x54   0x7215             STRB     R5,[R2, #+8]
    221                TWI_MessageBuffer[TWI_MessageBufferNextIndex].Stop          = Send_;
   \       0x56   0x7802             LDRB     R2,[R0, #+0]
   \       0x58   0x0112             LSLS     R2,R2,#+4
   \       0x5A   0x440A             ADD      R2,R1,R2
   \       0x5C   0x7297             STRB     R7,[R2, #+10]
    222                TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Attempts    = 0;
   \       0x5E   0x7802             LDRB     R2,[R0, #+0]
   \       0x60   0x0112             LSLS     R2,R2,#+4
   \       0x62   0x440A             ADD      R2,R1,R2
   \       0x64   0x2300             MOVS     R3,#+0
   \       0x66   0x7253             STRB     R3,[R2, #+9]
    223                
    224                /* Not used by Transmit */
    225                TWI_MessageBuffer[TWI_MessageBufferNextIndex].pu8RxBuffer = NULL;
   \       0x68   0x7802             LDRB     R2,[R0, #+0]
   \       0x6A   0x0112             LSLS     R2,R2,#+4
   \       0x6C   0x4411             ADD      R1,R1,R2
   \       0x6E   0x2200             MOVS     R2,#+0
   \       0x70   0x60CA             STR      R2,[R1, #+12]
    226                
    227                /* Update array pointers and size */
    228                TWI_MessageBufferNextIndex++;
   \       0x72   0x7801             LDRB     R1,[R0, #+0]
   \       0x74   0x1C49             ADDS     R1,R1,#+1
   \       0x76   0x7001             STRB     R1,[R0, #+0]
    229                TWI_MessageQueueLength++;
   \       0x78   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \       0x7C   0x1C49             ADDS     R1,R1,#+1
   \       0x7E   0xF888 0x1000      STRB     R1,[R8, #+0]
    230                if(TWI_MessageBufferNextIndex == TX_QUEUE_SIZE)
   \       0x82   0x7801             LDRB     R1,[R0, #+0]
   \       0x84   0x2910             CMP      R1,#+16
   \       0x86   0xD101             BNE.N    ??TWI0WriteByte_3
    231                {
    232                  TWI_MessageBufferNextIndex = 0;
   \       0x88   0x2100             MOVS     R1,#+0
   \       0x8A   0x7001             STRB     R1,[R0, #+0]
    233                }
    234          
    235                /* If the system is initializing, we want to manually cycle the TWI task through one iteration
    236                to send the message */
    237                if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \                     ??TWI0WriteByte_3: (+1)
   \       0x8C   0x.... 0x....      LDR.W    R0,??DataTable14_6
   \       0x90   0x6800             LDR      R0,[R0, #+0]
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD501             BPL.N    ??TWI0WriteByte_2
    238                {
    239                  TWIManualMode();
   \       0x96   0x.... 0x....      BL       TWIManualMode
    240                }
    241              }
    242              
    243              return(u32Token);
   \                     ??TWI0WriteByte_2: (+1)
   \       0x9A   0x0020             MOVS     R0,R4
   \                     ??TWI0WriteByte_1: (+1)
   \       0x9C   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    244            }
    245            
    246          } /* end TWIWriteByte() */
    247          
    248          
    249          /*----------------------------------------------------------------------------------------------------------------------
    250          Function: TWI0WriteData
    251          
    252          Description:
    253          Queues a data array for transfer on the  TWI0 peripheral.  
    254          
    255          Requires:
    256            - if a transmission is in progress, the node in the buffer that is currently being sent will not be destroyed during this function.
    257            - u32Size_ is the number of bytes in the data array
    258            - u8Data_ points to the first byte of the data array
    259          
    260          Promises:
    261            - adds the data message at TWI_Peripheral0->pTransmitBuffer buffer that will be sent by the TWI application
    262              when it is available.
    263            - Returns the message token assigned to the message; 0 is returned if the message cannot be queued in which case
    264              G_u32MessagingFlags can be checked for the reason
    265          */

   \                                 In section .text, align 2, keep-with-next
    266          u32 TWI0WriteData(u8 u8SlaveAddress_, u32 u32Size_, u8* u8Data_, TWIStopType Send_)
    267          {
   \                     TWI0WriteData: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
    268            u32 u32Token;
    269              
    270            if(TWI_MessageQueueLength == TX_QUEUE_SIZE)
   \        0xC   0x.... 0x....      LDR.W    R9,??DataTable14_2
   \       0x10   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \       0x14   0x2810             CMP      R0,#+16
   \       0x16   0xD101             BNE.N    ??TWI0WriteData_0
    271            {
    272              /* Queue Message in message system */
    273              return 0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xE03F             B.N      ??TWI0WriteData_1
    274            }
    275            else
    276            {
    277              /* Queue Message in message system */
    278              u32Token = QueueMessage(&TWI0->pTransmitBuffer, u32Size_, u8Data_);
   \                     ??TWI0WriteData_0: (+1)
   \       0x1C   0x003A             MOVS     R2,R7
   \       0x1E   0x0031             MOVS     R1,R6
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x1D00             ADDS     R0,R0,#+4
   \       0x28   0x.... 0x....      BL       QueueMessage
   \       0x2C   0x0004             MOVS     R4,R0
    279              if(u32Token)
   \       0x2E   0x2C00             CMP      R4,#+0
   \       0x30   0xD033             BEQ.N    ??TWI0WriteData_2
    280              {
    281                /* Queue Relevant data for TWI register setup */
    282                TWI_MessageBuffer[TWI_MessageBufferNextIndex].Direction     = WRITE;
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \       0x36   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \       0x3A   0x2200             MOVS     R2,#+0
   \       0x3C   0x7803             LDRB     R3,[R0, #+0]
   \       0x3E   0x011B             LSLS     R3,R3,#+4
   \       0x40   0x54CA             STRB     R2,[R1, R3]
    283                TWI_MessageBuffer[TWI_MessageBufferNextIndex].u32Size       = 1;
   \       0x42   0x7802             LDRB     R2,[R0, #+0]
   \       0x44   0x0112             LSLS     R2,R2,#+4
   \       0x46   0x440A             ADD      R2,R1,R2
   \       0x48   0x2301             MOVS     R3,#+1
   \       0x4A   0x6053             STR      R3,[R2, #+4]
    284                TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Address     = u8SlaveAddress_;
   \       0x4C   0x7802             LDRB     R2,[R0, #+0]
   \       0x4E   0x0112             LSLS     R2,R2,#+4
   \       0x50   0x440A             ADD      R2,R1,R2
   \       0x52   0x7215             STRB     R5,[R2, #+8]
    285                TWI_MessageBuffer[TWI_MessageBufferNextIndex].Stop          = Send_;
   \       0x54   0x7802             LDRB     R2,[R0, #+0]
   \       0x56   0x0112             LSLS     R2,R2,#+4
   \       0x58   0x440A             ADD      R2,R1,R2
   \       0x5A   0xF882 0x800A      STRB     R8,[R2, #+10]
    286                TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Attempts    = 0;
   \       0x5E   0x7802             LDRB     R2,[R0, #+0]
   \       0x60   0x0112             LSLS     R2,R2,#+4
   \       0x62   0x440A             ADD      R2,R1,R2
   \       0x64   0x2300             MOVS     R3,#+0
   \       0x66   0x7253             STRB     R3,[R2, #+9]
    287                
    288                /* Not used by Transmit */
    289                TWI_MessageBuffer[TWI_MessageBufferNextIndex].pu8RxBuffer = NULL;
   \       0x68   0x7802             LDRB     R2,[R0, #+0]
   \       0x6A   0x0112             LSLS     R2,R2,#+4
   \       0x6C   0x4411             ADD      R1,R1,R2
   \       0x6E   0x2200             MOVS     R2,#+0
   \       0x70   0x60CA             STR      R2,[R1, #+12]
    290                
    291                /* Update array pointers and size */
    292                TWI_MessageBufferNextIndex++;
   \       0x72   0x7801             LDRB     R1,[R0, #+0]
   \       0x74   0x1C49             ADDS     R1,R1,#+1
   \       0x76   0x7001             STRB     R1,[R0, #+0]
    293                TWI_MessageQueueLength++;
   \       0x78   0xF899 0x1000      LDRB     R1,[R9, #+0]
   \       0x7C   0x1C49             ADDS     R1,R1,#+1
   \       0x7E   0xF889 0x1000      STRB     R1,[R9, #+0]
    294                if(TWI_MessageBufferNextIndex == TX_QUEUE_SIZE)
   \       0x82   0x7801             LDRB     R1,[R0, #+0]
   \       0x84   0x2910             CMP      R1,#+16
   \       0x86   0xD101             BNE.N    ??TWI0WriteData_3
    295                {
    296                  TWI_MessageBufferNextIndex = 0;
   \       0x88   0x2100             MOVS     R1,#+0
   \       0x8A   0x7001             STRB     R1,[R0, #+0]
    297                }
    298          
    299                /* If the system is initializing, manually cycle the TWI task through one iteration to send the message */
    300                if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \                     ??TWI0WriteData_3: (+1)
   \       0x8C   0x.... 0x....      LDR.W    R0,??DataTable14_6
   \       0x90   0x6800             LDR      R0,[R0, #+0]
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD501             BPL.N    ??TWI0WriteData_2
    301                {
    302                  TWIManualMode();
   \       0x96   0x.... 0x....      BL       TWIManualMode
    303                }
    304              }
    305            
    306              return(u32Token);
   \                     ??TWI0WriteData_2: (+1)
   \       0x9A   0x0020             MOVS     R0,R4
   \                     ??TWI0WriteData_1: (+1)
   \       0x9C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    307            }
    308            
    309          } /* end TWIWriteData() */
    310          
    311          
    312          /*--------------------------------------------------------------------------------------------------------------------*/
    313          /* Protected Functions */
    314          /*--------------------------------------------------------------------------------------------------------------------*/
    315          
    316          /*----------------------------------------------------------------------------------------------------------------------
    317          Function: TWIInitialize
    318          
    319          Description:
    320          Initializes the TWI application and its variables. 
    321          
    322          Requires:
    323            - 
    324          
    325          Promises:
    326            - TWI peripheral objects are ready 
    327            - TWI application set to Idle
    328          */

   \                                 In section .text, align 2, keep-with-next
    329          void TWIInitialize(void)
    330          {
   \                     TWIInitialize: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    331            u32 u32TargetPerpipheralNumber = AT91C_ID_TWI0;
   \        0x2   0x2412             MOVS     R4,#+18
    332            
    333            AT91C_BASE_PMC->PMC_PCER |= (1<<u32TargetPerpipheralNumber);
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable14_7  ;; 0x400e0410
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0x2201             MOVS     R2,#+1
   \        0xC   0x40A2             LSLS     R2,R2,R4
   \        0xE   0x4311             ORRS     R1,R2,R1
   \       0x10   0x6001             STR      R1,[R0, #+0]
    334            
    335            TWI_u32Flags = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \       0x18   0x6008             STR      R0,[R1, #+0]
    336            TWI0 = &TWI_Peripheral0;
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable14_9
   \       0x1E   0x.... 0x....      LDR.W    R5,??DataTable14_3
   \       0x22   0x6028             STR      R0,[R5, #+0]
    337            TWI_MessageBufferNextIndex = 0;
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x.... 0x....      LDR.W    R2,??DataTable14_4
   \       0x2A   0x7011             STRB     R1,[R2, #+0]
    338            TWI_MessageBufferCurIndex = 0;
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x.... 0x....      LDR.W    R2,??DataTable14_10
   \       0x32   0x7011             STRB     R1,[R2, #+0]
    339            TWI_MessageQueueLength = 0;
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x.... 0x....      LDR.W    R2,??DataTable14_2
   \       0x3A   0x7011             STRB     R1,[R2, #+0]
    340            
    341            /* Initialize the TWI peripheral structures */
    342            TWI_Peripheral0.pBaseAddress    = AT91C_BASE_TWI0;
   \       0x3C   0x.... 0x....      LDR.W    R1,??DataTable14_11  ;; 0x40084000
   \       0x40   0x6001             STR      R1,[R0, #+0]
    343            TWI_Peripheral0.pTransmitBuffer = NULL;
   \       0x42   0x2100             MOVS     R1,#+0
   \       0x44   0x6041             STR      R1,[R0, #+4]
    344            TWI_Peripheral0.pu8RxBuffer     = NULL;
   \       0x46   0x2100             MOVS     R1,#+0
   \       0x48   0x6081             STR      R1,[R0, #+8]
    345            TWI_Peripheral0.u32Flags        = 0;
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0x60C1             STR      R1,[R0, #+12]
    346          
    347            /* Software reset of peripheral */
    348            TWI0->pBaseAddress->TWI_CR   |= _TWI_CR_SWRST_BIT;
   \       0x4E   0x6828             LDR      R0,[R5, #+0]
   \       0x50   0x6800             LDR      R0,[R0, #+0]
   \       0x52   0x6800             LDR      R0,[R0, #+0]
   \       0x54   0xF050 0x0080      ORRS     R0,R0,#0x80
   \       0x58   0x6829             LDR      R1,[R5, #+0]
   \       0x5A   0x6809             LDR      R1,[R1, #+0]
   \       0x5C   0x6008             STR      R0,[R1, #+0]
    349            TWI_u32Timer = G_u32SystemTime1ms;
   \       0x5E   0x.... 0x....      LDR.W    R6,??DataTable14_12
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \       0x66   0x6800             LDR      R0,[R0, #+0]
   \       0x68   0x6030             STR      R0,[R6, #+0]
    350            while( !IsTimeUp(&TWI_u32Timer, 5) );
   \                     ??TWIInitialize_0: (+1)
   \       0x6A   0x2105             MOVS     R1,#+5
   \       0x6C   0x0030             MOVS     R0,R6
   \       0x6E   0x.... 0x....      BL       IsTimeUp
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD0F9             BEQ.N    ??TWIInitialize_0
    351            
    352            /* Configure Peripheral */
    353            TWI0->pBaseAddress->TWI_CWGR = TWI0_CWGR_INIT;
   \       0x76   0x.... 0x....      LDR.W    R0,??DataTable14_14  ;; 0x21d1d
   \       0x7A   0x6829             LDR      R1,[R5, #+0]
   \       0x7C   0x6809             LDR      R1,[R1, #+0]
   \       0x7E   0x6108             STR      R0,[R1, #+16]
    354            TWI0->pBaseAddress->TWI_CR   = TWI0_CR_INIT;
   \       0x80   0x2024             MOVS     R0,#+36
   \       0x82   0x6829             LDR      R1,[R5, #+0]
   \       0x84   0x6809             LDR      R1,[R1, #+0]
   \       0x86   0x6008             STR      R0,[R1, #+0]
    355            TWI0->pBaseAddress->TWI_MMR  = TWI0_MMR_INIT;
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0x6829             LDR      R1,[R5, #+0]
   \       0x8C   0x6809             LDR      R1,[R1, #+0]
   \       0x8E   0x6048             STR      R0,[R1, #+4]
    356            TWI0->pBaseAddress->TWI_IER  = TWI0_IER_INIT;
   \       0x90   0xF44F 0x70A1      MOV      R0,#+322
   \       0x94   0x6829             LDR      R1,[R5, #+0]
   \       0x96   0x6809             LDR      R1,[R1, #+0]
   \       0x98   0x6248             STR      R0,[R1, #+36]
    357            TWI0->pBaseAddress->TWI_IDR  = TWI0_IDR_INIT;
   \       0x9A   0xF64F 0x6035      MOVW     R0,#+65077
   \       0x9E   0x6829             LDR      R1,[R5, #+0]
   \       0xA0   0x6809             LDR      R1,[R1, #+0]
   \       0xA2   0x6288             STR      R0,[R1, #+40]
    358            
    359            /* Enable TWI interrupts */
    360            NVIC_ClearPendingIRQ( (IRQn_Type)u32TargetPerpipheralNumber );
   \       0xA4   0x0020             MOVS     R0,R4
   \       0xA6   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \       0xA8   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    361            NVIC_EnableIRQ( (IRQn_Type)u32TargetPerpipheralNumber );
   \       0xAC   0x0020             MOVS     R0,R4
   \       0xAE   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \       0xB0   0x.... 0x....      BL       NVIC_EnableIRQ
    362          
    363            TWI_u32CurrentBytesRemaining   = 0;
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0x.... 0x....      LDR.W    R1,??DataTable14_15
   \       0xBA   0x6008             STR      R0,[R1, #+0]
    364            TWI_pu8CurrentTxData           = NULL;
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0x.... 0x....      LDR.W    R1,??DataTable14_16
   \       0xC2   0x6008             STR      R0,[R1, #+0]
    365          
    366            /* Set application pointer */
    367            TWI_StateMachine = TWISM_Idle;
   \       0xC4   0x.... 0x....      ADR.W    R0,TWISM_Idle
   \       0xC8   0x.... 0x....      LDR.W    R1,??DataTable14_17
   \       0xCC   0x6008             STR      R0,[R1, #+0]
    368            
    369          } /* end TWIInitialize() */
   \       0xCE   0xBD70             POP      {R4-R6,PC}       ;; return
    370          
    371          
    372          /*----------------------------------------------------------------------------------------------------------------------
    373          Function TWIRunActiveState()
    374          
    375          Description:
    376          Selects and runs one iteration of the current state in the state machine.
    377          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    378          may take 1ms / n to execute.
    379          
    380          Requires:
    381            - State machine function pointer points at current state
    382          
    383          Promises:
    384            - Calls the function to pointed by the state machine function pointer
    385          */

   \                                 In section .text, align 2, keep-with-next
    386          void TWIRunActiveState(void)
    387          {
   \                     TWIRunActiveState: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    388            TWI_StateMachine();
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable14_17
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x4780             BLX      R0
    389          
    390          } /* end TWIRunActiveState */
   \        0xA   0xBD01             POP      {R0,PC}          ;; return
    391          
    392          
    393          
    394          /*--------------------------------------------------------------------------------------------------------------------*/
    395          /* Protected Functions */
    396          /*--------------------------------------------------------------------------------------------------------------------*/
    397          
    398          /*----------------------------------------------------------------------------------------------------------------------
    399          Function: TWIFillTxBuffer
    400          
    401          Description:
    402          Fills the TWI peripheral buffer with bytes from the current messsage that is sending.  
    403          This function can be called from the TWI ISR!
    404          Note: if the implemented processor does not have a FIFO, this function can still be used but will only ever
    405          add one byte to the transmitter.
    406          
    407          Requires:
    408            - The TxBuffer is empty
    409            - TWI_pu8CurrentTxData points to the next byte in the message to be sent
    410            - TWI_u32CurrentBytesRemaining has an accurate count of the bytes remaining in the message data to be sent
    411            - Transmit interrupts are off
    412          
    413          Promises:
    414            - Data from *TWI_pu8CurrentTxData is added to the TWI peripheral Tx FIFO until the FIFO is full or there
    415              is no more data to send.
    416          */

   \                                 In section .text, align 2, keep-with-next
    417          static void TWI0FillTxBuffer(void)
    418          {
   \                     TWI0FillTxBuffer: (+1)
   \        0x0   0xB410             PUSH     {R4}
    419            u8 u8ByteCount = TWI_TX_FIFO_SIZE;
   \        0x2   0x2101             MOVS     R1,#+1
    420            
    421            /* Use the active global variables to fill up the transmit FIFO */
    422            while( (u8ByteCount != 0) && (TWI_u32CurrentBytesRemaining != 0) )
   \                     ??TWI0FillTxBuffer_0: (+1)
   \        0x4   0x0008             MOVS     R0,R1
   \        0x6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD015             BEQ.N    ??TWI0FillTxBuffer_1
   \        0xC   0x.... 0x....      LDR.W    R2,??DataTable14_15
   \       0x10   0x6810             LDR      R0,[R2, #+0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD010             BEQ.N    ??TWI0FillTxBuffer_1
    423            {
    424              TWI0->pBaseAddress->TWI_THR = *TWI_pu8CurrentTxData;
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable14_16
   \       0x1A   0x6803             LDR      R3,[R0, #+0]
   \       0x1C   0x781B             LDRB     R3,[R3, #+0]
   \       0x1E   0x.... 0x....      LDR.W    R4,??DataTable14_3
   \       0x22   0x6824             LDR      R4,[R4, #+0]
   \       0x24   0x6824             LDR      R4,[R4, #+0]
   \       0x26   0x6363             STR      R3,[R4, #+52]
    425              TWI_pu8CurrentTxData++;
   \       0x28   0x6803             LDR      R3,[R0, #+0]
   \       0x2A   0x1C5B             ADDS     R3,R3,#+1
   \       0x2C   0x6003             STR      R3,[R0, #+0]
    426              TWI_u32CurrentBytesRemaining--;
   \       0x2E   0x6810             LDR      R0,[R2, #+0]
   \       0x30   0x1E40             SUBS     R0,R0,#+1
   \       0x32   0x6010             STR      R0,[R2, #+0]
    427              u8ByteCount--;
   \       0x34   0x1E49             SUBS     R1,R1,#+1
   \       0x36   0xE7E5             B.N      ??TWI0FillTxBuffer_0
    428            }
    429            
    430            /* If there are no remaining bytes to load to the TX FIFO, disable the TWI transmit 
    431            FIFO empty interrupt */
    432            if(TWI_u32CurrentBytesRemaining == 0)
   \                     ??TWI0FillTxBuffer_1: (+1)
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable14_15
   \       0x3C   0x6800             LDR      R0,[R0, #+0]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD118             BNE.N    ??TWI0FillTxBuffer_2
    433            {
    434              TWI0->pBaseAddress->TWI_IDR = AT91C_TWI_TXRDY_MASTER;
   \       0x42   0x.... 0x....      LDR.W    R2,??DataTable14_3
   \       0x46   0x2004             MOVS     R0,#+4
   \       0x48   0x6813             LDR      R3,[R2, #+0]
   \       0x4A   0x681B             LDR      R3,[R3, #+0]
   \       0x4C   0x6298             STR      R0,[R3, #+40]
    435              if(TWI_MessageBuffer[TWI_MessageBufferCurIndex].Stop == STOP)
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \       0x52   0x.... 0x....      LDR.W    R3,??DataTable14_10
   \       0x56   0x781B             LDRB     R3,[R3, #+0]
   \       0x58   0x011B             LSLS     R3,R3,#+4
   \       0x5A   0x4418             ADD      R0,R0,R3
   \       0x5C   0x7A80             LDRB     R0,[R0, #+10]
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD10E             BNE.N    ??TWI0FillTxBuffer_3
    436              {
    437                TWI0->pBaseAddress->TWI_CR |= _TWI_CR_STOP_BIT;
   \       0x62   0x6810             LDR      R0,[R2, #+0]
   \       0x64   0x6800             LDR      R0,[R0, #+0]
   \       0x66   0x6800             LDR      R0,[R0, #+0]
   \       0x68   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x6C   0x6812             LDR      R2,[R2, #+0]
   \       0x6E   0x6812             LDR      R2,[R2, #+0]
   \       0x70   0x6010             STR      R0,[R2, #+0]
   \       0x72   0xE005             B.N      ??TWI0FillTxBuffer_3
    438              }
    439            }
    440            /* Otherwise make sure transmit interrupts are enabled */
    441            else
    442            {
    443              TWI0->pBaseAddress->TWI_IER = AT91C_TWI_TXRDY_MASTER;
   \                     ??TWI0FillTxBuffer_2: (+1)
   \       0x74   0x2004             MOVS     R0,#+4
   \       0x76   0x.... 0x....      LDR.W    R2,??DataTable14_3
   \       0x7A   0x6812             LDR      R2,[R2, #+0]
   \       0x7C   0x6812             LDR      R2,[R2, #+0]
   \       0x7E   0x6250             STR      R0,[R2, #+36]
    444            }
    445            
    446          } /* end TWIFillTxBuffer() */
   \                     ??TWI0FillTxBuffer_3: (+1)
   \       0x80   0xBC10             POP      {R4}
   \       0x82   0x4770             BX       LR               ;; return
    447          
    448          
    449          /*----------------------------------------------------------------------------------------------------------------------
    450          Function: TWIManualMode
    451          
    452          Description:
    453          Runs a transmit cycle of the TWI application to clock out a message.  This function is used only during
    454          initialization.
    455          
    456          Requires:
    457            - TWI application has been initialized.
    458          
    459          Promises:
    460            - All bytes currently in the TWI Rx FIFO are read out to the application receive circular buffer.
    461          */

   \                                 In section .text, align 2, keep-with-next
    462          static void TWIManualMode(void)
    463          {
   \                     TWIManualMode: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    464            TWI_u32Flags |=_TWI_INIT_MODE;
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable14_8
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0xF050 0x0001      ORRS     R0,R0,#0x1
   \        0xC   0x6020             STR      R0,[R4, #+0]
    465            TWI_u32Timer  = G_u32SystemTime1ms;
   \        0xE   0x.... 0x....      LDR.W    R5,??DataTable14_12
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x6028             STR      R0,[R5, #+0]
    466            
    467            while(TWI_u32Flags &_TWI_INIT_MODE)
   \                     ??TWIManualMode_0: (+1)
   \       0x1A   0x7820             LDRB     R0,[R4, #+0]
   \       0x1C   0x07C0             LSLS     R0,R0,#+31
   \       0x1E   0xD508             BPL.N    ??TWIManualMode_1
    468            {
    469              TWI_StateMachine();
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable14_17
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x4780             BLX      R0
    470              IsTimeUp(&TWI_u32Timer, 1);
   \       0x28   0x2101             MOVS     R1,#+1
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0x.... 0x....      BL       IsTimeUp
   \       0x30   0xE7F3             B.N      ??TWIManualMode_0
    471            }
    472                
    473          } /* end TWIManualMode() */
   \                     ??TWIManualMode_1: (+1)
   \       0x32   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    474          
    475          
    476          /*----------------------------------------------------------------------------------------------------------------------
    477          Function: TWI0_IrqHandler
    478          
    479          Description:
    480          Handles the TWI0 Peripheral interrupts
    481          
    482          Requires:
    483            - TWI application has been initialized.
    484          
    485          Promises:
    486            - More data has been queued or error flag raised
    487            - Or recieved byte is placed in desied buffer
    488          */

   \                                 In section .text, align 2, keep-with-next
    489          void TWI0_IrqHandler(void)
    490          {
   \                     TWI0_IrqHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    491            u32 u32InterruptStatus;
    492            
    493            /* Grab active interrupts and compare with status */
    494            u32InterruptStatus = AT91C_BASE_TWI0->TWI_IMR;
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable14_18  ;; 0x4008402c
   \        0x6   0x6804             LDR      R4,[R0, #+0]
    495            u32InterruptStatus &= AT91C_BASE_TWI0->TWI_SR;
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable14_19  ;; 0x40084020
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x4004             ANDS     R4,R0,R4
    496            
    497            /* NACK Received */
    498            if(u32InterruptStatus & _TWI_SR_NACK )
   \       0x10   0x05E0             LSLS     R0,R4,#+23
   \       0x12   0xD506             BPL.N    ??TWI0_IrqHandler_0
    499            {
    500              /* Error has occurred, reset the msg */
    501              TWI_u32Flags |= _TWI_ERROR_NACK;
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0xF051 0x7180      ORRS     R1,R1,#0x1000000
   \       0x1E   0x6001             STR      R1,[R0, #+0]
   \       0x20   0xE030             B.N      ??TWI0_IrqHandler_1
    502              
    503            }
    504            /* Receiving Bytes */
    505            else if(u32InterruptStatus & _TWI_SR_RXRDY && ( TWI0->u32Flags & _TWI_RECEIVING ) )
   \                     ??TWI0_IrqHandler_0: (+1)
   \       0x22   0x07A0             LSLS     R0,R4,#+30
   \       0x24   0xD51F             BPL.N    ??TWI0_IrqHandler_2
   \       0x26   0x....             LDR.N    R0,??DataTable14_3
   \       0x28   0x6801             LDR      R1,[R0, #+0]
   \       0x2A   0x7B09             LDRB     R1,[R1, #+12]
   \       0x2C   0x0709             LSLS     R1,R1,#+28
   \       0x2E   0xD51A             BPL.N    ??TWI0_IrqHandler_2
    506            {
    507              *TWI0->pu8RxBuffer = TWI0->pBaseAddress->TWI_RHR;
   \       0x30   0x6801             LDR      R1,[R0, #+0]
   \       0x32   0x6809             LDR      R1,[R1, #+0]
   \       0x34   0x6B09             LDR      R1,[R1, #+48]
   \       0x36   0x6802             LDR      R2,[R0, #+0]
   \       0x38   0x6892             LDR      R2,[R2, #+8]
   \       0x3A   0x7011             STRB     R1,[R2, #+0]
    508              TWI0->pu8RxBuffer++;
   \       0x3C   0x6801             LDR      R1,[R0, #+0]
   \       0x3E   0x6889             LDR      R1,[R1, #+8]
   \       0x40   0x1C49             ADDS     R1,R1,#+1
   \       0x42   0x6802             LDR      R2,[R0, #+0]
   \       0x44   0x6091             STR      R1,[R2, #+8]
    509              TWI_u32CurrentBytesRemaining--;
   \       0x46   0x....             LDR.N    R1,??DataTable14_15
   \       0x48   0x680A             LDR      R2,[R1, #+0]
   \       0x4A   0x1E52             SUBS     R2,R2,#+1
   \       0x4C   0x600A             STR      R2,[R1, #+0]
    510              
    511              if(TWI_u32CurrentBytesRemaining == 1)
   \       0x4E   0x6809             LDR      R1,[R1, #+0]
   \       0x50   0x2901             CMP      R1,#+1
   \       0x52   0xD117             BNE.N    ??TWI0_IrqHandler_1
    512              {
    513                TWI0->pBaseAddress->TWI_CR |= _TWI_CR_STOP_BIT;
   \       0x54   0x6801             LDR      R1,[R0, #+0]
   \       0x56   0x6809             LDR      R1,[R1, #+0]
   \       0x58   0x6809             LDR      R1,[R1, #+0]
   \       0x5A   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x5E   0x6800             LDR      R0,[R0, #+0]
   \       0x60   0x6800             LDR      R0,[R0, #+0]
   \       0x62   0x6001             STR      R1,[R0, #+0]
   \       0x64   0xE00E             B.N      ??TWI0_IrqHandler_1
    514              }
    515            }
    516            /* Transmitting Bytes */
    517            else if(u32InterruptStatus & _TWI_SR_TXRDY && ( TWI0->u32Flags & _TWI_TRANSMITTING ) )
   \                     ??TWI0_IrqHandler_2: (+1)
   \       0x66   0x0760             LSLS     R0,R4,#+29
   \       0x68   0xD507             BPL.N    ??TWI0_IrqHandler_3
   \       0x6A   0x....             LDR.N    R0,??DataTable14_3
   \       0x6C   0x6800             LDR      R0,[R0, #+0]
   \       0x6E   0x7B00             LDRB     R0,[R0, #+12]
   \       0x70   0x0780             LSLS     R0,R0,#+30
   \       0x72   0xD502             BPL.N    ??TWI0_IrqHandler_3
    518            {
    519              /* There is more data queued and peripheral ready */
    520              TWI0FillTxBuffer();
   \       0x74   0x.... 0x....      BL       TWI0FillTxBuffer
   \       0x78   0xE004             B.N      ??TWI0_IrqHandler_1
    521            }
    522            else
    523            {
    524              TWI_u32Flags |= _TWI_ERROR_INTERRUPT;
   \                     ??TWI0_IrqHandler_3: (+1)
   \       0x7A   0x....             LDR.N    R0,??DataTable14_8
   \       0x7C   0x6801             LDR      R1,[R0, #+0]
   \       0x7E   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x82   0x6001             STR      R1,[R0, #+0]
    525            }
    526          }
   \                     ??TWI0_IrqHandler_1: (+1)
   \       0x84   0xBD10             POP      {R4,PC}          ;; return
    527          
    528          /***********************************************************************************************************************
    529          State Machine Function Definitions
    530          ***********************************************************************************************************************/
    531          
    532          /*-------------------------------------------------------------------------------------------------------------------*/
    533          /* Wait for a transmit message to be queued.  Received data is handled in interrupts. */

   \                                 In section .text, align 4, keep-with-next
    534          void TWISM_Idle(void)
    535          {
   \                     TWISM_Idle: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    536            if(TWI_MessageBufferNextIndex != TWI_MessageBufferCurIndex )
   \        0x2   0x....             LDR.N    R1,??DataTable14_10
   \        0x4   0x....             LDR.N    R0,??DataTable14_4
   \        0x6   0x7800             LDRB     R0,[R0, #+0]
   \        0x8   0x780A             LDRB     R2,[R1, #+0]
   \        0xA   0x4290             CMP      R0,R2
   \        0xC   0xD075             BEQ.N    ??TWISM_Idle_0
    537            {
    538              TWI0->pBaseAddress->TWI_MMR = TWI0_MMR_INIT;
   \        0xE   0x....             LDR.N    R4,??DataTable14_3
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x6822             LDR      R2,[R4, #+0]
   \       0x14   0x6812             LDR      R2,[R2, #+0]
   \       0x16   0x6050             STR      R0,[R2, #+4]
    539              TWI0->pBaseAddress->TWI_CR = TWI0_CR_INIT;
   \       0x18   0x2024             MOVS     R0,#+36
   \       0x1A   0x6822             LDR      R2,[R4, #+0]
   \       0x1C   0x6812             LDR      R2,[R2, #+0]
   \       0x1E   0x6010             STR      R0,[R2, #+0]
    540              
    541              if(TWI_MessageBuffer[TWI_MessageBufferCurIndex].Direction == WRITE)
   \       0x20   0x....             LDR.N    R2,??DataTable14_5
   \       0x22   0x7808             LDRB     R0,[R1, #+0]
   \       0x24   0x0100             LSLS     R0,R0,#+4
   \       0x26   0x5C10             LDRB     R0,[R2, R0]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD128             BNE.N    ??TWISM_Idle_1
    542              {
    543                /* insert new address */
    544                TWI0->pBaseAddress->TWI_MMR |= ((TWI_MessageBuffer[TWI_MessageBufferCurIndex].u8Address << _TWI_MMR_ADDRESS_SHIFT));
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6800             LDR      R0,[R0, #+0]
   \       0x30   0x6840             LDR      R0,[R0, #+4]
   \       0x32   0x7809             LDRB     R1,[R1, #+0]
   \       0x34   0x0109             LSLS     R1,R1,#+4
   \       0x36   0x4411             ADD      R1,R2,R1
   \       0x38   0x7A09             LDRB     R1,[R1, #+8]
   \       0x3A   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \       0x3E   0x6821             LDR      R1,[R4, #+0]
   \       0x40   0x6809             LDR      R1,[R1, #+0]
   \       0x42   0x6048             STR      R0,[R1, #+4]
    545                
    546                /* Set up to transmit the message */
    547                TWI_u32CurrentBytesRemaining = TWI0->pTransmitBuffer->u32Size;
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x6840             LDR      R0,[R0, #+4]
   \       0x48   0x6840             LDR      R0,[R0, #+4]
   \       0x4A   0x....             LDR.N    R1,??DataTable14_15
   \       0x4C   0x6008             STR      R0,[R1, #+0]
    548                TWI_pu8CurrentTxData = TWI0->pTransmitBuffer->pu8Message;
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x6840             LDR      R0,[R0, #+4]
   \       0x52   0x3008             ADDS     R0,R0,#+8
   \       0x54   0x....             LDR.N    R1,??DataTable14_16
   \       0x56   0x6008             STR      R0,[R1, #+0]
    549                TWI0FillTxBuffer();    
   \       0x58   0x.... 0x....      BL       TWI0FillTxBuffer
    550                
    551                /* Update the message's status */
    552                UpdateMessageStatus(TWI0->pTransmitBuffer->u32Token, SENDING);
   \       0x5C   0x2102             MOVS     R1,#+2
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6840             LDR      R0,[R0, #+4]
   \       0x62   0x6800             LDR      R0,[R0, #+0]
   \       0x64   0x.... 0x....      BL       UpdateMessageStatus
    553            
    554                /* Proceed to next state to let the current message send */
    555                TWI0->u32Flags |= (_TWI_TRANSMITTING | _TWI_TRANS_NOT_COMP);
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x68C0             LDR      R0,[R0, #+12]
   \       0x6C   0xF050 0x0006      ORRS     R0,R0,#0x6
   \       0x70   0x6821             LDR      R1,[R4, #+0]
   \       0x72   0x60C8             STR      R0,[R1, #+12]
    556                TWI_StateMachine = TWISM_Transmitting;
   \       0x74   0x.... 0x....      ADR.W    R0,TWISM_Transmitting
   \       0x78   0x....             LDR.N    R1,??DataTable14_17
   \       0x7A   0x6008             STR      R0,[R1, #+0]
   \       0x7C   0xE034             B.N      ??TWISM_Idle_2
    557              }
    558              else if(TWI_MessageBuffer[TWI_MessageBufferCurIndex].Direction == READ)
   \                     ??TWISM_Idle_1: (+1)
   \       0x7E   0x7808             LDRB     R0,[R1, #+0]
   \       0x80   0x0100             LSLS     R0,R0,#+4
   \       0x82   0x5C10             LDRB     R0,[R2, R0]
   \       0x84   0x2801             CMP      R0,#+1
   \       0x86   0xD12F             BNE.N    ??TWISM_Idle_2
    559              {
    560                /* insert new address and set Read bit */
    561                TWI0->pBaseAddress->TWI_MMR |= (((TWI_MessageBuffer[TWI_MessageBufferCurIndex].u8Address) << _TWI_MMR_ADDRESS_SHIFT) & _TWI_MMR_MREAD_BIT);
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6800             LDR      R0,[R0, #+0]
   \       0x8C   0x6840             LDR      R0,[R0, #+4]
   \       0x8E   0x6823             LDR      R3,[R4, #+0]
   \       0x90   0x681B             LDR      R3,[R3, #+0]
   \       0x92   0x6058             STR      R0,[R3, #+4]
    562                
    563                /* Grab number of desired bytes and the pointer to store the buffer */
    564                TWI_u32CurrentBytesRemaining = TWI_MessageBuffer[TWI_MessageBufferCurIndex].u32Size;
   \       0x94   0x....             LDR.N    R0,??DataTable14_15
   \       0x96   0x780B             LDRB     R3,[R1, #+0]
   \       0x98   0x011B             LSLS     R3,R3,#+4
   \       0x9A   0x4413             ADD      R3,R2,R3
   \       0x9C   0x685B             LDR      R3,[R3, #+4]
   \       0x9E   0x6003             STR      R3,[R0, #+0]
    565                TWI0->pu8RxBuffer = TWI_MessageBuffer[TWI_MessageBufferCurIndex].pu8RxBuffer;
   \       0xA0   0x7809             LDRB     R1,[R1, #+0]
   \       0xA2   0x0109             LSLS     R1,R1,#+4
   \       0xA4   0x4411             ADD      R1,R2,R1
   \       0xA6   0x68C9             LDR      R1,[R1, #+12]
   \       0xA8   0x6822             LDR      R2,[R4, #+0]
   \       0xAA   0x6091             STR      R1,[R2, #+8]
    566                
    567                if(TWI_u32CurrentBytesRemaining == 1)
   \       0xAC   0x6800             LDR      R0,[R0, #+0]
   \       0xAE   0x2801             CMP      R0,#+1
   \       0xB0   0xD108             BNE.N    ??TWISM_Idle_3
    568                {
    569                  /* Start and Stop need to be set at same time */
    570                  TWI0->pBaseAddress->TWI_CR |= (_TWI_CR_START_BIT | _TWI_CR_STOP_BIT);
   \       0xB2   0x6820             LDR      R0,[R4, #+0]
   \       0xB4   0x6800             LDR      R0,[R0, #+0]
   \       0xB6   0x6800             LDR      R0,[R0, #+0]
   \       0xB8   0xF050 0x0003      ORRS     R0,R0,#0x3
   \       0xBC   0x6821             LDR      R1,[R4, #+0]
   \       0xBE   0x6809             LDR      R1,[R1, #+0]
   \       0xC0   0x6008             STR      R0,[R1, #+0]
   \       0xC2   0xE007             B.N      ??TWISM_Idle_4
    571                }
    572                else
    573                {
    574                  /* Just start bit, stop will be handled by interrupt */
    575                  TWI0->pBaseAddress->TWI_CR |= _TWI_CR_START_BIT;
   \                     ??TWISM_Idle_3: (+1)
   \       0xC4   0x6820             LDR      R0,[R4, #+0]
   \       0xC6   0x6800             LDR      R0,[R0, #+0]
   \       0xC8   0x6800             LDR      R0,[R0, #+0]
   \       0xCA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xCE   0x6821             LDR      R1,[R4, #+0]
   \       0xD0   0x6809             LDR      R1,[R1, #+0]
   \       0xD2   0x6008             STR      R0,[R1, #+0]
    576                }
    577                
    578                /* Proceed to receiving state and set flag */
    579                TWI0->u32Flags |= _TWI_RECEIVING;
   \                     ??TWISM_Idle_4: (+1)
   \       0xD4   0x6820             LDR      R0,[R4, #+0]
   \       0xD6   0x68C0             LDR      R0,[R0, #+12]
   \       0xD8   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0xDC   0x6821             LDR      R1,[R4, #+0]
   \       0xDE   0x60C8             STR      R0,[R1, #+12]
    580                TWI_StateMachine = TWISM_Receiving;
   \       0xE0   0x.... 0x....      ADR.W    R0,TWISM_Receiving
   \       0xE4   0x....             LDR.N    R1,??DataTable14_17
   \       0xE6   0x6008             STR      R0,[R1, #+0]
    581                
    582              }  
    583              
    584              /* Check for errors */
    585              if(TWI_u32Flags & TWI_ERROR_FLAG_MASK)
   \                     ??TWISM_Idle_2: (+1)
   \       0xE8   0x....             LDR.N    R0,??DataTable14_8
   \       0xEA   0x6800             LDR      R0,[R0, #+0]
   \       0xEC   0xF010 0x4F7F      TST      R0,#0xFF000000
   \       0xF0   0xD003             BEQ.N    ??TWISM_Idle_0
    586              {
    587                /* Reset peripheral parser and go to error state */
    588                TWI_StateMachine = TWISM_Error;
   \       0xF2   0x.... 0x....      ADR.W    R0,TWISM_Error
   \       0xF6   0x....             LDR.N    R1,??DataTable14_17
   \       0xF8   0x6008             STR      R0,[R1, #+0]
    589              }
    590            }
    591          } /* end TWISM_Idle() */
   \                     ??TWISM_Idle_0: (+1)
   \       0xFA   0xBD10             POP      {R4,PC}          ;; return
    592               
    593          
    594          /*-------------------------------------------------------------------------------------------------------------------*/
    595          /* Transmit in progress until current bytes have reached 0.  On exit, the transmit message must be dequeued.
    596          */

   \                                 In section .text, align 4, keep-with-next
    597          void TWISM_Transmitting(void)
    598          {
   \                     TWISM_Transmitting: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    599            /* Check if a stop condition has been requested */
    600            if(TWI_MessageBuffer[TWI_MessageBufferCurIndex].Stop == STOP)
   \        0x2   0x....             LDR.N    R4,??DataTable14_10
   \        0x4   0x....             LDR.N    R0,??DataTable14_5
   \        0x6   0x7821             LDRB     R1,[R4, #+0]
   \        0x8   0x0109             LSLS     R1,R1,#+4
   \        0xA   0x4408             ADD      R0,R0,R1
   \        0xC   0x7A80             LDRB     R0,[R0, #+10]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD115             BNE.N    ??TWISM_Transmitting_0
    601            {
    602              /* Check if all of the message bytes have completely finished sending and transmission complete */
    603              if( (TWI_u32CurrentBytesRemaining == 0) && 
    604                  (TWI0->pBaseAddress->TWI_SR & _TWI_SR_TXRDY) &&
    605                  (TWI0->pBaseAddress->TWI_SR & _TWI_SR_TXCOMP) )
   \       0x12   0x....             LDR.N    R0,??DataTable14_15
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD121             BNE.N    ??TWISM_Transmitting_1
   \       0x1A   0x....             LDR.N    R0,??DataTable14_3
   \       0x1C   0x6801             LDR      R1,[R0, #+0]
   \       0x1E   0x6809             LDR      R1,[R1, #+0]
   \       0x20   0x6A09             LDR      R1,[R1, #+32]
   \       0x22   0x0749             LSLS     R1,R1,#+29
   \       0x24   0xD51B             BPL.N    ??TWISM_Transmitting_1
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0x6809             LDR      R1,[R1, #+0]
   \       0x2A   0x6A09             LDR      R1,[R1, #+32]
   \       0x2C   0x07C9             LSLS     R1,R1,#+31
   \       0x2E   0xD516             BPL.N    ??TWISM_Transmitting_1
    606              {
    607                /*  Clear flags */
    608                TWI0->u32Flags &= ~(_TWI_TRANSMITTING | _TWI_TRANS_NOT_COMP);
   \       0x30   0x6801             LDR      R1,[R0, #+0]
   \       0x32   0x68C9             LDR      R1,[R1, #+12]
   \       0x34   0xF031 0x0106      BICS     R1,R1,#0x6
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0x60C1             STR      R1,[R0, #+12]
   \       0x3C   0xE00F             B.N      ??TWISM_Transmitting_1
    609              }
    610            }
    611            else
    612            {
    613              /* Check if all of the message bytes have completely finished sending */
    614              if( (TWI_u32CurrentBytesRemaining == 0) && 
    615                  (TWI0->pBaseAddress->TWI_SR & _TWI_SR_TXRDY) )
   \                     ??TWISM_Transmitting_0: (+1)
   \       0x3E   0x....             LDR.N    R0,??DataTable14_15
   \       0x40   0x6800             LDR      R0,[R0, #+0]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD10B             BNE.N    ??TWISM_Transmitting_1
   \       0x46   0x....             LDR.N    R0,??DataTable14_3
   \       0x48   0x6801             LDR      R1,[R0, #+0]
   \       0x4A   0x6809             LDR      R1,[R1, #+0]
   \       0x4C   0x6A09             LDR      R1,[R1, #+32]
   \       0x4E   0x0749             LSLS     R1,R1,#+29
   \       0x50   0xD505             BPL.N    ??TWISM_Transmitting_1
    616              { 
    617                /* Clear flag */
    618                TWI0->u32Flags &= ~_TWI_TRANSMITTING;
   \       0x52   0x6801             LDR      R1,[R0, #+0]
   \       0x54   0x68C9             LDR      R1,[R1, #+12]
   \       0x56   0xF031 0x0102      BICS     R1,R1,#0x2
   \       0x5A   0x6800             LDR      R0,[R0, #+0]
   \       0x5C   0x60C1             STR      R1,[R0, #+12]
    619              }
    620            }
    621            
    622            if( !(TWI0->u32Flags & _TWI_TRANSMITTING) )
   \                     ??TWISM_Transmitting_1: (+1)
   \       0x5E   0x....             LDR.N    R5,??DataTable14_3
   \       0x60   0x6828             LDR      R0,[R5, #+0]
   \       0x62   0x7B00             LDRB     R0,[R0, #+12]
   \       0x64   0x0780             LSLS     R0,R0,#+30
   \       0x66   0xD41D             BMI.N    ??TWISM_Transmitting_2
    623            {
    624              /* Update the status queue and then dequeue the message */
    625              UpdateMessageStatus(TWI0->pTransmitBuffer->u32Token, COMPLETE);
   \       0x68   0x2104             MOVS     R1,#+4
   \       0x6A   0x6828             LDR      R0,[R5, #+0]
   \       0x6C   0x6840             LDR      R0,[R0, #+4]
   \       0x6E   0x6800             LDR      R0,[R0, #+0]
   \       0x70   0x.... 0x....      BL       UpdateMessageStatus
    626              DeQueueMessage(&TWI0->pTransmitBuffer);
   \       0x74   0x6828             LDR      R0,[R5, #+0]
   \       0x76   0x1D00             ADDS     R0,R0,#+4
   \       0x78   0x.... 0x....      BL       DeQueueMessage
    627              
    628              /* Make sure _TWI_INIT_MODE flag is clear in case this was a manual cycle */
    629              TWI_u32Flags &= ~_TWI_INIT_MODE;
   \       0x7C   0x....             LDR.N    R0,??DataTable14_8
   \       0x7E   0x6801             LDR      R1,[R0, #+0]
   \       0x80   0x0849             LSRS     R1,R1,#+1
   \       0x82   0x0049             LSLS     R1,R1,#+1
   \       0x84   0x6001             STR      R1,[R0, #+0]
    630              TWI_StateMachine = TWISM_Idle;
   \       0x86   0x....             LDR.N    R0,??DataTable14_20
   \       0x88   0x....             LDR.N    R1,??DataTable14_17
   \       0x8A   0x6008             STR      R0,[R1, #+0]
    631              
    632              /* Update queue pointers */
    633              TWI_MessageBufferCurIndex++;
   \       0x8C   0x7820             LDRB     R0,[R4, #+0]
   \       0x8E   0x1C40             ADDS     R0,R0,#+1
   \       0x90   0x7020             STRB     R0,[R4, #+0]
    634              TWI_MessageQueueLength--;
   \       0x92   0x....             LDR.N    R0,??DataTable14_2
   \       0x94   0x7801             LDRB     R1,[R0, #+0]
   \       0x96   0x1E49             SUBS     R1,R1,#+1
   \       0x98   0x7001             STRB     R1,[R0, #+0]
    635              if(TWI_MessageBufferCurIndex == TX_QUEUE_SIZE)
   \       0x9A   0x7820             LDRB     R0,[R4, #+0]
   \       0x9C   0x2810             CMP      R0,#+16
   \       0x9E   0xD101             BNE.N    ??TWISM_Transmitting_2
    636              {
    637                TWI_MessageBufferCurIndex = 0;
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0x7020             STRB     R0,[R4, #+0]
    638              }
    639            }
    640            
    641            /* Check for errors */
    642            if(TWI_u32Flags & TWI_ERROR_FLAG_MASK)
   \                     ??TWISM_Transmitting_2: (+1)
   \       0xA4   0x....             LDR.N    R0,??DataTable14_8
   \       0xA6   0x6800             LDR      R0,[R0, #+0]
   \       0xA8   0xF010 0x4F7F      TST      R0,#0xFF000000
   \       0xAC   0xD003             BEQ.N    ??TWISM_Transmitting_3
    643            {
    644              /* Reset peripheral parser and go to error state */
    645              TWI_StateMachine = TWISM_Error;
   \       0xAE   0x.... 0x....      ADR.W    R0,TWISM_Error
   \       0xB2   0x....             LDR.N    R1,??DataTable14_17
   \       0xB4   0x6008             STR      R0,[R1, #+0]
    646            }
    647            
    648          } /* end TWISM_Transmitting() */
   \                     ??TWISM_Transmitting_3: (+1)
   \       0xB6   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    649          
    650          /*-------------------------------------------------------------------------------------------------------------------*/
    651          /* Receive in progress until current bytes have reached 0.
    652          */

   \                                 In section .text, align 4, keep-with-next
    653          void TWISM_Receiving(void)
    654          {
    655            if( (TWI_u32CurrentBytesRemaining == 0) &&
    656                (TWI0->pBaseAddress->TWI_SR & _TWI_SR_RXRDY) &&
    657                (TWI0->pBaseAddress->TWI_SR & _TWI_SR_TXCOMP) )
   \                     TWISM_Receiving: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable14_15
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD125             BNE.N    ??TWISM_Receiving_0
   \        0x8   0x....             LDR.N    R0,??DataTable14_3
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0x6809             LDR      R1,[R1, #+0]
   \        0xE   0x6A09             LDR      R1,[R1, #+32]
   \       0x10   0x0789             LSLS     R1,R1,#+30
   \       0x12   0xD51F             BPL.N    ??TWISM_Receiving_0
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0x6809             LDR      R1,[R1, #+0]
   \       0x18   0x6A09             LDR      R1,[R1, #+32]
   \       0x1A   0x07C9             LSLS     R1,R1,#+31
   \       0x1C   0xD51A             BPL.N    ??TWISM_Receiving_0
    658            {
    659              /* Clear flag */
    660              TWI0->u32Flags &= ~_TWI_RECEIVING;
   \       0x1E   0x6801             LDR      R1,[R0, #+0]
   \       0x20   0x68C9             LDR      R1,[R1, #+12]
   \       0x22   0xF031 0x0108      BICS     R1,R1,#0x8
   \       0x26   0x6800             LDR      R0,[R0, #+0]
   \       0x28   0x60C1             STR      R1,[R0, #+12]
    661              
    662              /* Make sure _TWI_INIT_MODE flag is clear in case this was a manual cycle */
    663              TWI_u32Flags &= ~_TWI_INIT_MODE;
   \       0x2A   0x....             LDR.N    R0,??DataTable14_8
   \       0x2C   0x6801             LDR      R1,[R0, #+0]
   \       0x2E   0x0849             LSRS     R1,R1,#+1
   \       0x30   0x0049             LSLS     R1,R1,#+1
   \       0x32   0x6001             STR      R1,[R0, #+0]
    664              TWI_StateMachine = TWISM_Idle;
   \       0x34   0x....             LDR.N    R0,??DataTable14_20
   \       0x36   0x....             LDR.N    R1,??DataTable14_17
   \       0x38   0x6008             STR      R0,[R1, #+0]
    665              
    666              /* Update queue pointers */
    667              TWI_MessageBufferCurIndex++;
   \       0x3A   0x....             LDR.N    R0,??DataTable14_10
   \       0x3C   0x7801             LDRB     R1,[R0, #+0]
   \       0x3E   0x1C49             ADDS     R1,R1,#+1
   \       0x40   0x7001             STRB     R1,[R0, #+0]
    668              TWI_MessageQueueLength--;
   \       0x42   0x....             LDR.N    R1,??DataTable14_2
   \       0x44   0x780A             LDRB     R2,[R1, #+0]
   \       0x46   0x1E52             SUBS     R2,R2,#+1
   \       0x48   0x700A             STRB     R2,[R1, #+0]
    669              if(TWI_MessageBufferCurIndex == TX_QUEUE_SIZE)
   \       0x4A   0x7801             LDRB     R1,[R0, #+0]
   \       0x4C   0x2910             CMP      R1,#+16
   \       0x4E   0xD101             BNE.N    ??TWISM_Receiving_0
    670              {
    671                TWI_MessageBufferCurIndex = 0;
   \       0x50   0x2100             MOVS     R1,#+0
   \       0x52   0x7001             STRB     R1,[R0, #+0]
    672              }
    673            }
    674            
    675            /* Check for errors */
    676            if(TWI_u32Flags & TWI_ERROR_FLAG_MASK)
   \                     ??TWISM_Receiving_0: (+1)
   \       0x54   0x....             LDR.N    R0,??DataTable14_8
   \       0x56   0x6800             LDR      R0,[R0, #+0]
   \       0x58   0xF010 0x4F7F      TST      R0,#0xFF000000
   \       0x5C   0xD003             BEQ.N    ??TWISM_Receiving_1
    677            {
    678              /* Reset peripheral parser and go to error state */
    679              TWI_StateMachine = TWISM_Error;
   \       0x5E   0x.... 0x....      ADR.W    R0,TWISM_Error
   \       0x62   0x....             LDR.N    R1,??DataTable14_17
   \       0x64   0x6008             STR      R0,[R1, #+0]
    680            }  
    681            
    682          }
   \                     ??TWISM_Receiving_1: (+1)
   \       0x66   0x4770             BX       LR               ;; return
    683          
    684          /*-------------------------------------------------------------------------------------------------------------------*/
    685          /* Handle an error */

   \                                 In section .text, align 4, keep-with-next
    686          void TWISM_Error(void)          
    687          {
   \                     TWISM_Error: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    688            /* NACK recieved */
    689            if( TWI_u32Flags & _TWI_ERROR_NACK )
   \        0x2   0x....             LDR.N    R4,??DataTable14_8
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x01C0             LSLS     R0,R0,#+7
   \        0x8   0xD530             BPL.N    ??TWISM_Error_0
    690            {
    691              /* Msg attempted too many times */
    692              if( ++TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Attempts == MAX_ATTEMPTS )
   \        0xA   0x....             LDR.N    R0,??DataTable14_4
   \        0xC   0x....             LDR.N    R1,??DataTable14_5
   \        0xE   0x7802             LDRB     R2,[R0, #+0]
   \       0x10   0x0112             LSLS     R2,R2,#+4
   \       0x12   0x440A             ADD      R2,R1,R2
   \       0x14   0x7803             LDRB     R3,[R0, #+0]
   \       0x16   0x011B             LSLS     R3,R3,#+4
   \       0x18   0x440B             ADD      R3,R1,R3
   \       0x1A   0x7A5B             LDRB     R3,[R3, #+9]
   \       0x1C   0x1C5B             ADDS     R3,R3,#+1
   \       0x1E   0x7253             STRB     R3,[R2, #+9]
   \       0x20   0x7800             LDRB     R0,[R0, #+0]
   \       0x22   0x0100             LSLS     R0,R0,#+4
   \       0x24   0x4408             ADD      R0,R1,R0
   \       0x26   0x7A40             LDRB     R0,[R0, #+9]
   \       0x28   0x2803             CMP      R0,#+3
   \       0x2A   0xD11B             BNE.N    ??TWISM_Error_1
    693              {
    694                /* Remove the message from buffer queue */
    695                TWI_MessageBufferCurIndex++;
   \       0x2C   0x....             LDR.N    R0,??DataTable14_10
   \       0x2E   0x7801             LDRB     R1,[R0, #+0]
   \       0x30   0x1C49             ADDS     R1,R1,#+1
   \       0x32   0x7001             STRB     R1,[R0, #+0]
    696                TWI_MessageQueueLength--;
   \       0x34   0x....             LDR.N    R1,??DataTable14_2
   \       0x36   0x780A             LDRB     R2,[R1, #+0]
   \       0x38   0x1E52             SUBS     R2,R2,#+1
   \       0x3A   0x700A             STRB     R2,[R1, #+0]
    697                if(TWI_MessageBufferCurIndex == TX_QUEUE_SIZE)
   \       0x3C   0x7801             LDRB     R1,[R0, #+0]
   \       0x3E   0x2910             CMP      R1,#+16
   \       0x40   0xD101             BNE.N    ??TWISM_Error_2
    698                {
    699                  TWI_MessageBufferCurIndex = 0;
   \       0x42   0x2100             MOVS     R1,#+0
   \       0x44   0x7001             STRB     R1,[R0, #+0]
    700                }
    701                
    702                if( TWI0->u32Flags & _TWI_TRANSMITTING )
   \                     ??TWISM_Error_2: (+1)
   \       0x46   0x....             LDR.N    R5,??DataTable14_3
   \       0x48   0x6828             LDR      R0,[R5, #+0]
   \       0x4A   0x7B00             LDRB     R0,[R0, #+12]
   \       0x4C   0x0780             LSLS     R0,R0,#+30
   \       0x4E   0xD509             BPL.N    ??TWISM_Error_1
    703                {
    704                  /* Dequeue Msg and Update Status */ 
    705                  UpdateMessageStatus(TWI0->pTransmitBuffer->u32Token, ABANDONED);
   \       0x50   0x2106             MOVS     R1,#+6
   \       0x52   0x6828             LDR      R0,[R5, #+0]
   \       0x54   0x6840             LDR      R0,[R0, #+4]
   \       0x56   0x6800             LDR      R0,[R0, #+0]
   \       0x58   0x.... 0x....      BL       UpdateMessageStatus
    706                  DeQueueMessage(&TWI0->pTransmitBuffer);
   \       0x5C   0x6828             LDR      R0,[R5, #+0]
   \       0x5E   0x1D00             ADDS     R0,R0,#+4
   \       0x60   0x.... 0x....      BL       DeQueueMessage
    707                }
    708              }
    709          
    710              /* Reset the msg flags */
    711              TWI0->u32Flags = 0;
   \                     ??TWISM_Error_1: (+1)
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x....             LDR.N    R1,??DataTable14_3
   \       0x68   0x6809             LDR      R1,[R1, #+0]
   \       0x6A   0x60C8             STR      R0,[R1, #+12]
    712            }
    713            
    714            /* Return to Idle */
    715            TWI_u32Flags &= ~TWI_ERROR_FLAG_MASK;
   \                     ??TWISM_Error_0: (+1)
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0xF020 0x407F      BIC      R0,R0,#0xFF000000
   \       0x72   0x6020             STR      R0,[R4, #+0]
    716            TWI_StateMachine = TWISM_Idle;
   \       0x74   0x....             LDR.N    R0,??DataTable14_20
   \       0x76   0x....             LDR.N    R1,??DataTable14_17
   \       0x78   0x6008             STR      R0,[R1, #+0]
    717            
    718          } /* end TWISM_Error() */
   \       0x7A   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0xE000'E280        DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x....'....        DC32     TWI_MessageQueueLength

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0x....'....        DC32     TWI0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \        0x0   0x....'....        DC32     TWI_MessageBufferNextIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \        0x0   0x....'....        DC32     TWI_MessageBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \        0x0   0x....'....        DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \        0x0   0x400E'0410        DC32     0x400e0410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \        0x0   0x....'....        DC32     TWI_u32Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \        0x0   0x....'....        DC32     TWI_Peripheral0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \        0x0   0x....'....        DC32     TWI_MessageBufferCurIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \        0x0   0x4008'4000        DC32     0x40084000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \        0x0   0x....'....        DC32     TWI_u32Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \        0x0   0x....'....        DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \        0x0   0x0002'1D1D        DC32     0x21d1d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_15:
   \        0x0   0x....'....        DC32     TWI_u32CurrentBytesRemaining

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_16:
   \        0x0   0x....'....        DC32     TWI_pu8CurrentTxData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_17:
   \        0x0   0x....'....        DC32     TWI_StateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_18:
   \        0x0   0x4008'402C        DC32     0x4008402c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_19:
   \        0x0   0x4008'4020        DC32     0x40084020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_20:
   \        0x0   0x....'....        DC32     TWISM_Idle
    719          
    720          
    721          
    722          /*--------------------------------------------------------------------------------------------------------------------*/
    723          /* End of File */
    724          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_ClearPendingIRQ
       0   NVIC_EnableIRQ
       4   TWI0FillTxBuffer
      16   TWI0ReadByte
        16   -> TWIManualMode
      24   TWI0ReadData
        24   -> TWIManualMode
      32   TWI0WriteByte
        32   -> QueueMessage
        32   -> TWIManualMode
      32   TWI0WriteData
        32   -> QueueMessage
        32   -> TWIManualMode
       8   TWI0_IrqHandler
         8   -> TWI0FillTxBuffer
      16   TWIInitialize
        16   -> IsTimeUp
        16   -> NVIC_ClearPendingIRQ
        16   -> NVIC_EnableIRQ
      16   TWIManualMode
        16   -- Indirect call
        16   -> IsTimeUp
       8   TWIRunActiveState
         8   -- Indirect call
      16   TWISM_Error
        16   -> DeQueueMessage
        16   -> UpdateMessageStatus
       8   TWISM_Idle
         8   -> TWI0FillTxBuffer
         8   -> UpdateMessageStatus
       0   TWISM_Receiving
      16   TWISM_Transmitting
        16   -> DeQueueMessage
        16   -> UpdateMessageStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_16
       4  ??DataTable14_17
       4  ??DataTable14_18
       4  ??DataTable14_19
       4  ??DataTable14_2
       4  ??DataTable14_20
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      24  NVIC_ClearPendingIRQ
      24  NVIC_EnableIRQ
       4  TWI0
     132  TWI0FillTxBuffer
     134  TWI0ReadByte
     134  TWI0ReadData
     160  TWI0WriteByte
     160  TWI0WriteData
     134  TWI0_IrqHandler
     208  TWIInitialize
      52  TWIManualMode
      12  TWIRunActiveState
     124  TWISM_Error
     252  TWISM_Idle
     104  TWISM_Receiving
     184  TWISM_Transmitting
     256  TWI_MessageBuffer
       1  TWI_MessageBufferCurIndex
       1  TWI_MessageBufferNextIndex
       1  TWI_MessageQueueLength
      16  TWI_Peripheral0
       4  TWI_StateMachine
       4  TWI_pu8CurrentTxData
       4  TWI_u32CurrentBytesRemaining
       4  TWI_u32Flags
       4  TWI_u32Timer

 
   299 bytes in section .bss
 1 922 bytes in section .text
 
 1 922 bytes of CODE memory
   299 bytes of DATA memory

Errors: none
Warnings: none
