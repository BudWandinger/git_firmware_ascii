###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.2.160/W32 for ARM         14/Oct/2018  14:43:37
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_common\drivers\ant.c
#    Command line =  
#        -f C:\Users\BUDWA_~1\AppData\Local\Temp\EWDBBA.tmp
#        (C:\Embedded\Firmware\git_Razor_Atmel\firmware_common\drivers\ant.c -D
#        EIE1 --preprocess=c
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List
#        -lC
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List
#        -o
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\ -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\bsp\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\drivers\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\application\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.1\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List\ant.lst
#    Object file  =  
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\Obj\ant.o
#
###############################################################################

C:\Embedded\Firmware\git_Razor_Atmel\firmware_common\drivers\ant.c
      1          /***********************************************************************************************************************
      2          File: ant.c                                                               
      3          
      4          Description:
      5          ANT implementation for Atmel SAM3U2 Cortex-M3 / Ant slave SPI.  This driver requires synchronous
      6          SPI slave connection to an AP2 or AP2-emulated ANT device (the ANT device is the Master).  
      7          All interface layer code is maintained here.  
      8          Transmitted messages use the Message task; received messages use an SSP peripheral
      9          with SPI_SLAVE_FLOW_CONTROL.
     10          
     11          ------------------------------------------------------------------------------------------------------------------------
     12          
     13          
     14          ***********************************************************************************************************************/
     15          
     16          #include "configuration.h"
     17          
     18          /***********************************************************************************************************************
     19          * Bookmarks
     20          ************************************************************************************************************************
     21          !!!!! ANT Serial-layer Functions
     22          @@@@@ ANT Interface-layer Functions
     23          ##### ANT State Machine Definition                                             
     24          ***********************************************************************************************************************/
     25          
     26          /***********************************************************************************************************************
     27          Global variable definitions with scope across entire project.
     28          All Global variable names shall start with "G_<type>Ant"
     29          ***********************************************************************************************************************/
     30          
     31          /* New variables */

   \                                 In section .bss, align 4
     32          u32 G_u32AntFlags;                                    /* Flag bits for ANT-related information */
   \                     G_u32AntFlags:
   \        0x0                      DS8 4
     33          

   \                                 In section .bss, align 4
     34          AntAssignChannelInfoType G_asAntChannelConfiguration[ANT_NUM_CHANNELS]; /* Keeps track of all configured ANT channels */
   \                     G_asAntChannelConfiguration:
   \        0x0                      DS8 160

   \                                 In section .bss, align 4
     35          AntMessageResponseType G_stMessageResponse;           /* Holds the latest message response info */
   \                     G_stMessageResponse:
   \        0x0                      DS8 4
     36          

   \                                 In section .bss, align 4
     37          AntApplicationMsgListType *G_sAntApplicationMsgList;  /* Public linked list of messages from ANT to the application */
   \                     G_sAntApplicationMsgList:
   \        0x0                      DS8 4
     38          

   \                                 In section .data, align 4
     39          u8 G_au8AntMessageOk[]     = "OK\n\r";
   \                     G_au8AntMessageOk:
   \        0x0   0x4F 0x4B          DC8 "OK\012\015"
   \              0x0A 0x0D    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     40          u8 G_au8AntMessageFail[  ] = "FAIL\n\r";
   \                     G_au8AntMessageFail:
   \        0x0   0x46 0x41          DC8 "FAIL\012\015"
   \              0x49 0x4C    
   \              0x0A 0x0D    
   \              0x00         
   \        0x7   0x00               DC8 0
     41          
     42          /* Replace 'd' at [12] with channel number */

   \                                 In section .data, align 4
     43          u8 G_au8AntMessageAssign[]    = "ANT channel d assign "; 
   \                     G_au8AntMessageAssign:
   \        0x0   0x41 0x4E          DC8 "ANT channel d assign "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x20 0x00    
   \       0x16   0x00 0x00          DC8 0, 0

   \                                 In section .data, align 4
     44          u8 G_au8AntMessageUnassign[]  = "ANT channel d unassign ";
   \                     G_au8AntMessageUnassign:
   \        0x0   0x41 0x4E          DC8 "ANT channel d unassign "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x75 0x6E    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x20 0x00    

   \                                 In section .data, align 4
     45          u8 G_au8AntMessageUnhandled[] = "ANT channel d message 0xxx response dd ";
   \                     G_au8AntMessageUnhandled:
   \        0x0   0x41 0x4E          DC8 "ANT channel d message 0xxx response dd "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x6D 0x65    
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x30 0x78    
   \              0x78 0x78    
   \              0x20 0x72    
   \              0x65 0x73    
   \              0x70 0x6F    
   \              0x6E 0x73    
   \              0x65 0x20    
   \              0x64 0x64    
   \              0x20 0x00    

   \                                 In section .data, align 4
     46          u8 G_au8AntMessageSetup[] = "ANT channel d setup ";
   \                     G_au8AntMessageSetup:
   \        0x0   0x41 0x4E          DC8 "ANT channel d setup "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x73 0x65    
   \              0x74 0x75    
   \              0x70 0x20    
   \              0x00         
   \       0x15   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     47          u8 G_au8AntMessageClose[] = "ANT channel d close ";
   \                     G_au8AntMessageClose:
   \        0x0   0x41 0x4E          DC8 "ANT channel d close "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x63 0x6C    
   \              0x6F 0x73    
   \              0x65 0x20    
   \              0x00         
   \       0x15   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     48          u8 G_au8AntMessageOpen[]  = "ANT channel d open ";
   \                     G_au8AntMessageOpen:
   \        0x0   0x41 0x4E          DC8 "ANT channel d open "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x6F 0x70    
   \              0x65 0x6E    
   \              0x20 0x00    
     49          

   \                                 In section .data, align 4
     50          u8 G_au8AntMessageInit[]  = "Initializing ANT... ";
   \                     G_au8AntMessageInit:
   \        0x0   0x49 0x6E          DC8 "Initializing ANT... "
   \              0x69 0x74    
   \              0x69 0x61    
   \              0x6C 0x69    
   \              0x7A 0x69    
   \              0x6E 0x67    
   \              0x20 0x41    
   \              0x4E 0x54    
   \              0x2E 0x2E    
   \              0x2E 0x20    
   \              0x00         
   \       0x15   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     51          u8 G_au8AntMessageInitFail[] = "failed. Host IOs set to HiZ.\r\n";
   \                     G_au8AntMessageInitFail:
   \        0x0   0x66 0x61          DC8 "failed. Host IOs set to HiZ.\015\012"
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x2E 0x20    
   \              0x48 0x6F    
   \              0x73 0x74    
   \              0x20 0x49    
   \              0x4F 0x73    
   \              0x20 0x73    
   \              0x65 0x74    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x48 0x69    
   \              0x5A 0x2E    
   \              0x0D 0x0A    
   \              0x00         
   \       0x1F   0x00               DC8 0

   \                                 In section .data, align 4
     52          u8 G_au8AntMessageNoAnt[] = "\n\r### nRF51422 Programming Mode: no ANT functionality ####\n\r";
   \                     G_au8AntMessageNoAnt:
   \        0x0   0x0A 0x0D          DC8 0AH, 0DH, 23H, 23H, 23H, 20H, 6EH, 52H
   \              0x23 0x23    
   \              0x23 0x20    
   \              0x6E 0x52    
   \        0x8   0x46 0x35          DC8 46H, 35H, 31H, 34H, 32H, 32H, 20H, 50H
   \              0x31 0x34    
   \              0x32 0x32    
   \              0x20 0x50    
   \       0x10   0x72 0x6F          DC8 72H, 6FH, 67H, 72H, 61H, 6DH, 6DH, 69H
   \              0x67 0x72    
   \              0x61 0x6D    
   \              0x6D 0x69    
   \       0x18   0x6E 0x67          DC8 6EH, 67H, 20H, 4DH, 6FH, 64H, 65H, 3AH
   \              0x20 0x4D    
   \              0x6F 0x64    
   \              0x65 0x3A    
   \       0x20   0x20 0x6E          DC8 20H, 6EH, 6FH, 20H, 41H, 4EH, 54H, 20H
   \              0x6F 0x20    
   \              0x41 0x4E    
   \              0x54 0x20    
   \       0x28   0x66 0x75          DC8 66H, 75H, 6EH, 63H, 74H, 69H, 6FH, 6EH
   \              0x6E 0x63    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \       0x30   0x61 0x6C          DC8 61H, 6CH, 69H, 74H, 79H, 20H, 23H, 23H
   \              0x69 0x74    
   \              0x79 0x20    
   \              0x23 0x23    
   \       0x38   0x23 0x23          DC8 23H, 23H, 0AH, 0DH, 0
   \              0x0A 0x0D    
   \              0x00         
   \       0x3D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     53          
     54          
     55          /* ANT message structures */

   \                                 In section .data, align 4
     56          u8 G_au8AntSetNetworkKey[]    = {MESG_NETWORK_KEY_SIZE, MESG_NETWORK_KEY_ID, 0 /* Network number */, 
   \                     G_au8AntSetNetworkKey:
   \        0x0   0x09 0x46          DC8 9, 70, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     57                                           0 /* KEY0 */, 0 /* KEY1 */, 0 /* KEY2 */, 0 /* KEY3 */, 
     58                                           0 /* KEY4 */, 0 /* KEY5 */, 0 /* KEY6 */, 0 /* KEY7 */, CS};

   \                                 In section .data, align 4
     59          u8 G_au8AntAssignChannel[]    = {MESG_ASSIGN_CHANNEL_SIZE, MESG_ASSIGN_CHANNEL_ID, 0 /* AntChannel */, 
   \                     G_au8AntAssignChannel:
   \        0x0   0x03 0x42          DC8 3, 66, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     60                                           0 /* AntChannelType */, 0 /* AntNetwork */, CS};

   \                                 In section .data, align 4
     61          u8 G_au8AntSetChannelID[]     = {MESG_CHANNEL_ID_SIZE, MESG_CHANNEL_ID_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetChannelID:
   \        0x0   0x05 0x51          DC8 5, 81, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     62                                           0 /* AntDeviceIdLo */, 0 /* AntDeviceIdHi */, 0 /* AntDeviceType */, 
     63                                           0 /* AntTransmissionType */, CS};

   \                                 In section .data, align 4
     64          u8 G_au8AntSetChannelPeriod[] = {MESG_CHANNEL_MESG_PERIOD_SIZE, MESG_CHANNEL_MESG_PERIOD_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetChannelPeriod:
   \        0x0   0x03 0x43          DC8 3, 67, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     65                                           0 /* AntChannelPeriodLo */, 0 /* AntChannelPeriodHi */, CS};

   \                                 In section .data, align 4
     66          u8 G_au8AntSetChannelRFFreq[] = {MESG_CHANNEL_RADIO_FREQ_SIZE, MESG_CHANNEL_RADIO_FREQ_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetChannelRFFreq:
   \        0x0   0x02 0x45          DC8 2, 69, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     67                                           0 /* AntFrequency */, CS};           

   \                                 In section .data, align 4
     68          u8 G_au8AntSetChannelPower[]  = {MESG_RADIO_TX_POWER_SIZE, MESG_RADIO_TX_POWER_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetChannelPower:
   \        0x0   0x02 0x47          DC8 2, 71, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     69                                           0 /* AntTxPower */, CS};        

   \                                 In section .data, align 4
     70          u8 G_au8AntLibConfig[]        = {MESG_LIB_CONFIG_SIZE, MESG_LIB_CONFIG_ID, 0, LIB_CONFIG_CHANNEL_ID_FLAG | LIB_CONFIG_RSSI_FLAG, CS};        
   \                     G_au8AntLibConfig:
   \        0x0   0x02 0x6E          DC8 2, 110, 0, 192, 0, 0, 0, 0
   \              0x00 0xC0    
   \              0x00 0x00    
   \              0x00 0x00    
     71          

   \                                 In section .data, align 4
     72          u8 G_au8AntBroadcastDataMessage[] = {MESG_DATA_SIZE, MESG_BROADCAST_DATA_ID, CH, D_0, D_1, D_2, D_3, D_4, D_5, D_6, D_7, CS};
   \                     G_au8AntBroadcastDataMessage:
   \        0x0   0x09 0x4E          DC8 9, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
     73          u8 G_au8AntAckDataMessage[] = {MESG_DATA_SIZE, MESG_ACKNOWLEDGED_DATA_ID, CH, D_0, D_1, D_2, D_3, D_4, D_5, D_6, D_7, CS};
   \                     G_au8AntAckDataMessage:
   \        0x0   0x09 0x4F          DC8 9, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
     74          u8 G_au8ANTGetVersion[]     = {MESG_REQUEST_SIZE, MESG_REQUEST_ID, 0, MESG_VERSION_ID, 0};   
   \                     G_au8ANTGetVersion:
   \        0x0   0x02 0x4D          DC8 2, 77, 0, 62, 0, 0, 0, 0
   \              0x00 0x3E    
   \              0x00 0x00    
   \              0x00 0x00    
     75          
     76          
     77          /*----------------------------------------------------------------------------*/
     78          /* Existing variables (defined in other files -- should all contain the "extern" keyword) 
     79          and indicate what file the variable is defined in. */
     80          extern u32 G_u32SystemFlags;                            /* From main.c */
     81          extern u32 G_u32ApplicationFlags;                       /* From main.c */
     82          
     83          extern volatile u32 G_u32SystemTime1ms;                 /* From board-specific source file */
     84          extern volatile u32 G_u32SystemTime1s;                  /* From board-specific source file */
     85          
     86          extern volatile u32 ANT_SSP_FLAGS;                      /* From configuration.h */
     87          
     88          
     89          /***********************************************************************************************************************
     90          Global variable definitions with scope limited to this local application.
     91          Variable names shall start with "Ant_<type>Name" and be declared as static.
     92          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     93          static fnCode_type Ant_pfnStateMachine;                 /* The ANT state machine function pointer */
   \                     Ant_pfnStateMachine:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     94          static u32 Ant_u32RxTimer;                              /* Dedicated timer for receiving bytes */
   \                     Ant_u32RxTimer:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     95          static u32 Ant_u32TxTimer;                              /* Dedicated timer for transmitting bytes */
   \                     Ant_u32TxTimer:
   \        0x0                      DS8 4
     96          

   \                                 In section .bss, align 4
     97          static u32 Ant_u32TxByteCounter = 0;                    /* Counter counts callbacks on sent bytes */
   \                     Ant_u32TxByteCounter:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     98          static u32 Ant_u32RxByteCounter = 0;                    /* Counter counts callbacks on received bytes */
   \                     Ant_u32RxByteCounter:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     99          static u32 Ant_u32RxTimeoutCounter = 0;                 /* Increments any time an ANT reception times out */
   \                     Ant_u32RxTimeoutCounter:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    100          static u32 Ant_u32UnexpectedByteCounter = 0;            /* Increments any time a byte is received that was not expected value */
   \                     Ant_u32UnexpectedByteCounter:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    101          static u32 Ant_u32CurrentTxMessageToken = 0;            /* Token for message currently being sent to ANT */
   \                     Ant_u32CurrentTxMessageToken:
   \        0x0                      DS8 4
    102          

   \                                 In section .bss, align 4
    103          static SspConfigurationType Ant_sSspConfig;             /* Configuration information for SSP peripheral */
   \                     Ant_sSspConfig:
   \        0x0                      DS8 36

   \                                 In section .bss, align 4
    104          static SspPeripheralType* Ant_Ssp;                      /* Pointer to Ant's SSP peripheral object */
   \                     Ant_Ssp:
   \        0x0                      DS8 4
    105          

   \                                 In section .bss, align 4
    106          static u8 Ant_u8AntVersion[MESG_VERSION_SIZE];          /* ANT device version string */
   \                     Ant_u8AntVersion:
   \        0x0                      DS8 12
    107          

   \                                 In section .bss, align 4
    108          static u8 Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE];       /* Space for verified received ANT messages */
   \                     Ant_au8AntRxBuffer:
   \        0x0                      DS8 256

   \                                 In section .bss, align 4
    109          static u8 *Ant_pu8AntRxBufferNextChar;                  /* Pointer to next char to be written in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferNextChar:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    110          static u8 *Ant_pu8AntRxBufferCurrentChar;               /* Pointer to the current char in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferCurrentChar:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    111          static u8 *Ant_pu8AntRxBufferUnreadMsg;                 /* Pointer to unread chars in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferUnreadMsg:
   \        0x0                      DS8 4

   \                                 In section .bss, align 1
    112          static u8 Ant_u8AntNewRxMessages;                       /* Counter for number of new messages in AntRxBuffer */
   \                     Ant_u8AntNewRxMessages:
   \        0x0                      DS8 1
    113          

   \                                 In section .bss, align 4
    114          static u32 Ant_u32ApplicationMessageCount = 0;          /* Counts messages queued on G_sAntApplicationMsgList */
   \                     Ant_u32ApplicationMessageCount:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    115          static AntOutgoingMessageListType *Ant_psDataOutgoingMsgList; /* Linked list of outgoing ANT-formatted messages */
   \                     Ant_psDataOutgoingMsgList:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    116          static u32 Ant_u32OutgoingMessageCount = 0;             /* Counts messages queued on Ant_psDataOutgoingMsgList */
   \                     Ant_u32OutgoingMessageCount:
   \        0x0                      DS8 4
    117          

   \                                 In section .bss, align 1
    118          static u8 Ant_u8SlaveMissedMessageHigh = 0;             /* Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageHigh:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
    119          static u8 Ant_u8SlaveMissedMessageMid = 0;              /* Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageMid:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
    120          static u8 Ant_u8SlaveMissedMessageLow = 0;              /* Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageLow:
   \        0x0                      DS8 1
    121          
    122          
    123          /* Debug variables */

   \                                 In section .bss, align 4
    124          static u32 Ant_DebugRxMessageCounter = 0;
   \                     Ant_DebugRxMessageCounter:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    125          static u32 Ant_DebugTotalRxMessages = 0;
   \                     Ant_DebugTotalRxMessages:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    126          static u32 Ant_DebugProcessRxMessages = 0;
   \                     Ant_DebugProcessRxMessages:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    127          static u32 Ant_DebugQueuedDataMessages = 0;
   \                     Ant_DebugQueuedDataMessages:
   \        0x0                      DS8 4
    128          
    129          
    130          /***********************************************************************************************************************
    131          !!!!! ANT Serial-layer Functions
    132          ***********************************************************************************************************************/
    133          
    134          /* ANT Private Serial-layer Functions */
    135          
    136          /*------------------------------------------------------------------------------
    137          Function: AntSyncSerialInitialize
    138          
    139          Description:
    140          Properly sets up the ANT SPI interface and tests Host <-> ANT communications.
    141          
    142          Requires:
    143            - ANT_SPI is configured
    144            - !CS (SEN) interrupt should be enabled
    145          // - GPIO interrupts are configured and enabled
    146          
    147          Promises:
    148            - Ant_pu8AntRxBufferNextChar is initialized to start of AntRxBuffer
    149            - Ant_pu8AntRxBufferUnreadMsg is initialized to start of AntRxBuffer
    150            - Ant_u8AntNewRxMessages = 0;
    151            - ANT SSP CS and RX interrupts are enabled
    152            - If ANT starts up correctly and responds to version request, then 
    153              G_u32SystemFlags _APPLICATION_FLAGS_ANT is set and Ant_u8AntVersion is populated
    154              with the returned version information from the ANT IC.  
    155          */

   \                                 In section .text, align 2, keep-with-next
    156          static void AntSyncSerialInitialize(void)
    157          {
   \                     AntSyncSerialInitialize: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    158            u32 u32EventTimer;
    159            bool bErrorStatus = FALSE;
   \        0x2   0x2400             MOVS     R4,#+0
    160            
    161            /* Initialize buffer pointers */  
    162            Ant_pu8AntRxBufferNextChar    = Ant_au8AntRxBuffer;
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable15
   \        0x8   0x.... 0x....      LDR.W    R1,??DataTable14
   \        0xC   0x6008             STR      R0,[R1, #+0]
    163            Ant_pu8AntRxBufferCurrentChar = Ant_au8AntRxBuffer;
   \        0xE   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \       0x12   0x6008             STR      R0,[R1, #+0]
    164            Ant_pu8AntRxBufferUnreadMsg   = Ant_au8AntRxBuffer;
   \       0x14   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \       0x18   0x6008             STR      R0,[R1, #+0]
    165            Ant_u8AntNewRxMessages = 0;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \       0x20   0x7008             STRB     R0,[R1, #+0]
    166           
    167            /* Reset the 51422 and initialize SRDY and MRDY */
    168            u32EventTimer = G_u32SystemTime1ms;
   \       0x22   0x.... 0x....      LDR.W    R5,??DataTable14_2
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0x9000             STR      R0,[SP, #+0]
    169            ANT_RESET_ASSERT();
   \       0x2A   0xF45F 0x1600      MOVS     R6,#+2097152
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable14_3  ;; 0x400e0e34
   \       0x32   0x6006             STR      R6,[R0, #+0]
    170            SYNC_MRDY_DEASSERT();
   \       0x34   0x.... 0x....      LDR.W    R7,??DataTable15_3  ;; 0x400e0e30
   \       0x38   0xF45F 0x0000      MOVS     R0,#+8388608
   \       0x3C   0x6038             STR      R0,[R7, #+0]
    171            SYNC_SRDY_DEASSERT();
   \       0x3E   0xF05F 0x7080      MOVS     R0,#+16777216
   \       0x42   0x6038             STR      R0,[R7, #+0]
    172            while( !IsTimeUp(&u32EventTimer, ANT_RESET_WAIT_MS) );
   \                     ??AntSyncSerialInitialize_0: (+1)
   \       0x44   0x2164             MOVS     R1,#+100
   \       0x46   0x4668             MOV      R0,SP
   \       0x48   0x.... 0x....      BL       IsTimeUp
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD0F9             BEQ.N    ??AntSyncSerialInitialize_0
    173            ANT_RESET_DEASSERT();
   \       0x50   0x603E             STR      R6,[R7, #+0]
    174            u32EventTimer = G_u32SystemTime1ms;
   \       0x52   0x6828             LDR      R0,[R5, #+0]
   \       0x54   0x9000             STR      R0,[SP, #+0]
    175            while( !IsTimeUp(&u32EventTimer, ANT_RESTART_DELAY_MS) );
   \                     ??AntSyncSerialInitialize_1: (+1)
   \       0x56   0xF44F 0x717A      MOV      R1,#+1000
   \       0x5A   0x4668             MOV      R0,SP
   \       0x5C   0x.... 0x....      BL       IsTimeUp
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD0F8             BEQ.N    ??AntSyncSerialInitialize_1
    176          
    177            
    178            /* ANT should want to send message 0x6F now to indicate it has reset */
    179            u32EventTimer = G_u32SystemTime1ms;
   \       0x64   0x6828             LDR      R0,[R5, #+0]
   \       0x66   0x9000             STR      R0,[SP, #+0]
    180            while( !IS_SEN_ASSERTED() && !bErrorStatus )
   \                     ??AntSyncSerialInitialize_2: (+1)
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \       0x6C   0x6800             LDR      R0,[R0, #+0]
   \       0x6E   0x07C0             LSLS     R0,R0,#+31
   \       0x70   0xD40A             BMI.N    ??AntSyncSerialInitialize_3
   \       0x72   0x0020             MOVS     R0,R4
   \       0x74   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD106             BNE.N    ??AntSyncSerialInitialize_3
    181            {
    182              bErrorStatus = IsTimeUp(&u32EventTimer, ANT_MSG_TIMEOUT_MS);
   \       0x7A   0xF44F 0x717A      MOV      R1,#+1000
   \       0x7E   0x4668             MOV      R0,SP
   \       0x80   0x.... 0x....      BL       IsTimeUp
   \       0x84   0x0004             MOVS     R4,R0
   \       0x86   0xE7EF             B.N      ??AntSyncSerialInitialize_2
    183            }
    184          
    185            if (!bErrorStatus)
   \                     ??AntSyncSerialInitialize_3: (+1)
   \       0x88   0x0020             MOVS     R0,R4
   \       0x8A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD111             BNE.N    ??AntSyncSerialInitialize_4
    186            {
    187              /* Receive and process the restart message */
    188              AntRxMessage();
   \       0x90   0x.... 0x....      BL       AntRxMessage
    189              AntProcessMessage();   
   \       0x94   0x.... 0x....      BL       AntProcessMessage
    190          
    191            /* Send out version request message and expect response */
    192              G_au8ANTGetVersion[4] = AntCalculateTxChecksum(&G_au8ANTGetVersion[0]);
   \       0x98   0x.... 0x....      LDR.W    R5,??DataTable16
   \       0x9C   0x0028             MOVS     R0,R5
   \       0x9E   0x.... 0x....      BL       AntCalculateTxChecksum
   \       0xA2   0x7128             STRB     R0,[R5, #+4]
    193              AntTxMessage(&G_au8ANTGetVersion[0]);    
   \       0xA4   0x0028             MOVS     R0,R5
   \       0xA6   0x.... 0x....      BL       AntTxMessage
    194              AntExpectResponse(MESG_VERSION_ID, ANT_MSG_TIMEOUT_MS);
   \       0xAA   0xF44F 0x717A      MOV      R1,#+1000
   \       0xAE   0x203E             MOVS     R0,#+62
   \       0xB0   0x.... 0x....      BL       AntExpectResponse
    195            }
    196           
    197          } /* end AntSyncSerialInitialize */
   \                     ??AntSyncSerialInitialize_4: (+1)
   \       0xB4   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    198          
    199          
    200          /*-----------------------------------------------------------------------------
    201          Function: AntSrdyPulse
    202          
    203          Description:
    204          Pulses Srdy with added delays on the front and middle. 
    205          
    206          Requires:
    207            - 
    208          
    209          Promises:
    210            - A delay controlled by ANT_SRDY_DELAY is passed
    211            - SRDY is asserted
    212            - A delay of ANT_SRDY_PERIOD is passed
    213            - SRDY is deasserted
    214          */

   \                                 In section .text, align 2, keep-with-next
    215          static void AntSrdyPulse(void)
    216          {
    217            for(u32 i = 0; i < ANT_SRDY_DELAY; i++);
   \                     AntSrdyPulse: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \                     ??AntSrdyPulse_0: (+1)
   \        0x2   0x28C8             CMP      R0,#+200
   \        0x4   0xD201             BCS.N    ??AntSrdyPulse_1
   \        0x6   0x1C40             ADDS     R0,R0,#+1
   \        0x8   0xE7FB             B.N      ??AntSrdyPulse_0
    218            SYNC_SRDY_ASSERT();
   \                     ??AntSrdyPulse_1: (+1)
   \        0xA   0xF05F 0x7080      MOVS     R0,#+16777216
   \        0xE   0x.... 0x....      LDR.W    R1,??DataTable14_3  ;; 0x400e0e34
   \       0x12   0x6008             STR      R0,[R1, #+0]
    219            
    220            for(u32 i = 0; i < ANT_SRDY_PERIOD; i++);
   \       0x14   0x2100             MOVS     R1,#+0
   \                     ??AntSrdyPulse_2: (+1)
   \       0x16   0x2914             CMP      R1,#+20
   \       0x18   0xD201             BCS.N    ??AntSrdyPulse_3
   \       0x1A   0x1C49             ADDS     R1,R1,#+1
   \       0x1C   0xE7FB             B.N      ??AntSrdyPulse_2
    221            SYNC_SRDY_DEASSERT();
   \                     ??AntSrdyPulse_3: (+1)
   \       0x1E   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0x400e0e30
   \       0x22   0x6008             STR      R0,[R1, #+0]
    222          
    223          } /* end AntSrdyPulse() */
   \       0x24   0x4770             BX       LR               ;; return
    224          
    225          
    226          /*-----------------------------------------------------------------------------
    227          Function: AntRxMessage
    228          
    229          Description:
    230          Completely receive a message from ANT to the Host.  Incoming bytes are deposited directly into the receive
    231          buffer from the SSP ISR which should be extremely fast and complete in a maximum of 500us.  
    232          
    233          Requires:
    234            - _SSP_CS_ASSERTED is set indicating a message is ready to come in 
    235            - G_u32AntFlags _ANT_FLAGS_TX_INTERRUPTED is set if the system wanted to transmit
    236              but ANT wanted to send a message at the same time (so MESG_TX_SYNC has already 
    237              been received); _SSP_RX_COMPLETE must still be set from this.
    238            - Ant_pu8AntRxBufferCurrentChar points to the first byte of the message
    239          
    240          Promises:
    241            - If a good new message has been received, then Ant_u8AntNewMessages is incremented
    242              and the message is at Ant_pu8AntRxBufferUnreadMsg in Ant_au8AntRxBuffer
    243            - If a good message is not received, then Ant_u8AntNewMessages is unchanged.
    244            - In both cases, Ant_pu8AntRxBufferNextChar points at the next empty buffer location
    245          */

   \                                 In section .text, align 2, keep-with-next
    246          static void AntRxMessage(void)
    247          {
   \                     AntRxMessage: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB08C             SUB      SP,SP,#+48
    248            u8 u8Checksum;
    249            u8 u8Length;
    250            u32 u32CurrentRxByteCount;
    251            u8 au8RxTimeoutMsg[] = "AntRx: timeout\n\r";
   \        0x6   0xA807             ADD      R0,SP,#+28
   \        0x8   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \        0xC   0x2211             MOVS     R2,#+17
   \        0xE   0x.... 0x....      BL       __aeabi_memcpy
    252            u8 au8RxFailMsg[] = "AntRx: message failed\n\r";
   \       0x12   0xA801             ADD      R0,SP,#+4
   \       0x14   0x.... 0x....      LDR.W    R1,??DataTable14_6
   \       0x18   0x2218             MOVS     R2,#+24
   \       0x1A   0x.... 0x....      BL       __aeabi_memcpy4
    253            bool bReceptionError = FALSE;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xF88D 0x0000      STRB     R0,[SP, #+0]
    254            
    255            /* Ensure we have CS flag */
    256            if( !( IS_SEN_ASSERTED() ) )
   \       0x24   0x.... 0x....      LDR.W    R4,??DataTable14_4
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x07C0             LSLS     R0,R0,#+31
   \       0x2C   0xF140 0x80CC      BPL.W    ??AntRxMessage_0
    257            {
    258              return;
    259            }
    260            
    261            /* Initialize the receive timer and get a snapshot of current byte count */
    262            u32CurrentRxByteCount = Ant_u32RxByteCounter;
   \                     ??AntRxMessage_1: (+1)
   \       0x30   0x.... 0x....      LDR.W    R10,??DataTable14_7
   \       0x34   0xF8DA 0x7000      LDR      R7,[R10, #+0]
    263            Ant_u32RxTimer = 0;
   \       0x38   0x.... 0x....      LDR.W    R5,??DataTable14_8
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x6028             STR      R0,[R5, #+0]
    264            
    265            /* If the Global _ANT_FLAGS_TX_INTERRUPTED flag has been set, then we have already read the TX_SYNC byte */
    266            if(G_u32AntFlags & _ANT_FLAGS_TX_INTERRUPTED)
   \       0x40   0x.... 0x....      LDR.W    R11,??DataTable14_9
   \       0x44   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x48   0x00C0             LSLS     R0,R0,#+3
   \       0x4A   0xD507             BPL.N    ??AntRxMessage_2
    267            {
    268              /* Clear flag and load the value we know was already received to allow the function to proceed*/
    269              G_u32AntFlags &= ~_ANT_FLAGS_TX_INTERRUPTED;
   \       0x4C   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x50   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \       0x54   0xF8CB 0x0000      STR      R0,[R11, #+0]
    270              
    271              /* Adjust the starting byte counter since it came in during AntTxMessage */
    272              u32CurrentRxByteCount--;
   \       0x58   0x1E7F             SUBS     R7,R7,#+1
   \       0x5A   0xE00D             B.N      ??AntRxMessage_3
    273              
    274            }
    275            /* Otherwise we need to first read the sync byte  */
    276            else
    277            {
    278              /* Do short delay then cycle SRDY to get the first byte */
    279              AntSrdyPulse();
   \                     ??AntRxMessage_2: (+1)
   \       0x5C   0x.... 0x....      BL       AntSrdyPulse
    280          
    281              /* Begin the receive cycle that takes place using interrupts and callbacks and is monitored by a timeout of 
    282              about 500us - this should be plenty of time to receive even the longest ANT message but still only half the 
    283              allowed 1ms loop time for the system. */
    284              
    285              /* Read the first byte when it comes in */
    286              while( !(ANT_SSP_FLAGS & _SSP_RX_COMPLETE) &&
    287                     (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_4: (+1)
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x0740             LSLS     R0,R0,#+29
   \       0x64   0xD408             BMI.N    ??AntRxMessage_3
   \       0x66   0x6828             LDR      R0,[R5, #+0]
   \       0x68   0xF242 0x7110      MOVW     R1,#+10000
   \       0x6C   0x4288             CMP      R0,R1
   \       0x6E   0xD203             BCS.N    ??AntRxMessage_3
    288              {
    289                Ant_u32RxTimer++;
   \       0x70   0x6828             LDR      R0,[R5, #+0]
   \       0x72   0x1C40             ADDS     R0,R0,#+1
   \       0x74   0x6028             STR      R0,[R5, #+0]
   \       0x76   0xE7F3             B.N      ??AntRxMessage_4
    290              }
    291            }
    292            
    293            if( Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT) 
   \                     ??AntRxMessage_3: (+1)
   \       0x78   0x6828             LDR      R0,[R5, #+0]
   \       0x7A   0xF242 0x7111      MOVW     R1,#+10001
   \       0x7E   0x4288             CMP      R0,R1
   \       0x80   0xD305             BCC.N    ??AntRxMessage_5
    294            {
    295              AntAbortMessage();
   \       0x82   0x.... 0x....      BL       AntAbortMessage
    296              DebugPrintf(au8RxTimeoutMsg);
   \       0x86   0xA807             ADD      R0,SP,#+28
   \       0x88   0x.... 0x....      BL       DebugPrintf
    297              return;
   \       0x8C   0xE09C             B.N      ??AntRxMessage_0
    298            }
    299          
    300            /* _SSP_RX_COMPLETE flag will be set and the Rx callback will have run.  
    301            The callback does NOT toggle SRDY yet.  _SSP_RX_COMPLETE should still
    302            be set from AntTxMessage if that's what got us here. */
    303            ANT_SSP_FLAGS &= ~_SSP_RX_COMPLETE;
   \                     ??AntRxMessage_5: (+1)
   \       0x8E   0x6820             LDR      R0,[R4, #+0]
   \       0x90   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x94   0x6020             STR      R0,[R4, #+0]
    304             
    305            /* One way or the other, we now have a potential SYNC byte at Ant_pu8AntRxBufferCurrentChar.  
    306            Proceed to test it and receive the rest of the message */
    307            if (*Ant_pu8AntRxBufferCurrentChar == MESG_TX_SYNC)                     
   \       0x96   0x.... 0x....      LDR.W    R6,??DataTable14_1
   \       0x9A   0x6830             LDR      R0,[R6, #+0]
   \       0x9C   0x7800             LDRB     R0,[R0, #+0]
   \       0x9E   0x28A4             CMP      R0,#+164
   \       0xA0   0xD166             BNE.N    ??AntRxMessage_6
    308            {
    309              /* Flag that a reception is in progress */
    310              G_u32AntFlags |= _ANT_FLAGS_RX_IN_PROGRESS;
   \       0xA2   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0xA6   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \       0xAA   0xF8CB 0x0000      STR      R0,[R11, #+0]
    311              
    312              /* Delay and then cycle SRDY to get the next byte (length) */
    313              AntSrdyPulse();
   \       0xAE   0x.... 0x....      BL       AntSrdyPulse
    314              
    315              /* The SSP interrupts and Rx callback handle the rest of the reception until a full message is received. 
    316              We know it is received when SEN is deasserted. */
    317              while( IS_SEN_ASSERTED() && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_7: (+1)
   \       0xB2   0x6820             LDR      R0,[R4, #+0]
   \       0xB4   0x07C0             LSLS     R0,R0,#+31
   \       0xB6   0xD508             BPL.N    ??AntRxMessage_8
   \       0xB8   0x6828             LDR      R0,[R5, #+0]
   \       0xBA   0xF242 0x7110      MOVW     R1,#+10000
   \       0xBE   0x4288             CMP      R0,R1
   \       0xC0   0xD203             BCS.N    ??AntRxMessage_8
    318              {
    319                Ant_u32RxTimer++;
   \       0xC2   0x6828             LDR      R0,[R5, #+0]
   \       0xC4   0x1C40             ADDS     R0,R0,#+1
   \       0xC6   0x6028             STR      R0,[R5, #+0]
   \       0xC8   0xE7F3             B.N      ??AntRxMessage_7
    320              }
    321            
    322              /* One way or another, this Rx is done! */
    323              G_u32AntFlags &= ~_ANT_FLAGS_RX_IN_PROGRESS;
   \                     ??AntRxMessage_8: (+1)
   \       0xCA   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0xCE   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \       0xD2   0xF8CB 0x0000      STR      R0,[R11, #+0]
    324              ANT_SSP_FLAGS &= ~_SSP_RX_COMPLETE;
   \       0xD6   0x6820             LDR      R0,[R4, #+0]
   \       0xD8   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0xDC   0x6020             STR      R0,[R4, #+0]
    325          
    326              /* Check that the above loop ended as expected and didn't time out */
    327              if(Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT)
   \       0xDE   0x6828             LDR      R0,[R5, #+0]
   \       0xE0   0xF242 0x7110      MOVW     R1,#+10000
   \       0xE4   0x4288             CMP      R0,R1
   \       0xE6   0xD23A             BCS.N    ??AntRxMessage_9
    328              {  
    329                /* Update counter to see how many bytes we should have */
    330                u32CurrentRxByteCount = Ant_u32RxByteCounter - u32CurrentRxByteCount;
   \       0xE8   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0xEC   0x1BC7             SUBS     R7,R0,R7
    331              
    332                /* RxBufferCurrentChar is still pointing to the SYNC byte. Validate what should be a complete message now. */
    333                u8Checksum = *Ant_pu8AntRxBufferCurrentChar;
   \       0xEE   0x6830             LDR      R0,[R6, #+0]
   \       0xF0   0x7800             LDRB     R0,[R0, #+0]
   \       0xF2   0x4680             MOV      R8,R0
    334                AdvanceAntRxBufferCurrentChar();
   \       0xF4   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    335                
    336                /* Read the length byte and add two to count the length byte and message ID but not checksum as length will be our checksum counter */
    337                u8Length = *Ant_pu8AntRxBufferCurrentChar + 2;  
   \       0xF8   0x6830             LDR      R0,[R6, #+0]
   \       0xFA   0x7800             LDRB     R0,[R0, #+0]
   \       0xFC   0x1C80             ADDS     R0,R0,#+2
   \       0xFE   0x4681             MOV      R9,R0
    338                
    339                /* Optional check (u8Length does not include the SYNC byte or Checksum byte so add 2) */
    340                if(u32CurrentRxByteCount != (u8Length + 2) )
   \      0x100   0x4648             MOV      R0,R9
   \      0x102   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x104   0x1C80             ADDS     R0,R0,#+2
   \      0x106   0x4287             CMP      R7,R0
   \      0x108   0xD005             BEQ.N    ??AntRxMessage_10
    341                {
    342                  /* Could throw out the message right away - this could save some potential weird memory accesses
    343                  if there was any corruption or a wild u8Length value */
    344                  G_u32AntFlags |= _ANT_FLAGS_LENGTH_MISMATCH;
   \      0x10A   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x10E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x112   0xF8CB 0x0000      STR      R0,[R11, #+0]
    345                }
    346           
    347                /* Validate the remaining bytes based on u8Length*/
    348                do
    349                {
    350                  u8Checksum ^= *Ant_pu8AntRxBufferCurrentChar;                     
   \                     ??AntRxMessage_10: (+1)
   \      0x116   0x6830             LDR      R0,[R6, #+0]
   \      0x118   0x7800             LDRB     R0,[R0, #+0]
   \      0x11A   0xEA90 0x0808      EORS     R8,R0,R8
    351                  AdvanceAntRxBufferCurrentChar();
   \      0x11E   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    352                } while (--u8Length);
   \      0x122   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \      0x126   0x4648             MOV      R0,R9
   \      0x128   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x12A   0x2800             CMP      R0,#+0
   \      0x12C   0xD1F3             BNE.N    ??AntRxMessage_10
    353                
    354                /* AntRxBufferCurrentChar is pointing to the last received byte that should be the checksum. */
    355                if (u8Checksum == *Ant_pu8AntRxBufferCurrentChar)      
   \      0x12E   0x4640             MOV      R0,R8
   \      0x130   0x6831             LDR      R1,[R6, #+0]
   \      0x132   0x7809             LDRB     R1,[R1, #+0]
   \      0x134   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x136   0x4288             CMP      R0,R1
   \      0x138   0xD10A             BNE.N    ??AntRxMessage_11
    356                {
    357                  Ant_u8AntNewRxMessages++;
   \      0x13A   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \      0x13E   0x7801             LDRB     R1,[R0, #+0]
   \      0x140   0x1C49             ADDS     R1,R1,#+1
   \      0x142   0x7001             STRB     R1,[R0, #+0]
    358                  Ant_DebugTotalRxMessages++;
   \      0x144   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \      0x148   0x6801             LDR      R1,[R0, #+0]
   \      0x14A   0x1C49             ADDS     R1,R1,#+1
   \      0x14C   0x6001             STR      R1,[R0, #+0]
   \      0x14E   0xE017             B.N      ??AntRxMessage_12
    359                }
    360                /* If the message was not good, then move Ant_pu8AntRxBufferUnreadMsg passed the garbage data */
    361                else
    362                {
    363                  Ant_pu8AntRxBufferUnreadMsg = Ant_pu8AntRxBufferCurrentChar;
   \                     ??AntRxMessage_11: (+1)
   \      0x150   0x6830             LDR      R0,[R6, #+0]
   \      0x152   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \      0x156   0x6008             STR      R0,[R1, #+0]
    364                  AdvanceAntRxBufferUnreadMsgPointer();
   \      0x158   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   \      0x15C   0xE010             B.N      ??AntRxMessage_12
    365                }
    366              } 
    367              else
    368              {
    369                Ant_u32RxTimeoutCounter++;
   \                     ??AntRxMessage_9: (+1)
   \      0x15E   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \      0x162   0x6801             LDR      R1,[R0, #+0]
   \      0x164   0x1C49             ADDS     R1,R1,#+1
   \      0x166   0x6001             STR      R1,[R0, #+0]
    370                bReceptionError = TRUE;
   \      0x168   0x2001             MOVS     R0,#+1
   \      0x16A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \      0x16E   0xE007             B.N      ??AntRxMessage_12
    371              }
    372            } /* end if(*Ant_pu8AntRxBufferCurrentChar == MESG_TX_SYNC) */
    373            else
    374            {
    375              /* Otherwise we have received an unexpected byte -- flag it, clear Ssp flags and abandon the byte */
    376              Ant_u32UnexpectedByteCounter++;
   \                     ??AntRxMessage_6: (+1)
   \      0x170   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \      0x174   0x6801             LDR      R1,[R0, #+0]
   \      0x176   0x1C49             ADDS     R1,R1,#+1
   \      0x178   0x6001             STR      R1,[R0, #+0]
    377              bReceptionError = TRUE;
   \      0x17A   0x2001             MOVS     R0,#+1
   \      0x17C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    378            }
    379          
    380            /* If a reception error has occured, */
    381            if(bReceptionError)
   \                     ??AntRxMessage_12: (+1)
   \      0x180   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x184   0x2800             CMP      R0,#+0
   \      0x186   0xD01D             BEQ.N    ??AntRxMessage_13
    382            {
    383              /* Toggle SRDY until CS deasserts and throw out the message */
    384              DebugPrintf(au8RxFailMsg);
   \      0x188   0xA801             ADD      R0,SP,#+4
   \      0x18A   0x.... 0x....      BL       DebugPrintf
    385              while( IS_SEN_ASSERTED()  && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_14: (+1)
   \      0x18E   0x6820             LDR      R0,[R4, #+0]
   \      0x190   0x07C0             LSLS     R0,R0,#+31
   \      0x192   0xD50A             BPL.N    ??AntRxMessage_15
   \      0x194   0x6828             LDR      R0,[R5, #+0]
   \      0x196   0xF242 0x7110      MOVW     R1,#+10000
   \      0x19A   0x4288             CMP      R0,R1
   \      0x19C   0xD205             BCS.N    ??AntRxMessage_15
    386              {
    387                Ant_u32RxTimer++;
   \      0x19E   0x6828             LDR      R0,[R5, #+0]
   \      0x1A0   0x1C40             ADDS     R0,R0,#+1
   \      0x1A2   0x6028             STR      R0,[R5, #+0]
    388                AntSrdyPulse();
   \      0x1A4   0x.... 0x....      BL       AntSrdyPulse
   \      0x1A8   0xE7F1             B.N      ??AntRxMessage_14
    389              }
    390             
    391              /* Since we have flow control, we can safely assume that no other messages
    392              have come in and Ant_pu8AntRxBufferNextChar is pointing to where the next 
    393              valid message WILL come in - so push all the pointers there. */
    394              Ant_pu8AntRxBufferCurrentChar = Ant_pu8AntRxBufferNextChar;
   \                     ??AntRxMessage_15: (+1)
   \      0x1AA   0x.... 0x....      LDR.W    R0,??DataTable14
   \      0x1AE   0x6801             LDR      R1,[R0, #+0]
   \      0x1B0   0x6031             STR      R1,[R6, #+0]
    395              Ant_pu8AntRxBufferUnreadMsg = Ant_pu8AntRxBufferNextChar;
   \      0x1B2   0x6800             LDR      R0,[R0, #+0]
   \      0x1B4   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \      0x1B8   0x6008             STR      R0,[R1, #+0]
    396              ANT_SSP_FLAGS &= ~(_SSP_TX_COMPLETE | _SSP_RX_COMPLETE);
   \      0x1BA   0x6820             LDR      R0,[R4, #+0]
   \      0x1BC   0xF030 0x0006      BICS     R0,R0,#0x6
   \      0x1C0   0x6020             STR      R0,[R4, #+0]
   \      0x1C2   0xE001             B.N      ??AntRxMessage_16
    397          
    398            }
    399            else
    400            {
    401              /* In all other cases, finish by advancing the current byte pointer */
    402              AdvanceAntRxBufferCurrentChar();
   \                     ??AntRxMessage_13: (+1)
   \      0x1C4   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    403            }
    404            
    405          } /* end AntRxMessage() */
   \                     ??AntRxMessage_16: (+1)
   \                     ??AntRxMessage_0: (+1)
   \      0x1C8   0xB00D             ADD      SP,SP,#+52
   \      0x1CA   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    406          
    407          
    408          /*-----------------------------------------------------------------------------
    409          Function: AntAbortMessage
    410          
    411          Description:
    412          Kills the current message in progress with ANT and resets all of the pointers.
    413          Any existing received buffer data is lost.
    414          
    415          *** Warning: all interrupts are disabled, so this could impact system tick time ***
    416          
    417          Requires:
    418            - 
    419          
    420          Promises:
    421            - Ant_pu8AntRxBufferNextChar, Ant_pu8AntRxBufferCurrentChar, Ant_pu8AntRxBufferUnreadMsg,
    422              and Ant_u8AntNewRxMessages reset.
    423          */

   \                                 In section .text, align 2, keep-with-next
    424          static void AntAbortMessage(void)
    425          {
    426            __disable_interrupt();
   \                     AntAbortMessage: (+1)
   \        0x0   0xB672             CPSID    I
    427            Ant_pu8AntRxBufferNextChar = &Ant_au8AntRxBuffer[0];
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable15
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable14
   \        0xA   0x6008             STR      R0,[R1, #+0]
    428            Ant_pu8AntRxBufferCurrentChar = &Ant_au8AntRxBuffer[0];
   \        0xC   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \       0x10   0x6008             STR      R0,[R1, #+0]
    429            Ant_pu8AntRxBufferUnreadMsg = &Ant_au8AntRxBuffer[0];
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \       0x16   0x6008             STR      R0,[R1, #+0]
    430            Ant_u8AntNewRxMessages = 0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \       0x1E   0x7008             STRB     R0,[R1, #+0]
    431            __enable_interrupt();
   \       0x20   0xB662             CPSIE    I
    432            
    433          } /* end AntAbortMessage() */
   \       0x22   0x4770             BX       LR               ;; return
    434          
    435          
    436          /*-----------------------------------------------------------------------------
    437          Function: AdvanceAntRxBufferCurrentChar
    438          
    439          Description:
    440          Safely advances the Ant_pu8AntRxBufferCurrentChar within the circular buffer
    441          
    442          Requires:
    443            - No interrupt functions using Ant_pu8AntRxBufferCurrentChar are allowed to run
    444          
    445          Promises:
    446            - Ant_pu8AntRxBufferCurrentChar points to the next char to write in Ant_au8AntRxBuffer
    447          */

   \                                 In section .text, align 2, keep-with-next
    448          static void AdvanceAntRxBufferCurrentChar(void)
    449          {
    450            Ant_pu8AntRxBufferCurrentChar++;
   \                     AdvanceAntRxBufferCurrentChar: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x1C49             ADDS     R1,R1,#+1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    451            if(Ant_pu8AntRxBufferCurrentChar == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable15
   \        0xE   0x6802             LDR      R2,[R0, #+0]
   \       0x10   0xF511 0x7380      ADDS     R3,R1,#+256
   \       0x14   0x429A             CMP      R2,R3
   \       0x16   0xD100             BNE.N    ??AdvanceAntRxBufferCurrentChar_0
    452            {
    453              Ant_pu8AntRxBufferCurrentChar = &Ant_au8AntRxBuffer[0];
   \       0x18   0x6001             STR      R1,[R0, #+0]
    454            }
    455            
    456          } /* end AdvanceAntRxBufferCurrentChar() */
   \                     ??AdvanceAntRxBufferCurrentChar_0: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
    457          
    458          
    459          /*-----------------------------------------------------------------------------/
    460          Function: AdvanceAntRxBufferUnreadMsgPointer
    461          
    462          Description:
    463          Increments the Rx buffer pointer and handles the wrap-around.
    464          
    465          Requires:
    466            - Ant_pu8AntRxBufferUnreadMsg cannot be moved in an ISR
    467          
    468          Promises:
    469            - Ant_pu8AntRxBufferUnreadMsg is pointing to the next char in the circular buffer
    470          */

   \                                 In section .text, align 2, keep-with-next
    471          static void AdvanceAntRxBufferUnreadMsgPointer()
    472          {
    473            Ant_pu8AntRxBufferUnreadMsg++;
   \                     AdvanceAntRxBufferUnreadMsgPointer: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x1C49             ADDS     R1,R1,#+1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    474            if (Ant_pu8AntRxBufferUnreadMsg == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable15
   \        0xE   0x6802             LDR      R2,[R0, #+0]
   \       0x10   0xF511 0x7380      ADDS     R3,R1,#+256
   \       0x14   0x429A             CMP      R2,R3
   \       0x16   0xD100             BNE.N    ??AdvanceAntRxBufferUnreadMsgPointer_0
    475            {
    476              Ant_pu8AntRxBufferUnreadMsg = &Ant_au8AntRxBuffer[0];
   \       0x18   0x6001             STR      R1,[R0, #+0]
    477            }
    478            
    479          } /* end AdvanceAntRxBufferUnreadMsgPointer() */
   \                     ??AdvanceAntRxBufferUnreadMsgPointer_0: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
    480          
    481            
    482          /*------------------------------------------------------------------------------
    483          Function: AntParseExtendedData
    484          
    485          Description:
    486          Reads extended data based on the flags that are set.
    487          Loads into AntExtendedDataType which currently has these fields:
    488          {
    489            u8 u8Channel;                        
    490            u16 u16DeviceID;                         
    491            u8 u8DeviceType;                         
    492            u8 u8TransType;                          
    493            u8 u8Flags;                             
    494            s8 s8RSSI;                              
    495          } AntExtendedDataType;
    496          
    497          Requires:
    498            - pu8SourceMessage_ points to an ANT message buffer that holds a complete ANT data
    499              message structure except for SYNC byte.  antmessage.h Buffer Indices an then be used.
    500            - psExtDataTarget_ points to the target AntExtendedDataType structure
    501          
    502          Promises:
    503            - If extended data is present, all values are read into local variables and then
    504              loaded into psExtDataTarget_ and the function returns TRUE.
    505            - If no extended data is present, psExtDataTarget_ is set to default values and
    506              the function returns FALSE.
    507          */

   \                                 In section .text, align 2, keep-with-next
    508          static bool AntParseExtendedData(u8* pu8SourceMessage, AntExtendedDataType* psExtDataTarget_)
    509          {
   \                     AntParseExtendedData: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    510            bool bReturnValue;
    511            u8 u8MessageSize;
    512            u8 u8Channel;                        
    513            u8 u8Flags = 0;       
   \        0x8   0x2600             MOVS     R6,#+0
    514            u8 u8BufferOffset = 0;
   \        0xA   0xF05F 0x0B00      MOVS     R11,#+0
    515            
    516            /* Channel ID extended data */
    517            u16 u16DeviceID = 0xFFFF;;                         
   \        0xE   0xF64F 0x79FF      MOVW     R9,#+65535
   \       0x12   0xF8AD 0x9002      STRH     R9,[SP, #+2]
    518            u8 u8DeviceType = 0xFF;                        
   \       0x16   0x27FF             MOVS     R7,#+255
   \       0x18   0xF88D 0x7000      STRB     R7,[SP, #+0]
    519            u8 u8TransType = 0xFF;                          
    520          
    521            /* RSSI extended data */
    522            s8 s8RSSI = 0xFF;   
   \       0x1C   0xF05F 0x38FF      MOVS     R8,#-1
    523            //For now, we don't have a use for these two:
    524            //u8 u8MeasurementType = 0xFF;
    525            //u8 u8Threshold = 0xFF;
    526            
    527            /* RF Timestamp data */
    528            u16 u16RxTimestamp = 0xFFFF;
    529              
    530            /* Get generic data */
    531            u8MessageSize = *(pu8SourceMessage + BUFFER_INDEX_MESG_SIZE);
   \       0x20   0xF894 0xA000      LDRB     R10,[R4, #+0]
    532            u8Channel = *(pu8SourceMessage + BUFFER_INDEX_CHANNEL_NUM);
   \       0x24   0x78A0             LDRB     R0,[R4, #+2]
   \       0x26   0xF88D 0x0001      STRB     R0,[SP, #+1]
    533          
    534            /* Check to see if the message is the regular size (MESG_MAX_DATA_SIZE) */
    535            if(u8MessageSize == MESG_MAX_DATA_SIZE)
   \       0x2A   0x4650             MOV      R0,R10
   \       0x2C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2E   0x2809             CMP      R0,#+9
   \       0x30   0xD101             BNE.N    ??AntParseExtendedData_0
    536            {
    537              bReturnValue = FALSE;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xE04E             B.N      ??AntParseExtendedData_1
    538            }
    539            
    540            /* Check for a message that is too big or too small */
    541            else if( (u8MessageSize > MESG_MAX_SIZE) ||
    542                     (u8MessageSize < MESG_MAX_DATA_SIZE) )
   \                     ??AntParseExtendedData_0: (+1)
   \       0x36   0x4650             MOV      R0,R10
   \       0x38   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x3A   0x2812             CMP      R0,#+18
   \       0x3C   0xDA03             BGE.N    ??AntParseExtendedData_2
   \       0x3E   0x4650             MOV      R0,R10
   \       0x40   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x42   0x2809             CMP      R0,#+9
   \       0x44   0xDA05             BGE.N    ??AntParseExtendedData_3
    543            {
    544              DebugPrintf("\n\rUnexpected ANT message size\n\n\r");
   \                     ??AntParseExtendedData_2: (+1)
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable20
   \       0x4A   0x.... 0x....      BL       DebugPrintf
    545              bReturnValue = FALSE;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xE040             B.N      ??AntParseExtendedData_1
    546            }
    547            
    548            /* Otherwise we have some extended message data */
    549            else 
    550            {
    551              /* Byte after data must be flag byte */
    552              u8Flags = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA_FLAGS);
   \                     ??AntParseExtendedData_3: (+1)
   \       0x52   0x7AE0             LDRB     R0,[R4, #+11]
   \       0x54   0x0006             MOVS     R6,R0
    553              bReturnValue = TRUE;
   \       0x56   0x2001             MOVS     R0,#+1
    554              
    555              /* Channel ID information is always first if it's there */
    556              if(u8Flags & LIB_CONFIG_CHANNEL_ID_FLAG)
   \       0x58   0x0631             LSLS     R1,R6,#+24
   \       0x5A   0xD51E             BPL.N    ??AntParseExtendedData_4
    557              {
    558                u16DeviceID = (u16)(*(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset)) & 0x00FF;
   \       0x5C   0x4659             MOV      R1,R11
   \       0x5E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x60   0x4421             ADD      R1,R4,R1
   \       0x62   0x7B09             LDRB     R1,[R1, #+12]
    559                u8BufferOffset++;
   \       0x64   0xF11B 0x0B01      ADDS     R11,R11,#+1
    560                u16DeviceID |= ( (u16)(*(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset)) << 8 ) & 0xFF00;
   \       0x68   0x465A             MOV      R2,R11
   \       0x6A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x6C   0x4422             ADD      R2,R4,R2
   \       0x6E   0x7B12             LDRB     R2,[R2, #+12]
   \       0x70   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \       0x74   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    561                u8BufferOffset++;
   \       0x78   0xF11B 0x0B01      ADDS     R11,R11,#+1
    562                u8DeviceType = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
   \       0x7C   0x4659             MOV      R1,R11
   \       0x7E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x80   0x4421             ADD      R1,R4,R1
   \       0x82   0x7B09             LDRB     R1,[R1, #+12]
   \       0x84   0xF88D 0x1000      STRB     R1,[SP, #+0]
    563                u8BufferOffset++;
   \       0x88   0xF11B 0x0B01      ADDS     R11,R11,#+1
    564                u8TransType = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
   \       0x8C   0x4659             MOV      R1,R11
   \       0x8E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x90   0x4421             ADD      R1,R4,R1
   \       0x92   0x7B09             LDRB     R1,[R1, #+12]
   \       0x94   0x000F             MOVS     R7,R1
    565                u8BufferOffset++;
   \       0x96   0xF11B 0x0B01      ADDS     R11,R11,#+1
    566              }
    567              
    568              /* RSSI information is always next if it's there */
    569              if(u8Flags & LIB_CONFIG_RSSI_FLAG)
   \                     ??AntParseExtendedData_4: (+1)
   \       0x9A   0x0671             LSLS     R1,R6,#+25
   \       0x9C   0xD50B             BPL.N    ??AntParseExtendedData_5
    570              {
    571                //u8MeasurementType = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
    572                u8BufferOffset++;
   \       0x9E   0xF11B 0x0B01      ADDS     R11,R11,#+1
    573                s8RSSI = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
   \       0xA2   0x4659             MOV      R1,R11
   \       0xA4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0xA6   0x4421             ADD      R1,R4,R1
   \       0xA8   0xF991 0x100C      LDRSB    R1,[R1, #+12]
   \       0xAC   0x4688             MOV      R8,R1
    574                u8BufferOffset++;
   \       0xAE   0xF11B 0x0B01      ADDS     R11,R11,#+1
    575                //u8Threshold = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
    576                u8BufferOffset++;
   \       0xB2   0xF11B 0x0B01      ADDS     R11,R11,#+1
    577             }   
    578          
    579              /* Timestamp information is always last */
    580              if(u8Flags & LIB_CONFIG_RX_TIMESTAMP_FLAG)
   \                     ??AntParseExtendedData_5: (+1)
   \       0xB6   0x06B1             LSLS     R1,R6,#+26
   \       0xB8   0xD50C             BPL.N    ??AntParseExtendedData_1
    581              {
    582                u16RxTimestamp = (u16)(*(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset)) & 0x00FF;
   \       0xBA   0x4659             MOV      R1,R11
   \       0xBC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0xBE   0x4421             ADD      R1,R4,R1
   \       0xC0   0x7B09             LDRB     R1,[R1, #+12]
    583                u8BufferOffset++;
   \       0xC2   0xF11B 0x0B01      ADDS     R11,R11,#+1
    584                u16RxTimestamp |= ( (u16)(*(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset)) << 8 ) & 0xFF00;
   \       0xC6   0x465A             MOV      R2,R11
   \       0xC8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xCA   0x4422             ADD      R2,R4,R2
   \       0xCC   0x7B12             LDRB     R2,[R2, #+12]
   \       0xCE   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \       0xD2   0x4689             MOV      R9,R1
    585              }
    586            }
    587            
    588            /* Load psExtDataTarget_ and return */
    589            psExtDataTarget_->u8Flags      = u8Flags;
   \                     ??AntParseExtendedData_1: (+1)
   \       0xD4   0x706E             STRB     R6,[R5, #+1]
    590            psExtDataTarget_->u8Channel    = u8Channel;
   \       0xD6   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \       0xDA   0x7029             STRB     R1,[R5, #+0]
    591            psExtDataTarget_->u16DeviceID  = u16DeviceID;
   \       0xDC   0xF8BD 0x1002      LDRH     R1,[SP, #+2]
   \       0xE0   0x8069             STRH     R1,[R5, #+2]
    592            psExtDataTarget_->u8DeviceType = u8DeviceType;
   \       0xE2   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0xE6   0x7129             STRB     R1,[R5, #+4]
    593            psExtDataTarget_->u8TransType  = u8TransType;
   \       0xE8   0x716F             STRB     R7,[R5, #+5]
    594            psExtDataTarget_->s8RSSI       = s8RSSI;
   \       0xEA   0xF885 0x8006      STRB     R8,[R5, #+6]
    595          
    596            return bReturnValue;
   \       0xEE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xF0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    597            
    598          } /* end AntParseExtendedData */
    599          
    600          
    601          /***********************************************************************************************************************
    602          @@@@@ ANT Interface-layer Functions
    603          ***********************************************************************************************************************/
    604            
    605          /*------------------------------------------------------------------------------
    606          Function: AntInitialize
    607          
    608          Description:
    609          Intialize the ANT system.  ANT device is reset and communication checked through
    610          a version request.  The main channel parameters are then set up to default values.
    611            
    612          Requires:
    613            - ANT_SPI peripheral is correctly configured
    614            - Debug system is initialized so debug messages can be sent to UART
    615          
    616          Promises:
    617            - G_stAntSetupData set to default ANT values
    618            - If all successful, G_u32SystemFlags.AntGood bit is set and ANT system is ready
    619            - Ant_pfnStateMachine = AntSM_Idle
    620          */

   \                                 In section .text, align 2, keep-with-next
    621          void AntInitialize(void)
    622          {
   \                     AntInitialize: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    623            u32 u32AntPortAPins, u32AntPortBPins;
    624          
    625            if(G_u32SystemFlags & _SYSTEM_STARTUP_NO_ANT)
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable19
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x01C0             LSLS     R0,R0,#+7
   \        0xA   0xD509             BPL.N    ??AntInitialize_0
    626            {
    627              DebugPrintf(G_au8AntMessageNoAnt);
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \       0x10   0x.... 0x....      BL       DebugPrintf
    628              Ant_pfnStateMachine = AntSM_NoResponse;
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \       0x18   0x.... 0x....      LDR.W    R1,??DataTable21
   \       0x1C   0x6008             STR      R0,[R1, #+0]
   \       0x1E   0xE0CD             B.N      ??AntInitialize_1
    629            }
    630            else
    631            {
    632              /* Give PIO control of ANT_RESET line */
    633              AT91C_BASE_PIOB->PIO_OER = PB_21_ANT_RESET;
   \                     ??AntInitialize_0: (+1)
   \       0x20   0xF45F 0x1000      MOVS     R0,#+2097152
   \       0x24   0x.... 0x....      LDR.W    R1,??DataTable20_1  ;; 0x400e0e10
   \       0x28   0x6008             STR      R0,[R1, #+0]
    634              
    635              /* Announce on the debug port that ANT setup is starting and intialize pointers */
    636              DebugPrintf(G_au8AntMessageInit);
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \       0x2E   0x.... 0x....      BL       DebugPrintf
    637              G_sAntApplicationMsgList = 0;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \       0x38   0x6008             STR      R0,[R1, #+0]
    638              Ant_psDataOutgoingMsgList = 0;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x.... 0x....      LDR.W    R1,??DataTable21_2
   \       0x40   0x6008             STR      R0,[R1, #+0]
    639            
    640            /* Initialize the G_asAntChannelConfiguration data struct */
    641            for(u8 i = 0; i < ANT_NUM_CHANNELS; i++)
   \       0x42   0x2000             MOVS     R0,#+0
   \                     ??AntInitialize_2: (+1)
   \       0x44   0x0001             MOVS     R1,R0
   \       0x46   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x48   0x2908             CMP      R1,#+8
   \       0x4A   0xDA51             BGE.N    ??AntInitialize_3
    642            {
    643              G_asAntChannelConfiguration[i].AntChannel          = (AntChannelNumberType)i;
   \       0x4C   0x2114             MOVS     R1,#+20
   \       0x4E   0x.... 0x....      LDR.W    R2,??DataTable21_3
   \       0x52   0x0003             MOVS     R3,R0
   \       0x54   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0x56   0x434B             MULS     R3,R1,R3
   \       0x58   0x54D0             STRB     R0,[R2, R3]
    644              G_asAntChannelConfiguration[i].AntChannelType      = 0xFF;
   \       0x5A   0x23FF             MOVS     R3,#+255
   \       0x5C   0x0006             MOVS     R6,R0
   \       0x5E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x60   0x434E             MULS     R6,R1,R6
   \       0x62   0x4416             ADD      R6,R2,R6
   \       0x64   0x7073             STRB     R3,[R6, #+1]
    645              G_asAntChannelConfiguration[i].AntNetwork          = 0xFF;
   \       0x66   0x0006             MOVS     R6,R0
   \       0x68   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x6A   0x434E             MULS     R6,R1,R6
   \       0x6C   0x4416             ADD      R6,R2,R6
   \       0x6E   0x70B3             STRB     R3,[R6, #+2]
    646              G_asAntChannelConfiguration[i].AntDeviceIdLo       = 0xFF;
   \       0x70   0x0006             MOVS     R6,R0
   \       0x72   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x74   0x434E             MULS     R6,R1,R6
   \       0x76   0x4416             ADD      R6,R2,R6
   \       0x78   0x72F3             STRB     R3,[R6, #+11]
    647              G_asAntChannelConfiguration[i].AntDeviceIdHi       = 0xFF;
   \       0x7A   0x0006             MOVS     R6,R0
   \       0x7C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x7E   0x434E             MULS     R6,R1,R6
   \       0x80   0x4416             ADD      R6,R2,R6
   \       0x82   0x7333             STRB     R3,[R6, #+12]
    648              G_asAntChannelConfiguration[i].AntDeviceType       = 0xFF;
   \       0x84   0x0006             MOVS     R6,R0
   \       0x86   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x88   0x434E             MULS     R6,R1,R6
   \       0x8A   0x4416             ADD      R6,R2,R6
   \       0x8C   0x7373             STRB     R3,[R6, #+13]
    649              G_asAntChannelConfiguration[i].AntTransmissionType = 0xFF;
   \       0x8E   0x0006             MOVS     R6,R0
   \       0x90   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x92   0x434E             MULS     R6,R1,R6
   \       0x94   0x4416             ADD      R6,R2,R6
   \       0x96   0x73B3             STRB     R3,[R6, #+14]
    650              G_asAntChannelConfiguration[i].AntChannelPeriodLo  = 0xFF;
   \       0x98   0x0006             MOVS     R6,R0
   \       0x9A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x9C   0x434E             MULS     R6,R1,R6
   \       0x9E   0x4416             ADD      R6,R2,R6
   \       0xA0   0x73F3             STRB     R3,[R6, #+15]
    651              G_asAntChannelConfiguration[i].AntChannelPeriodHi  = 0xFF;
   \       0xA2   0x0006             MOVS     R6,R0
   \       0xA4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0xA6   0x434E             MULS     R6,R1,R6
   \       0xA8   0x4416             ADD      R6,R2,R6
   \       0xAA   0x7433             STRB     R3,[R6, #+16]
    652              G_asAntChannelConfiguration[i].AntFrequency        = 0xFF;
   \       0xAC   0x0006             MOVS     R6,R0
   \       0xAE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0xB0   0x434E             MULS     R6,R1,R6
   \       0xB2   0x4416             ADD      R6,R2,R6
   \       0xB4   0x7473             STRB     R3,[R6, #+17]
    653              G_asAntChannelConfiguration[i].AntTxPower          = 0xFF;
   \       0xB6   0x0006             MOVS     R6,R0
   \       0xB8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0xBA   0x434E             MULS     R6,R1,R6
   \       0xBC   0x4416             ADD      R6,R2,R6
   \       0xBE   0x74B3             STRB     R3,[R6, #+18]
    654              G_asAntChannelConfiguration[i].AntFlags            = 0;
   \       0xC0   0x0003             MOVS     R3,R0
   \       0xC2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0xC4   0x434B             MULS     R3,R1,R3
   \       0xC6   0x4413             ADD      R3,R2,R3
   \       0xC8   0x2600             MOVS     R6,#+0
   \       0xCA   0x74DE             STRB     R6,[R3, #+19]
    655              
    656              for(u8 j = 0; j < ANT_NETWORK_NUMBER_BYTES; j++)
   \       0xCC   0x2300             MOVS     R3,#+0
   \                     ??AntInitialize_4: (+1)
   \       0xCE   0x001E             MOVS     R6,R3
   \       0xD0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0xD2   0x2E08             CMP      R6,#+8
   \       0xD4   0xDA0A             BGE.N    ??AntInitialize_5
    657              {
    658                G_asAntChannelConfiguration[i].AntNetworkKey[j] = 0;
   \       0xD6   0x0006             MOVS     R6,R0
   \       0xD8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0xDA   0x434E             MULS     R6,R1,R6
   \       0xDC   0x4416             ADD      R6,R2,R6
   \       0xDE   0x001F             MOVS     R7,R3
   \       0xE0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \       0xE2   0x443E             ADD      R6,R6,R7
   \       0xE4   0x2700             MOVS     R7,#+0
   \       0xE6   0x70F7             STRB     R7,[R6, #+3]
    659              }
   \       0xE8   0x1C5B             ADDS     R3,R3,#+1
   \       0xEA   0xE7F0             B.N      ??AntInitialize_4
    660            }
   \                     ??AntInitialize_5: (+1)
   \       0xEC   0x1C40             ADDS     R0,R0,#+1
   \       0xEE   0xE7A9             B.N      ??AntInitialize_2
    661              
    662              /* Configure the SSP resource to be used for the application */
    663              Ant_sSspConfig.SspPeripheral      = ANT_SPI;
   \                     ??AntInitialize_3: (+1)
   \       0xF0   0x.... 0x....      LDR.W    R0,??DataTable21_4
   \       0xF4   0x2104             MOVS     R1,#+4
   \       0xF6   0x7001             STRB     R1,[R0, #+0]
    664              Ant_sSspConfig.pCsGpioAddress     = ANT_SPI_CS_GPIO;
   \       0xF8   0x.... 0x....      LDR.W    R6,??DataTable21_5  ;; 0x400e0e00
   \       0xFC   0x6046             STR      R6,[R0, #+4]
    665              Ant_sSspConfig.u32CsPin           = ANT_SPI_CS_PIN;
   \       0xFE   0xF45F 0x0180      MOVS     R1,#+4194304
   \      0x102   0x6081             STR      R1,[R0, #+8]
    666              Ant_sSspConfig.eBitOrder          = LSB_FIRST;
   \      0x104   0x2101             MOVS     R1,#+1
   \      0x106   0x7301             STRB     R1,[R0, #+12]
    667              Ant_sSspConfig.eSspMode           = SPI_SLAVE_FLOW_CONTROL;
   \      0x108   0x2103             MOVS     R1,#+3
   \      0x10A   0x7341             STRB     R1,[R0, #+13]
    668              Ant_sSspConfig.fnSlaveTxFlowCallback = AntTxFlowControlCallback;
   \      0x10C   0x.... 0x....      ADR.W    R1,AntTxFlowControlCallback
   \      0x110   0x6101             STR      R1,[R0, #+16]
    669              Ant_sSspConfig.fnSlaveRxFlowCallback = AntRxFlowControlCallback;
   \      0x112   0x.... 0x....      ADR.W    R1,AntRxFlowControlCallback
   \      0x116   0x6141             STR      R1,[R0, #+20]
    670              Ant_sSspConfig.pu8RxBufferAddress = Ant_au8AntRxBuffer;
   \      0x118   0x.... 0x....      LDR.W    R1,??DataTable15
   \      0x11C   0x6181             STR      R1,[R0, #+24]
    671              Ant_sSspConfig.ppu8RxNextByte     = &Ant_pu8AntRxBufferNextChar;
   \      0x11E   0x.... 0x....      LDR.W    R1,??DataTable14
   \      0x122   0x61C1             STR      R1,[R0, #+28]
    672              Ant_sSspConfig.u16RxBufferSize    = ANT_RX_BUFFER_SIZE;
   \      0x124   0xF44F 0x7180      MOV      R1,#+256
   \      0x128   0x8401             STRH     R1,[R0, #+32]
    673          
    674              Ant_Ssp = SspRequest(&Ant_sSspConfig);
   \      0x12A   0x.... 0x....      BL       SspRequest
   \      0x12E   0x.... 0x....      LDR.W    R1,??DataTable21_6
   \      0x132   0x6008             STR      R0,[R1, #+0]
    675              ANT_SSP_FLAGS = 0;
   \      0x134   0x2000             MOVS     R0,#+0
   \      0x136   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \      0x13A   0x6008             STR      R0,[R1, #+0]
    676              
    677              /* Reset ANT, activate SPI interface and get a test message */
    678              AntSyncSerialInitialize();
   \      0x13C   0x.... 0x....      BL       AntSyncSerialInitialize
    679              
    680              /* Report status out the debug port */
    681              if(G_u32ApplicationFlags & _APPLICATION_FLAGS_ANT)  
   \      0x140   0x.... 0x....      LDR.W    R0,??DataTable21_7
   \      0x144   0x7800             LDRB     R0,[R0, #+0]
   \      0x146   0x06C0             LSLS     R0,R0,#+27
   \      0x148   0xD519             BPL.N    ??AntInitialize_6
    682              {
    683                DebugPrintf(G_au8AntMessageOk);
   \      0x14A   0x.... 0x....      LDR.W    R0,??DataTable21_8
   \      0x14E   0x.... 0x....      BL       DebugPrintf
    684                DebugPrintf("ANT version: ");
   \      0x152   0x.... 0x....      LDR.W    R0,??DataTable21_9
   \      0x156   0x.... 0x....      BL       DebugPrintf
    685                DebugPrintf(Ant_u8AntVersion);
   \      0x15A   0x.... 0x....      LDR.W    R0,??DataTable21_10
   \      0x15E   0x.... 0x....      BL       DebugPrintf
    686                DebugLineFeed();
   \      0x162   0x.... 0x....      BL       DebugLineFeed
    687                
    688                G_u32AntFlags &= ~_ANT_FLAGS_RESTART;
   \      0x166   0x.... 0x....      LDR.W    R0,??DataTable14_9
   \      0x16A   0x6801             LDR      R1,[R0, #+0]
   \      0x16C   0xF431 0x3180      BICS     R1,R1,#0x10000
   \      0x170   0x6001             STR      R1,[R0, #+0]
    689                Ant_pfnStateMachine = AntSM_Idle;
   \      0x172   0x.... 0x....      ADR.W    R0,AntSM_Idle
   \      0x176   0x.... 0x....      LDR.W    R1,??DataTable21
   \      0x17A   0x6008             STR      R0,[R1, #+0]
   \      0x17C   0xE01E             B.N      ??AntInitialize_1
    690              }
    691              else
    692              {
    693                /* The ANT device is not responding -- it may be dead, or it may not yet
    694                be loaded with any firmware.  Regardless, float all of the interface lines so 
    695                that any programmer or other firmware will not be impacted by the Host MCU */
    696                DebugPrintf(G_au8AntMessageInitFail);
   \                     ??AntInitialize_6: (+1)
   \      0x17E   0x.... 0x....      LDR.W    R0,??DataTable21_11
   \      0x182   0x.... 0x....      BL       DebugPrintf
    697          
    698                /* Make sure all ANT pins are on the PIO controller */
    699                u32AntPortAPins = ANT_PIOA_PINS;
   \      0x186   0xF05F 0x7030      MOVS     R0,#+46137344
   \      0x18A   0x0004             MOVS     R4,R0
    700                u32AntPortBPins = ANT_PIOB_PINS;
   \      0x18C   0xF05F 0x70F0      MOVS     R0,#+31457280
   \      0x190   0x0005             MOVS     R5,R0
    701                
    702                AT91C_BASE_PIOA->PIO_PDR = u32AntPortAPins;
   \      0x192   0x.... 0x....      LDR.W    R0,??DataTable21_12  ;; 0x400e0c04
   \      0x196   0x6004             STR      R4,[R0, #+0]
    703                AT91C_BASE_PIOA->PIO_PER = u32AntPortAPins;
   \      0x198   0x.... 0x....      LDR.W    R0,??DataTable21_13  ;; 0x400e0c00
   \      0x19C   0x6004             STR      R4,[R0, #+0]
    704                AT91C_BASE_PIOB->PIO_PDR = u32AntPortBPins;
   \      0x19E   0x.... 0x....      LDR.W    R0,??DataTable21_14  ;; 0x400e0e04
   \      0x1A2   0x6005             STR      R5,[R0, #+0]
    705                AT91C_BASE_PIOB->PIO_PER = u32AntPortBPins;
   \      0x1A4   0x6035             STR      R5,[R6, #+0]
    706          
    707                /* Disable all outputs (set to HiZ input) */
    708                AT91C_BASE_PIOA->PIO_ODR = u32AntPortAPins;
   \      0x1A6   0x.... 0x....      LDR.W    R0,??DataTable21_15  ;; 0x400e0c14
   \      0x1AA   0x6004             STR      R4,[R0, #+0]
    709                AT91C_BASE_PIOB->PIO_ODR = u32AntPortBPins;
   \      0x1AC   0x.... 0x....      LDR.W    R0,??DataTable21_16  ;; 0x400e0e14
   \      0x1B0   0x6005             STR      R5,[R0, #+0]
    710                
    711                Ant_pfnStateMachine = AntSM_NoResponse;
   \      0x1B2   0x.... 0x....      ADR.W    R0,AntSM_NoResponse
   \      0x1B6   0x.... 0x....      LDR.W    R1,??DataTable21
   \      0x1BA   0x6008             STR      R0,[R1, #+0]
    712              }
    713            }
    714          } /* end AntInitialize() */
   \                     ??AntInitialize_1: (+1)
   \      0x1BC   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    715          
    716          
    717          /*----------------------------------------------------------------------------------------------------------------------
    718          Function AntRunActiveState()
    719          
    720          Description:
    721          Selects and runs one iteration of the current state in the state machine.
    722          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    723          may take 1ms / n to execute.
    724          
    725          Requires:
    726            - State machine function pointer points at current state
    727          
    728          Promises:
    729            - Calls the function to pointed by the state machine function pointer
    730          */

   \                                 In section .text, align 2, keep-with-next
    731          void AntRunActiveState(void)
    732          {
   \                     AntRunActiveState: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    733            Ant_pfnStateMachine();
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable21
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x4780             BLX      R0
    734          
    735          } /* end AntRunActiveState */
   \        0xA   0xBD01             POP      {R0,PC}          ;; return
    736          
    737          
    738          /*-----------------------------------------------------------------------------
    739          Function: AntTxMessage
    740          
    741          Description:
    742          Send a message from the Host to the ANT device.  To do this, we must tell ANT that we have
    743          a message to send by asserting MRDY, wait for ANT to acknowlege with SEN, then read a byte from
    744          ANT to confirm the transmission can proceed.  If ANT happens to wants to send a message at the
    745          same time, the byte it sends will be an Rx byte so the AntTxMessage must suspend and go read the 
    746          incoming message first.  The process would restart after that.
    747          
    748          Once ANT confirms that the Host may transmit, the message to transmit is queued and data is sent byte-by-byte with SRDY used for flow
    749          control after each byte.  Due to the speed of the chip-to-chip communications, even the longest ANT message
    750          should be able to send in less than 500us so it will likely be done on the main program cycle that
    751          immediately follows this call.  
    752          
    753          Requires:
    754            - pu8AntTxMessage_ points to an Ant formatted message where the first data byte
    755              is the length byte (since ANT sends the SYNC byte) and the last byte is
    756              the checksum.
    757          
    758          Promises:
    759            - Returns TRUE if the transmit message is queued successfully; Ant_u32CurrentTxMessageToken holds the message token
    760            - Returns FALSE if the transfer couldn't start or if receive message interrupted
    761              (G_u32AntFlags _ANT_FLAGS_TX_INTERRUPTED is set;  AntRxBufferCurrentChar pointing to the received byte).
    762            - MRDY is deasserted
    763          */

   \                                 In section .text, align 2, keep-with-next
    764          bool AntTxMessage(u8 *pu8AntTxMessage_)
    765          {
   \                     AntTxMessage: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB099             SUB      SP,SP,#+100
   \        0x6   0x0004             MOVS     R4,R0
    766            u8 u8Byte;
    767            u32 u32Length;
    768            u32 u32TimeOut = G_u32SystemTime1s;
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable21_17
   \        0xC   0x6805             LDR      R5,[R0, #+0]
    769            u8 au8TxInProgressMsg[] = "AntTx: msg already in progress\n\r";
   \        0xE   0xA810             ADD      R0,SP,#+64
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable21_18
   \       0x14   0x2221             MOVS     R2,#+33
   \       0x16   0x.... 0x....      BL       __aeabi_memcpy
    770            u8 au8TxTimeoutMsg[]    = "AntTx: SEN timeout\n\r";
   \       0x1A   0xA80A             ADD      R0,SP,#+40
   \       0x1C   0x.... 0x....      LDR.W    R1,??DataTable21_19
   \       0x20   0x2215             MOVS     R2,#+21
   \       0x22   0x.... 0x....      BL       __aeabi_memcpy
    771            u8 au8TxNoTokenMsg[]    = "AntTx: No token\n\r";
   \       0x26   0xA805             ADD      R0,SP,#+20
   \       0x28   0x.... 0x....      LDR.W    R1,??DataTable21_20
   \       0x2C   0x2212             MOVS     R2,#+18
   \       0x2E   0x.... 0x....      BL       __aeabi_memcpy
    772            u8 au8TxNoSyncMsg[]     = "AntTx: No SYNC\n\r";
   \       0x32   0x4668             MOV      R0,SP
   \       0x34   0x.... 0x....      LDR.W    R1,??DataTable21_21
   \       0x38   0x2211             MOVS     R2,#+17
   \       0x3A   0x.... 0x....      BL       __aeabi_memcpy
    773          
    774            /* Check G_u32AntFlags first */
    775            if(G_u32AntFlags & (_ANT_FLAGS_TX_IN_PROGRESS | _ANT_FLAGS_RX_IN_PROGRESS) )
   \       0x3E   0x.... 0x....      LDR.W    R6,??DataTable14_9
   \       0x42   0x6830             LDR      R0,[R6, #+0]
   \       0x44   0xF010 0x6F40      TST      R0,#0xC000000
   \       0x48   0xD004             BEQ.N    ??AntTxMessage_0
    776            {
    777              DebugPrintf(au8TxInProgressMsg);
   \       0x4A   0xA810             ADD      R0,SP,#+64
   \       0x4C   0x.... 0x....      BL       DebugPrintf
    778              return FALSE;
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xE07B             B.N      ??AntTxMessage_1
    779            }
    780            
    781            /* Initialize the timeout timer and notify ANT that the Host wishes to send a message */
    782            Ant_u32RxTimer = 0;
   \                     ??AntTxMessage_0: (+1)
   \       0x54   0x.... 0x....      LDR.W    R7,??DataTable14_8
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x6038             STR      R0,[R7, #+0]
    783            SYNC_MRDY_ASSERT();                          
   \       0x5C   0xF45F 0x0800      MOVS     R8,#+8388608
   \       0x60   0x....             LDR.N    R0,??DataTable14_3  ;; 0x400e0e34
   \       0x62   0xF8C0 0x8000      STR      R8,[R0, #+0]
    784          
    785            /* Wait for SEN to be asserted indicating ANT is ready for a message */
    786            while ( !IS_SEN_ASSERTED() && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntTxMessage_2: (+1)
   \       0x66   0x.... 0x....      LDR.W    R9,??DataTable14_4
   \       0x6A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x6E   0x07C0             LSLS     R0,R0,#+31
   \       0x70   0xD408             BMI.N    ??AntTxMessage_3
   \       0x72   0x6838             LDR      R0,[R7, #+0]
   \       0x74   0xF242 0x7110      MOVW     R1,#+10000
   \       0x78   0x4288             CMP      R0,R1
   \       0x7A   0xD203             BCS.N    ??AntTxMessage_3
    787            {
    788              Ant_u32RxTimer++;
   \       0x7C   0x6838             LDR      R0,[R7, #+0]
   \       0x7E   0x1C40             ADDS     R0,R0,#+1
   \       0x80   0x6038             STR      R0,[R7, #+0]
   \       0x82   0xE7F0             B.N      ??AntTxMessage_2
    789            }
    790            
    791            /* If we timed out, then clear MRDY and exit */
    792            if(Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT)
   \                     ??AntTxMessage_3: (+1)
   \       0x84   0xF242 0x7A11      MOVW     R10,#+10001
   \       0x88   0x6838             LDR      R0,[R7, #+0]
   \       0x8A   0x4550             CMP      R0,R10
   \       0x8C   0xD308             BCC.N    ??AntTxMessage_4
    793            {
    794              SYNC_MRDY_DEASSERT();                          
   \       0x8E   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x400e0e30
   \       0x92   0xF8C0 0x8000      STR      R8,[R0, #+0]
    795              DebugPrintf(au8TxTimeoutMsg);
   \       0x96   0xA80A             ADD      R0,SP,#+40
   \       0x98   0x.... 0x....      BL       DebugPrintf
    796              return(FALSE);
   \       0x9C   0x2000             MOVS     R0,#+0
   \       0x9E   0xE055             B.N      ??AntTxMessage_1
    797            }
    798            
    799            /* Else we have SEN flag; queue to read 1 byte after a short delay before toggling SRDY */
    800            AntSrdyPulse();
   \                     ??AntTxMessage_4: (+1)
   \       0xA0   0x.... 0x....      BL       AntSrdyPulse
    801          
    802            /* Wait for the first byte to come in via the ISR / Rx Callback*/
    803            while( !(ANT_SSP_FLAGS & _SSP_RX_COMPLETE) && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntTxMessage_5: (+1)
   \       0xA4   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xA8   0x0740             LSLS     R0,R0,#+29
   \       0xAA   0xD408             BMI.N    ??AntTxMessage_6
   \       0xAC   0x6838             LDR      R0,[R7, #+0]
   \       0xAE   0xF242 0x7110      MOVW     R1,#+10000
   \       0xB2   0x4288             CMP      R0,R1
   \       0xB4   0xD203             BCS.N    ??AntTxMessage_6
    804            {
    805              Ant_u32RxTimer++;
   \       0xB6   0x6838             LDR      R0,[R7, #+0]
   \       0xB8   0x1C40             ADDS     R0,R0,#+1
   \       0xBA   0x6038             STR      R0,[R7, #+0]
   \       0xBC   0xE7F2             B.N      ??AntTxMessage_5
    806            }
    807          
    808            /* Ok to deassert MRDY now */
    809            SYNC_MRDY_DEASSERT();                     
   \                     ??AntTxMessage_6: (+1)
   \       0xBE   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x400e0e30
   \       0xC2   0xF8C0 0x8000      STR      R8,[R0, #+0]
    810          
    811            /* If we timed out now, then clear MRDY and exit.  Because CS is still asserted, the task
    812            will attempt to read a message but fail and eventually abort. */
    813            if(Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT)
   \       0xC6   0x6838             LDR      R0,[R7, #+0]
   \       0xC8   0x4550             CMP      R0,R10
   \       0xCA   0xD304             BCC.N    ??AntTxMessage_7
    814            {
    815             DebugPrintf(au8TxTimeoutMsg);
   \       0xCC   0xA80A             ADD      R0,SP,#+40
   \       0xCE   0x.... 0x....      BL       DebugPrintf
    816             return(FALSE);
   \       0xD2   0x2000             MOVS     R0,#+0
   \       0xD4   0xE03A             B.N      ??AntTxMessage_1
    817            }
    818                    
    819            /* When the byte comes in, the SSP module will set the _SSP_RX_COMPLETE flag and also call the 
    820            Rx callback but does not toggle SRDY at this time.  We must look at this byte to determine if ANT 
    821            initiated this particular communication and is telling us that a message is coming in, or if we 
    822            initiated the communication and ANT is allowing us to transmit. */
    823          
    824            /* Read the byte - don't advance the pointer yet */
    825            u8Byte = *Ant_pu8AntRxBufferCurrentChar;                       
   \                     ??AntTxMessage_7: (+1)
   \       0xD6   0x....             LDR.N    R0,??DataTable14_1
   \       0xD8   0x6800             LDR      R0,[R0, #+0]
   \       0xDA   0x7807             LDRB     R7,[R0, #+0]
    826          
    827            /* If the byte is TX_SYNC, then ANT wants to send a message which must be done first */
    828            if (u8Byte == MESG_TX_SYNC)                     
   \       0xDC   0x0038             MOVS     R0,R7
   \       0xDE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xE0   0x28A4             CMP      R0,#+164
   \       0xE2   0xD105             BNE.N    ??AntTxMessage_8
    829            {
    830              G_u32AntFlags |= _ANT_FLAGS_TX_INTERRUPTED;
   \       0xE4   0x6830             LDR      R0,[R6, #+0]
   \       0xE6   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \       0xEA   0x6030             STR      R0,[R6, #+0]
    831              return(FALSE);
   \       0xEC   0x2000             MOVS     R0,#+0
   \       0xEE   0xE02D             B.N      ??AntTxMessage_1
    832            }
    833          
    834            /* Since the Rx byte is in our Rx buffer, advance both pointers since it's not an incoming message */
    835            AdvanceAntRxBufferCurrentChar();
   \                     ??AntTxMessage_8: (+1)
   \       0xF0   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    836            AdvanceAntRxBufferUnreadMsgPointer();
   \       0xF4   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
    837          
    838            /* Clear the status flag and process the byte */
    839            ANT_SSP_FLAGS &= ~_SSP_RX_COMPLETE; /* !!!!! Odd for this to be here, but maybe it needs to be */
   \       0xF8   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xFC   0xF030 0x0004      BICS     R0,R0,#0x4
   \      0x100   0xF8C9 0x0000      STR      R0,[R9, #+0]
    840            
    841            /* If the byte is RX_SYNC, then proceed to send the message */
    842            if (u8Byte == MESG_RX_SYNC)                     
   \      0x104   0x0038             MOVS     R0,R7
   \      0x106   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x108   0x28A5             CMP      R0,#+165
   \      0x10A   0xD11B             BNE.N    ??AntTxMessage_9
    843            {
    844              /* Flag that a transmit is in progress */
    845              G_u32AntFlags |= _ANT_FLAGS_TX_IN_PROGRESS;
   \      0x10C   0x6830             LDR      R0,[R6, #+0]
   \      0x10E   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \      0x112   0x6030             STR      R0,[R6, #+0]
    846              
    847              /* Read the message length and add three for the length, message ID and checksum */
    848              u32Length = (u32)(pu8AntTxMessage_[0] + 3); 
   \      0x114   0x7826             LDRB     R6,[R4, #+0]
   \      0x116   0x1CF6             ADDS     R6,R6,#+3
    849              
    850              /* Queue the message to the peripheral and capture the token */ 
    851              Ant_u32CurrentTxMessageToken = SspWriteData(Ant_Ssp, u32Length, pu8AntTxMessage_);
   \      0x118   0x.... 0x....      LDR.W    R8,??DataTable21_22
   \      0x11C   0x0022             MOVS     R2,R4
   \      0x11E   0x0031             MOVS     R1,R6
   \      0x120   0x.... 0x....      LDR.W    R0,??DataTable21_6
   \      0x124   0x6800             LDR      R0,[R0, #+0]
   \      0x126   0x.... 0x....      BL       SspWriteData
   \      0x12A   0xF8C8 0x0000      STR      R0,[R8, #+0]
    852          
    853              /* Return TRUE only if we received a message token indicating the message has been queued */
    854              if(Ant_u32CurrentTxMessageToken != 0)
   \      0x12E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x132   0x2800             CMP      R0,#+0
   \      0x134   0xD001             BEQ.N    ??AntTxMessage_10
    855              {
    856                return(TRUE);
   \      0x136   0x2001             MOVS     R0,#+1
   \      0x138   0xE008             B.N      ??AntTxMessage_1
    857              }
    858              else
    859              {
    860                DebugPrintf(au8TxNoTokenMsg);
   \                     ??AntTxMessage_10: (+1)
   \      0x13A   0xA805             ADD      R0,SP,#+20
   \      0x13C   0x.... 0x....      BL       DebugPrintf
    861                return(FALSE);
   \      0x140   0x2000             MOVS     R0,#+0
   \      0x142   0xE003             B.N      ??AntTxMessage_1
    862              }
    863            }
    864          
    865            /* If we get here, not a sync byte, so return */
    866            DebugPrintf(au8TxNoSyncMsg);
   \                     ??AntTxMessage_9: (+1)
   \      0x144   0x4668             MOV      R0,SP
   \      0x146   0x.... 0x....      BL       DebugPrintf
    867            return(FALSE);
   \      0x14A   0x2000             MOVS     R0,#+0
   \                     ??AntTxMessage_1: (+1)
   \      0x14C   0xB01A             ADD      SP,SP,#+104
   \      0x14E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    868          
    869          } /* end AntTxMessage() */
    870          
    871          
    872          /*------------------------------------------------------------------------------
    873          Function: AntExpectResponse
    874          
    875          Description:
    876          Waits a specified amount of time for a particular message to arrive from ANT in 
    877          response to a message sent to ANT.  
    878          
    879          *** This function violates the 1ms system rule, so should only be used during initialization. ***
    880            
    881          Requires:
    882            - u8ExpectedMessageID_ is the ID of a message to which a response is expected
    883            - u32TimeoutMS_ is the maximum value in ms to wait for the response 
    884            - A message had been sent to ANT to which a response should be coming in
    885            - Ant_u8AntNewRxMessages == 0 as this function is meant to run one-to-one with
    886              transmitted messages.
    887            - SSP task should be in manual mode so it is busy sending the Tx message to which
    888              this function will wait for the ANT response.
    889          
    890          Promises:
    891            - Returns 0 if the message is received and was successful
    892            - Returns 1 if a response is never received or if the response indicates the
    893              message was not successful.
    894          */

   \                                 In section .text, align 2, keep-with-next
    895          u8 AntExpectResponse(u8 u8ExpectedMessageID_, u32 u32TimeoutMS_) 
    896          {
   \                     AntExpectResponse: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
    897            bool bTimeout = FALSE;
   \        0xA   0x2600             MOVS     R6,#+0
    898            u8 u8ReturnValue = 1;
   \        0xC   0x2701             MOVS     R7,#+1
    899            u32 u32StartTime = G_u32SystemTime1s;
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable21_17
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x9000             STR      R0,[SP, #+0]
    900            u8 au8AntExpectMsgFail[] = "\r\nANT expected msg fail\n\r";
   \       0x16   0xA801             ADD      R0,SP,#+4
   \       0x18   0x.... 0x....      LDR.W    R1,??DataTable21_23
   \       0x1C   0x221A             MOVS     R2,#+26
   \       0x1E   0x.... 0x....      BL       __aeabi_memcpy
    901          
    902            /* Wait for current message to send */
    903            u32StartTime = G_u32SystemTime1ms;
   \       0x22   0x.... 0x....      LDR.W    R8,??DataTable14_2
   \       0x26   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x2A   0x9000             STR      R0,[SP, #+0]
    904            while( IS_SEN_ASSERTED() && !bTimeout )
   \                     ??AntExpectResponse_0: (+1)
   \       0x2C   0x.... 0x....      LDR.W    R9,??DataTable14_4
   \       0x30   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x34   0x07C0             LSLS     R0,R0,#+31
   \       0x36   0xD50A             BPL.N    ??AntExpectResponse_1
   \       0x38   0x0030             MOVS     R0,R6
   \       0x3A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD106             BNE.N    ??AntExpectResponse_1
    905            {
    906              bTimeout = IsTimeUp(&u32StartTime, ANT_MSG_TIMEOUT_MS);
   \       0x40   0xF44F 0x717A      MOV      R1,#+1000
   \       0x44   0x4668             MOV      R0,SP
   \       0x46   0x.... 0x....      BL       IsTimeUp
   \       0x4A   0x0006             MOVS     R6,R0
   \       0x4C   0xE7EE             B.N      ??AntExpectResponse_0
    907            }
    908          
    909            if( !bTimeout )
   \                     ??AntExpectResponse_1: (+1)
   \       0x4E   0x0030             MOVS     R0,R6
   \       0x50   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD11C             BNE.N    ??AntExpectResponse_2
    910            {
    911              /* Done with this message token, so it can be cleared */
    912              G_u32AntFlags &= ~_ANT_FLAGS_TX_IN_PROGRESS;
   \       0x56   0x....             LDR.N    R0,??DataTable14_9
   \       0x58   0x6801             LDR      R1,[R0, #+0]
   \       0x5A   0xF031 0x6100      BICS     R1,R1,#0x8000000
   \       0x5E   0x6001             STR      R1,[R0, #+0]
    913              AntDeQueueOutgoingMessage();
   \       0x60   0x.... 0x....      BL       AntDeQueueOutgoingMessage
    914              Ant_u32CurrentTxMessageToken = 0;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x.... 0x....      LDR.W    R1,??DataTable21_22
   \       0x6A   0x6008             STR      R0,[R1, #+0]
    915              
    916              /* Wait for SEN */
    917              u32StartTime = G_u32SystemTime1ms;
   \       0x6C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x70   0x9000             STR      R0,[SP, #+0]
    918              while( !IS_SEN_ASSERTED() && !bTimeout )
   \                     ??AntExpectResponse_3: (+1)
   \       0x72   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x76   0x07C0             LSLS     R0,R0,#+31
   \       0x78   0xD40A             BMI.N    ??AntExpectResponse_2
   \       0x7A   0x0030             MOVS     R0,R6
   \       0x7C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD106             BNE.N    ??AntExpectResponse_2
    919              {
    920                bTimeout = IsTimeUp(&u32StartTime, ANT_MSG_TIMEOUT_MS);
   \       0x82   0xF44F 0x717A      MOV      R1,#+1000
   \       0x86   0x4668             MOV      R0,SP
   \       0x88   0x.... 0x....      BL       IsTimeUp
   \       0x8C   0x0006             MOVS     R6,R0
   \       0x8E   0xE7F0             B.N      ??AntExpectResponse_3
    921              }
    922            }
    923            
    924            /* If no timeout then read the incoming message */
    925            if( !bTimeout )
   \                     ??AntExpectResponse_2: (+1)
   \       0x90   0x0030             MOVS     R0,R6
   \       0x92   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD118             BNE.N    ??AntExpectResponse_4
    926            {
    927              AntRxMessage();
   \       0x98   0x.... 0x....      BL       AntRxMessage
    928          
    929              /* If there is a new message in the receive buffer, then check that it is a response to the expected
    930              message and that the response is no error */
    931              if(Ant_u8AntNewRxMessages)
   \       0x9C   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \       0xA0   0x7800             LDRB     R0,[R0, #+0]
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD011             BEQ.N    ??AntExpectResponse_4
    932              {
    933                /* Check if the response is an Event, the event is a reply to the expected message, and the reply is good.
    934                Since Ant_pu8AntRxBufferUnreadMsg is pointing to the SYNC byte, add 1 when using BUFFER_INDEX values. */
    935                if( (*(Ant_pu8AntRxBufferUnreadMsg + MESG_ID_OFFSET) == MESG_RESPONSE_EVENT_ID) &&    
    936                    (*(Ant_pu8AntRxBufferUnreadMsg + MESG_RESPONSE_MESG_ID_OFFSET) == u8ExpectedMessageID_) &&
    937                    (*(Ant_pu8AntRxBufferUnreadMsg + MESG_RESPONSE_CODE_OFFSET) == RESPONSE_NO_ERROR) )
   \       0xA6   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \       0xAA   0x6801             LDR      R1,[R0, #+0]
   \       0xAC   0x7889             LDRB     R1,[R1, #+2]
   \       0xAE   0x2940             CMP      R1,#+64
   \       0xB0   0xD10B             BNE.N    ??AntExpectResponse_4
   \       0xB2   0x6801             LDR      R1,[R0, #+0]
   \       0xB4   0x7909             LDRB     R1,[R1, #+4]
   \       0xB6   0x0022             MOVS     R2,R4
   \       0xB8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xBA   0x4291             CMP      R1,R2
   \       0xBC   0xD105             BNE.N    ??AntExpectResponse_4
   \       0xBE   0x6800             LDR      R0,[R0, #+0]
   \       0xC0   0x7940             LDRB     R0,[R0, #+5]
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD101             BNE.N    ??AntExpectResponse_4
    938                {
    939                  u8ReturnValue = 0;
   \       0xC6   0x2000             MOVS     R0,#+0
   \       0xC8   0x0007             MOVS     R7,R0
    940                }
    941              }
    942            }
    943            
    944            /* Process any message in the RxBuffer and return the result value */
    945            AntProcessMessage();
   \                     ??AntExpectResponse_4: (+1)
   \       0xCA   0x.... 0x....      BL       AntProcessMessage
    946            
    947            if( bTimeout )
   \       0xCE   0x0030             MOVS     R0,R6
   \       0xD0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xD2   0x2800             CMP      R0,#+0
   \       0xD4   0xD002             BEQ.N    ??AntExpectResponse_5
    948            {
    949              DebugPrintf(au8AntExpectMsgFail);
   \       0xD6   0xA801             ADD      R0,SP,#+4
   \       0xD8   0x.... 0x....      BL       DebugPrintf
    950              /* !!!! What clean-up should be done here?  Reset ANT and restart init? */
    951            }
    952          
    953            return(u8ReturnValue);
   \                     ??AntExpectResponse_5: (+1)
   \       0xDC   0x0038             MOVS     R0,R7
   \       0xDE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xE0   0xB009             ADD      SP,SP,#+36
   \       0xE2   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    954          
    955          } /* end AntExpectResponse */
    956          
    957          
    958          /*-----------------------------------------------------------------------------
    959          Function: AntTxFlowControlCallback
    960          
    961          Description:
    962          Callback function to toggle flow control during transmission.  The peripheral task
    963          sending the message must invoke this function after each byte.  
    964          
    965          Note: Since this function is called from an ISR, it should execute as quickly as possible. 
    966          
    967          Requires:
    968            - 
    969          
    970          Promises:
    971            - SRDY is toggled
    972            - Ant_u32TxByteCounter incremented
    973          */
    974          

   \                                 In section .text, align 4, keep-with-next
    975          void AntTxFlowControlCallback(void)
    976          {
   \                     AntTxFlowControlCallback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    977            /* Count the byte and toggle flow control lines */
    978            Ant_u32TxByteCounter++; 
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable21_24
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0x1C49             ADDS     R1,R1,#+1
   \        0xA   0x6001             STR      R1,[R0, #+0]
    979            AntSrdyPulse();
   \        0xC   0x.... 0x....      BL       AntSrdyPulse
    980          
    981          } /* end AntTxFlowControlCallback() */
   \       0x10   0xBD01             POP      {R0,PC}          ;; return
    982          
    983          
    984          /*-----------------------------------------------------------------------------
    985          Function: AntRxFlowControlCallback
    986          
    987          Description:
    988          Callback function to toggle flow control during reception.  The peripheral task
    989          receiving the message must invoke this function after each byte.  
    990          
    991          Note: Since this function is called from an ISR, it should execute as quickly as possible. 
    992          Unfortunately, AntSrdyPulse() takes some time but the duty cycle of this interrupt
    993          is low enough that we can survive (this interrupt priority could be dropped below everything
    994          else to mitigate any issues).
    995          
    996          Requires:
    997            - ISRs are off already since this is totally not re-entrant
    998            - A received byte was just written to the Rx buffer
    999            - _SSP_CS_ASSERTED in correct state: should be set on first byte, but application should 
   1000              clear it for all subsequent bytes so flow control is handled entirely by this function
   1001          
   1002          Promises:
   1003            - Ant_pu8AntRxBufferNextChar is advanced safely so it is ready to receive the next byte
   1004            - Ant_u32RxByteCounter incremented
   1005            - SRDY is toggled if _ANT_FLAGS_RX_IN_PROGRESS is set
   1006          */

   \                                 In section .text, align 4, keep-with-next
   1007          void AntRxFlowControlCallback(void)
   1008          {
   \                     AntRxFlowControlCallback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1009            /* Count the byte and safely advance the receive buffer pointer; this is called from the
   1010            RX ISR, so it won't be interrupted and break Ant_pu8AntRxBufferNextChar */
   1011            Ant_u32RxByteCounter++;
   \        0x2   0x....             LDR.N    R0,??DataTable14_7
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x1C49             ADDS     R1,R1,#+1
   \        0x8   0x6001             STR      R1,[R0, #+0]
   1012            Ant_pu8AntRxBufferNextChar++;
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x1C49             ADDS     R1,R1,#+1
   \       0x12   0x6001             STR      R1,[R0, #+0]
   1013            if(Ant_pu8AntRxBufferNextChar == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \       0x14   0x.... 0x....      LDR.W    R1,??DataTable15
   \       0x18   0x6802             LDR      R2,[R0, #+0]
   \       0x1A   0xF511 0x7380      ADDS     R3,R1,#+256
   \       0x1E   0x429A             CMP      R2,R3
   \       0x20   0xD100             BNE.N    ??AntRxFlowControlCallback_0
   1014            {
   1015              Ant_pu8AntRxBufferNextChar = &Ant_au8AntRxBuffer[0];
   \       0x22   0x6001             STR      R1,[R0, #+0]
   1016            }
   1017            
   1018            /* Only toggle SRDY if a reception is flagged in progress */
   1019            if( G_u32AntFlags & _ANT_FLAGS_RX_IN_PROGRESS )
   \                     ??AntRxFlowControlCallback_0: (+1)
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable21_25
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0x0140             LSLS     R0,R0,#+5
   \       0x2C   0xD501             BPL.N    ??AntRxFlowControlCallback_1
   1020            {
   1021              AntSrdyPulse();
   \       0x2E   0x.... 0x....      BL       AntSrdyPulse
   1022            }
   1023            
   1024          } /* end AntRxFlowControlCallback() */
   \                     ??AntRxFlowControlCallback_1: (+1)
   \       0x32   0xBD01             POP      {R0,PC}          ;; return
   1025          
   1026          
   1027          /*------------------------------------------------------------------------------
   1028          Function: AntCalculateTxChecksum
   1029          
   1030          Description:
   1031          Calculates and returns the checksum for a Host > ANT message.
   1032          
   1033          Requires:
   1034            - pu8Message_ points to the message to transmit
   1035            - the message to transmit is a complete ANT message except the SYNC byte (starts with length byte)
   1036          
   1037          Promises:
   1038            - Finds ANT checksum for the message and returns it
   1039          */

   \                                 In section .text, align 2, keep-with-next
   1040          u8 AntCalculateTxChecksum(u8* pu8Message_)
   1041          {
   \                     AntCalculateTxChecksum: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x0002             MOVS     R2,R0
   1042            u8 u8Size = *pu8Message_ + 2;
   \        0x4   0x7813             LDRB     R3,[R2, #+0]
   \        0x6   0x1C9B             ADDS     R3,R3,#+2
   1043            u8 u8Checksum = MESG_RX_SYNC;
   \        0x8   0x20A5             MOVS     R0,#+165
   1044            
   1045            for(u8 i = 0; i < u8Size; i++)
   \        0xA   0x2400             MOVS     R4,#+0
   \                     ??AntCalculateTxChecksum_0: (+1)
   \        0xC   0x0021             MOVS     R1,R4
   \        0xE   0x001D             MOVS     R5,R3
   \       0x10   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x12   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \       0x14   0x42A9             CMP      R1,R5
   \       0x16   0xD204             BCS.N    ??AntCalculateTxChecksum_1
   1046            {
   1047              u8Checksum ^= *pu8Message_;
   \       0x18   0x7811             LDRB     R1,[R2, #+0]
   \       0x1A   0x4048             EORS     R0,R1,R0
   1048              pu8Message_++;
   \       0x1C   0x1C52             ADDS     R2,R2,#+1
   1049            }
   \       0x1E   0x1C64             ADDS     R4,R4,#+1
   \       0x20   0xE7F4             B.N      ??AntCalculateTxChecksum_0
   1050            
   1051            return(u8Checksum);
   \                     ??AntCalculateTxChecksum_1: (+1)
   \       0x22   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x24   0xBC30             POP      {R4,R5}
   \       0x26   0x4770             BX       LR               ;; return
   1052            
   1053          } /* end AntCalculateTxChecksum() */
   1054          
   1055          
   1056          /*-----------------------------------------------------------------------------/
   1057          Function: AntQueueOutgoingMessage
   1058          
   1059          Description:
   1060          Creates a new ANT message structure and adds it into Ant_psDataOutgoingMsgList.
   1061          If the list is full, the message is not added.
   1062          The Outgoing message list are the messages sent from the Host to the ANT chip.
   1063          
   1064          Requires:
   1065            - pu8Message_ is an ANT-formatted message starting with LENGTH and ending with CHECKSUM
   1066            - Enough space is available on the heap
   1067          
   1068          Promises:
   1069            - A new list item in the outgoing message linked list is created and inserted at the end
   1070              of the list as long as there is enough room.
   1071            - Returns TRUE if the entry is added successfully.
   1072            - Returns FALSE on error.
   1073          */

   \                                 In section .text, align 2, keep-with-next
   1074          bool AntQueueOutgoingMessage(u8 *pu8Message_)
   1075          {
   \                     AntQueueOutgoingMessage: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB08A             SUB      SP,SP,#+40
   \        0x6   0x0006             MOVS     R6,R0
   1076            u8 u8Length;
   1077            u8 u8MessageCount = 0;
   \        0x8   0x2700             MOVS     R7,#+0
   1078            AntOutgoingMessageListType *psNewDataMessage;
   1079            AntOutgoingMessageListType *psListParser;
   1080            u8 au8AddMessageFailMsg[] = "\n\rNo space in AntQueueOutgoingMessage\n\r";
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x.... 0x....      LDR.W    R1,??DataTable21_26
   \       0x10   0x2228             MOVS     R2,#+40
   \       0x12   0x.... 0x....      BL       __aeabi_memcpy4
   1081            
   1082            /* Add to the number of queued message */
   1083            Ant_DebugQueuedDataMessages++;
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable21_27
   \       0x1A   0x6801             LDR      R1,[R0, #+0]
   \       0x1C   0x1C49             ADDS     R1,R1,#+1
   \       0x1E   0x6001             STR      R1,[R0, #+0]
   1084          
   1085            /* Allocate space for the new message - always do maximum message size */
   1086            psNewDataMessage = malloc( sizeof(AntOutgoingMessageListType) );
   \       0x20   0x201C             MOVS     R0,#+28
   \       0x22   0x.... 0x....      BL       malloc
   \       0x26   0x0004             MOVS     R4,R0
   1087            if (psNewDataMessage == NULL)
   \       0x28   0x2C00             CMP      R4,#+0
   \       0x2A   0xD104             BNE.N    ??AntQueueOutgoingMessage_0
   1088            {
   1089              DebugPrintf(au8AddMessageFailMsg);
   \       0x2C   0x4668             MOV      R0,SP
   \       0x2E   0x.... 0x....      BL       DebugPrintf
   1090              return(FALSE);
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xE03D             B.N      ??AntQueueOutgoingMessage_1
   1091            }
   1092            
   1093            /* Fill in all the fields of the newly allocated message structure */
   1094            u8Length = *pu8Message_ + 3;
   \                     ??AntQueueOutgoingMessage_0: (+1)
   \       0x36   0xF896 0x8000      LDRB     R8,[R6, #+0]
   \       0x3A   0xF118 0x0803      ADDS     R8,R8,#+3
   1095            for(u8 i = 0; i < u8Length; i++)
   \       0x3E   0x2000             MOVS     R0,#+0
   \                     ??AntQueueOutgoingMessage_2: (+1)
   \       0x40   0x0001             MOVS     R1,R0
   \       0x42   0x4642             MOV      R2,R8
   \       0x44   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x46   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x48   0x4291             CMP      R1,R2
   \       0x4A   0xD208             BCS.N    ??AntQueueOutgoingMessage_3
   1096            {
   1097              psNewDataMessage->au8MessageData[i] = *(pu8Message_ + i);
   \       0x4C   0x0001             MOVS     R1,R0
   \       0x4E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x50   0x5C71             LDRB     R1,[R6, R1]
   \       0x52   0x0002             MOVS     R2,R0
   \       0x54   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x56   0x4422             ADD      R2,R4,R2
   \       0x58   0x7111             STRB     R1,[R2, #+4]
   1098            }
   \       0x5A   0x1C40             ADDS     R0,R0,#+1
   \       0x5C   0xE7F0             B.N      ??AntQueueOutgoingMessage_2
   1099            
   1100            psNewDataMessage->u32TimeStamp  = G_u32SystemTime1ms;
   \                     ??AntQueueOutgoingMessage_3: (+1)
   \       0x5E   0x....             LDR.N    R0,??DataTable14_2
   \       0x60   0x6800             LDR      R0,[R0, #+0]
   \       0x62   0x6020             STR      R0,[R4, #+0]
   1101            psNewDataMessage->psNextMessage = NULL;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x61A0             STR      R0,[R4, #+24]
   1102          
   1103            /* Insert into an empty list */
   1104            if(Ant_psDataOutgoingMsgList == NULL)
   \       0x68   0x.... 0x....      LDR.W    R1,??DataTable21_2
   \       0x6C   0x6808             LDR      R0,[R1, #+0]
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD106             BNE.N    ??AntQueueOutgoingMessage_4
   1105            {
   1106              Ant_psDataOutgoingMsgList = psNewDataMessage;
   \       0x72   0x600C             STR      R4,[R1, #+0]
   1107              Ant_u32OutgoingMessageCount++;
   \       0x74   0x.... 0x....      LDR.W    R0,??DataTable21_28
   \       0x78   0x6801             LDR      R1,[R0, #+0]
   \       0x7A   0x1C49             ADDS     R1,R1,#+1
   \       0x7C   0x6001             STR      R1,[R0, #+0]
   \       0x7E   0xE017             B.N      ??AntQueueOutgoingMessage_5
   1108            }
   1109          
   1110            /* Otherwise traverse the list to find the end where the new message will be inserted */
   1111            else
   1112            {
   1113              psListParser = Ant_psDataOutgoingMsgList;
   \                     ??AntQueueOutgoingMessage_4: (+1)
   \       0x80   0x6808             LDR      R0,[R1, #+0]
   \       0x82   0x0005             MOVS     R5,R0
   1114              while(psListParser->psNextMessage != NULL)  
   \                     ??AntQueueOutgoingMessage_6: (+1)
   \       0x84   0x69A8             LDR      R0,[R5, #+24]
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD002             BEQ.N    ??AntQueueOutgoingMessage_7
   1115              {
   1116                psListParser = psListParser->psNextMessage;
   \       0x8A   0x69AD             LDR      R5,[R5, #+24]
   1117                u8MessageCount++;
   \       0x8C   0x1C7F             ADDS     R7,R7,#+1
   \       0x8E   0xE7F9             B.N      ??AntQueueOutgoingMessage_6
   1118              }
   1119              
   1120              /* Check for a full list */
   1121              if(u8MessageCount < ANT_OUTGOING_MESSAGE_BUFFER_SIZE)
   \                     ??AntQueueOutgoingMessage_7: (+1)
   \       0x90   0x0038             MOVS     R0,R7
   \       0x92   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x94   0x2820             CMP      R0,#+32
   \       0x96   0xD206             BCS.N    ??AntQueueOutgoingMessage_8
   1122              {
   1123                /* Insert the new message at the end of the list */
   1124                psListParser->psNextMessage = psNewDataMessage;
   \       0x98   0x61AC             STR      R4,[R5, #+24]
   1125                Ant_u32OutgoingMessageCount++;
   \       0x9A   0x.... 0x....      LDR.W    R0,??DataTable21_28
   \       0x9E   0x6801             LDR      R1,[R0, #+0]
   \       0xA0   0x1C49             ADDS     R1,R1,#+1
   \       0xA2   0x6001             STR      R1,[R0, #+0]
   \       0xA4   0xE004             B.N      ??AntQueueOutgoingMessage_5
   1126              }
   1127              else
   1128              {
   1129                DebugPrintf(au8AddMessageFailMsg);
   \                     ??AntQueueOutgoingMessage_8: (+1)
   \       0xA6   0x4668             MOV      R0,SP
   \       0xA8   0x.... 0x....      BL       DebugPrintf
   1130                return(FALSE);
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0xE000             B.N      ??AntQueueOutgoingMessage_1
   1131              }
   1132            }
   1133              
   1134            return(TRUE);
   \                     ??AntQueueOutgoingMessage_5: (+1)
   \       0xB0   0x2001             MOVS     R0,#+1
   \                     ??AntQueueOutgoingMessage_1: (+1)
   \       0xB2   0xB00A             ADD      SP,SP,#+40
   \       0xB4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1135            
   1136          } /* end AntQueueOutgoingMessage() */
   1137          
   1138          
   1139          /*-----------------------------------------------------------------------------/
   1140          Function: AntDeQueueApplicationMessage
   1141          
   1142          Description:
   1143          Releases the first message in G_sAntApplicationMsgList 
   1144          
   1145          Requires:
   1146            - G_sAntApplicationMsgList points to the start of the list which is the entry to remove
   1147          
   1148          Promises:
   1149            - G_sAntApplicationMsgList = G_sAntApplicationMsgList.
   1150          */

   \                                 In section .text, align 2, keep-with-next
   1151          void AntDeQueueApplicationMessage(void)
   1152          {
   \                     AntDeQueueApplicationMessage: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1153            AntApplicationMsgListType *psMessageToKill;
   1154            
   1155            if(G_sAntApplicationMsgList != NULL)
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \        0x6   0x6808             LDR      R0,[R1, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD00C             BEQ.N    ??AntDeQueueApplicationMessage_0
   1156            {
   1157              psMessageToKill = G_sAntApplicationMsgList;
   \        0xC   0x6808             LDR      R0,[R1, #+0]
   \        0xE   0x0004             MOVS     R4,R0
   1158              G_sAntApplicationMsgList = G_sAntApplicationMsgList->psNextMessage;
   \       0x10   0x6808             LDR      R0,[R1, #+0]
   \       0x12   0x6980             LDR      R0,[R0, #+24]
   \       0x14   0x6008             STR      R0,[R1, #+0]
   1159          
   1160              /* The doomed message is properly disconnected, so kill it */
   1161              free(psMessageToKill);
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       free
   1162              Ant_u32ApplicationMessageCount--;
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable21_29
   \       0x20   0x6801             LDR      R1,[R0, #+0]
   \       0x22   0x1E49             SUBS     R1,R1,#+1
   \       0x24   0x6001             STR      R1,[R0, #+0]
   1163            }
   1164            
   1165          } /* end AntDeQueueApplicationMessage() */
   \                     ??AntDeQueueApplicationMessage_0: (+1)
   \       0x26   0xBD10             POP      {R4,PC}          ;; return
   1166          
   1167          
   1168          /* ANT private Interface-layer Functions */
   1169          
   1170                                              
   1171          /*------------------------------------------------------------------------------
   1172          Function: AntProcessMessage
   1173          
   1174          Description:
   1175          Reads the lastest received Ant message and updates system information accordingly. 
   1176            
   1177          Requires:
   1178            - Ant_u8AntNewRxMessages holds the number of unprocessed messages in the message queue
   1179            - GGpu8AntRxBufferUnreadMsg points to the first byte of an unread verified ANT message
   1180          
   1181          Promises:
   1182            - Returns 1 if Ant_u8AntNewRxMessages == 0 or the message exceeds the maximum allowed length
   1183            - Otherwise, returns 0 and:
   1184              - Ant_u8AntNewRxMessages--
   1185              - GGpu8AntRxBufferUnreadMsg points to the first byte of the next unread verified ANT message
   1186              - System flags are updated
   1187          */

   \                                 In section .text, align 2, keep-with-next
   1188          static u8 AntProcessMessage(void)
   1189          {
   \                     AntProcessMessage: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   1190            u8 u8MessageLength;
   1191            u8 u8Channel;
   1192            u8 au8MessageCopy[MESG_MAX_SIZE];
   1193            AntExtendedDataType sExtendedData;
   1194            
   1195             /* Exit immediately if there are no messages in the RxBuffer */
   1196          	if (!Ant_u8AntNewRxMessages)
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \        0x8   0x7808             LDRB     R0,[R1, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD101             BNE.N    ??AntProcessMessage_0
   1197              return(1);
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xE1B6             B.N      ??AntProcessMessage_1
   1198            
   1199            Ant_DebugProcessRxMessages++;
   \                     ??AntProcessMessage_0: (+1)
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable21_30
   \       0x16   0x6802             LDR      R2,[R0, #+0]
   \       0x18   0x1C52             ADDS     R2,R2,#+1
   \       0x1A   0x6002             STR      R2,[R0, #+0]
   1200            
   1201            /* Otherwise decrement counter, and get a copy of the message (necessary since the rx buffer is circular)
   1202            and we want to index the various bytes using the ANT byte definitions. */  
   1203            Ant_u8AntNewRxMessages--;
   \       0x1C   0x7808             LDRB     R0,[R1, #+0]
   \       0x1E   0x1E40             SUBS     R0,R0,#+1
   \       0x20   0x7008             STRB     R0,[R1, #+0]
   1204            AdvanceAntRxBufferUnreadMsgPointer();
   \       0x22   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   1205            u8MessageLength = *Ant_pu8AntRxBufferUnreadMsg;
   \       0x26   0x.... 0x....      LDR.W    R5,??DataTable15_1
   \       0x2A   0x6828             LDR      R0,[R5, #+0]
   \       0x2C   0x7804             LDRB     R4,[R0, #+0]
   1206            
   1207            /* Check to ensure the message size is legit.  !!!!! Clean up pointers if not */
   1208            if(u8MessageLength > MESG_MAX_SIZE)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x32   0x2812             CMP      R0,#+18
   \       0x34   0xDB01             BLT.N    ??AntProcessMessage_2
   1209            {
   1210              return(1);
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0xE1A2             B.N      ??AntProcessMessage_1
   1211            }
   1212            
   1213            /* Copy the message so it can be indexed easily */ 
   1214            for(u8 i = 0; i < (u8MessageLength + MESG_FRAME_SIZE - MESG_SYNC_SIZE); i++)
   \                     ??AntProcessMessage_2: (+1)
   \       0x3A   0x2600             MOVS     R6,#+0
   \                     ??AntProcessMessage_3: (+1)
   \       0x3C   0x0030             MOVS     R0,R6
   \       0x3E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x40   0x0021             MOVS     R1,R4
   \       0x42   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x44   0x1CC9             ADDS     R1,R1,#+3
   \       0x46   0x4288             CMP      R0,R1
   \       0x48   0xDA09             BGE.N    ??AntProcessMessage_4
   1215            {
   1216              au8MessageCopy[i] = *Ant_pu8AntRxBufferUnreadMsg;
   \       0x4A   0x6828             LDR      R0,[R5, #+0]
   \       0x4C   0x7800             LDRB     R0,[R0, #+0]
   \       0x4E   0x4669             MOV      R1,SP
   \       0x50   0x0032             MOVS     R2,R6
   \       0x52   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x54   0x5488             STRB     R0,[R1, R2]
   1217              AdvanceAntRxBufferUnreadMsgPointer();
   \       0x56   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   1218            }
   \       0x5A   0x1C76             ADDS     R6,R6,#+1
   \       0x5C   0xE7EE             B.N      ??AntProcessMessage_3
   1219            /* Note: Ant_pu8AntRxBufferUnreadMsg is now pointing at the next unread message */
   1220            
   1221            /* Get the channel number since it is needed for many things below (this value
   1222            will NOT be the channel for messages that do not include the channel number,
   1223            but that should be fine as long as the value is used in the correct context. */
   1224            u8Channel = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM];
   \                     ??AntProcessMessage_4: (+1)
   \       0x5E   0x466E             MOV      R6,SP
   \       0x60   0x78B5             LDRB     R5,[R6, #+2]
   1225            
   1226            /* Decide what to do based on the Message ID */
   1227            switch( au8MessageCopy[BUFFER_INDEX_MESG_ID] )
   \       0x62   0x7870             LDRB     R0,[R6, #+1]
   \       0x64   0x283E             CMP      R0,#+62
   \       0x66   0xF000 0x8169      BEQ.W    ??AntProcessMessage_5
   \       0x6A   0x2840             CMP      R0,#+64
   \       0x6C   0xD00C             BEQ.N    ??AntProcessMessage_6
   \       0x6E   0x284E             CMP      R0,#+78
   \       0x70   0xF000 0x814B      BEQ.W    ??AntProcessMessage_7
   \       0x74   0x284F             CMP      R0,#+79
   \       0x76   0xF000 0x8148      BEQ.W    ??AntProcessMessage_7
   \       0x7A   0x2852             CMP      R0,#+82
   \       0x7C   0xF000 0x815D      BEQ.W    ??AntProcessMessage_8
   \       0x80   0x286F             CMP      R0,#+111
   \       0x82   0xF000 0x8171      BEQ.W    ??AntProcessMessage_9
   \       0x86   0xE175             B.N      ??AntProcessMessage_10
   1228            {
   1229              case MESG_RESPONSE_EVENT_ID:
   1230              { 
   1231                /* Channel Message received: it is a Channel Response or Channel Event */
   1232                if( au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID] != MESG_EVENT_ID )
   \                     ??AntProcessMessage_6: (+1)
   \       0x88   0x78F0             LDRB     R0,[R6, #+3]
   \       0x8A   0x2801             CMP      R0,#+1
   \       0x8C   0xF000 0x80BC      BEQ.W    ??AntProcessMessage_11
   1233                {
   1234                  /* We have a Channel Response: parse it out based on the message ID to which the 
   1235                  response applies and post the result */
   1236                  G_stMessageResponse.u8Channel = u8Channel;
   \       0x90   0x.... 0x....      LDR.W    R0,??DataTable21_31
   \       0x94   0x7005             STRB     R5,[R0, #+0]
   1237                  G_stMessageResponse.u8MessageNumber = au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID];
   \       0x96   0x78F1             LDRB     R1,[R6, #+3]
   \       0x98   0x7041             STRB     R1,[R0, #+1]
   1238                  G_stMessageResponse.u8ResponseCode  = au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE];      
   \       0x9A   0x7931             LDRB     R1,[R6, #+4]
   \       0x9C   0x7081             STRB     R1,[R0, #+2]
   1239                  
   1240                  switch(au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID])
   \       0x9E   0x78F0             LDRB     R0,[R6, #+3]
   \       0xA0   0x2841             CMP      R0,#+65
   \       0xA2   0xD055             BEQ.N    ??AntProcessMessage_12
   \       0xA4   0x2842             CMP      R0,#+66
   \       0xA6   0xD04B             BEQ.N    ??AntProcessMessage_13
   \       0xA8   0x284B             CMP      R0,#+75
   \       0xAA   0xD007             BEQ.N    ??AntProcessMessage_14
   \       0xAC   0x284C             CMP      R0,#+76
   \       0xAE   0xD02C             BEQ.N    ??AntProcessMessage_15
   \       0xB0   0x285B             CMP      R0,#+91
   \       0xB2   0xD174             BNE.N    ??AntProcessMessage_16
   1241                  {
   1242                    case MESG_OPEN_SCAN_CHANNEL_ID:
   1243                      DebugPrintf("Scanning ");
   \                     ??AntProcessMessage_17: (+1)
   \       0xB4   0x.... 0x....      LDR.W    R0,??DataTable21_32
   \       0xB8   0x.... 0x....      BL       DebugPrintf
   1244                      /* Fall through */
   1245                      
   1246                    case MESG_OPEN_CHANNEL_ID:
   1247                      G_au8AntMessageOpen[12] = u8Channel + 0x30;
   \                     ??AntProcessMessage_14: (+1)
   \       0xBC   0x.... 0x....      LDR.W    R0,??DataTable21_33
   \       0xC0   0xF115 0x0130      ADDS     R1,R5,#+48
   \       0xC4   0x7301             STRB     R1,[R0, #+12]
   1248                      DebugPrintf(G_au8AntMessageOpen);
   \       0xC6   0x.... 0x....      BL       DebugPrintf
   1249                      
   1250                      /* Only change the flags if the command was successful */
   1251                      if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR )
   \       0xCA   0x7930             LDRB     R0,[R6, #+4]
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD11B             BNE.N    ??AntProcessMessage_18
   1252                      {
   1253                        G_asAntChannelConfiguration[u8Channel].AntFlags |= _ANT_FLAGS_CHANNEL_OPEN;
   \       0xD0   0x2014             MOVS     R0,#+20
   \       0xD2   0x.... 0x....      LDR.W    R1,??DataTable21_3
   \       0xD6   0x002A             MOVS     R2,R5
   \       0xD8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xDA   0x4342             MULS     R2,R0,R2
   \       0xDC   0x440A             ADD      R2,R1,R2
   \       0xDE   0x002B             MOVS     R3,R5
   \       0xE0   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0xE2   0x4343             MULS     R3,R0,R3
   \       0xE4   0x440B             ADD      R3,R1,R3
   \       0xE6   0x7CDB             LDRB     R3,[R3, #+19]
   \       0xE8   0xF053 0x0304      ORRS     R3,R3,#0x4
   \       0xEC   0x74D3             STRB     R3,[R2, #+19]
   1254                        G_asAntChannelConfiguration[u8Channel].AntFlags &= ~_ANT_FLAGS_CHANNEL_OPEN_PENDING;
   \       0xEE   0x002A             MOVS     R2,R5
   \       0xF0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xF2   0x4342             MULS     R2,R0,R2
   \       0xF4   0x440A             ADD      R2,R1,R2
   \       0xF6   0x002B             MOVS     R3,R5
   \       0xF8   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0xFA   0xFB00 0xF003      MUL      R0,R0,R3
   \       0xFE   0x4408             ADD      R0,R1,R0
   \      0x100   0x7CC0             LDRB     R0,[R0, #+19]
   \      0x102   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \      0x106   0x74D0             STRB     R0,[R2, #+19]
   1255                      }
   1256                      break;
   \                     ??AntProcessMessage_18: (+1)
   \      0x108   0xE06B             B.N      ??AntProcessMessage_19
   1257          
   1258                    case MESG_CLOSE_CHANNEL_ID:
   1259                      G_au8AntMessageClose[12] = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM] + 0x30;
   \                     ??AntProcessMessage_15: (+1)
   \      0x10A   0x.... 0x....      LDR.W    R0,??DataTable21_34
   \      0x10E   0x78B1             LDRB     R1,[R6, #+2]
   \      0x110   0x3130             ADDS     R1,R1,#+48
   \      0x112   0x7301             STRB     R1,[R0, #+12]
   1260                      DebugPrintf(G_au8AntMessageClose);
   \      0x114   0x.... 0x....      BL       DebugPrintf
   1261          
   1262                      /* Only change the flags if the command was successful */
   1263                      if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR )
   \      0x118   0x7930             LDRB     R0,[R6, #+4]
   \      0x11A   0x2800             CMP      R0,#+0
   \      0x11C   0xD10F             BNE.N    ??AntProcessMessage_20
   1264                      {
   1265                        G_asAntChannelConfiguration[u8Channel].AntFlags &= ~(_ANT_FLAGS_CHANNEL_CLOSE_PENDING | _ANT_FLAGS_CHANNEL_OPEN);
   \      0x11E   0x2014             MOVS     R0,#+20
   \      0x120   0x.... 0x....      LDR.W    R1,??DataTable21_3
   \      0x124   0x002A             MOVS     R2,R5
   \      0x126   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x128   0x4342             MULS     R2,R0,R2
   \      0x12A   0x440A             ADD      R2,R1,R2
   \      0x12C   0x002B             MOVS     R3,R5
   \      0x12E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x130   0xFB00 0xF003      MUL      R0,R0,R3
   \      0x134   0x4408             ADD      R0,R1,R0
   \      0x136   0x7CC0             LDRB     R0,[R0, #+19]
   \      0x138   0xF010 0x00F3      ANDS     R0,R0,#0xF3
   \      0x13C   0x74D0             STRB     R0,[R2, #+19]
   1266                      }
   1267                      break;
   \                     ??AntProcessMessage_20: (+1)
   \      0x13E   0xE050             B.N      ??AntProcessMessage_19
   1268          
   1269                    case MESG_ASSIGN_CHANNEL_ID:
   1270                      G_au8AntMessageAssign[12] = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM] + 0x30;
   \                     ??AntProcessMessage_13: (+1)
   \      0x140   0x.... 0x....      LDR.W    R0,??DataTable21_35
   \      0x144   0x78B1             LDRB     R1,[R6, #+2]
   \      0x146   0x3130             ADDS     R1,R1,#+48
   \      0x148   0x7301             STRB     R1,[R0, #+12]
   1271                      DebugPrintf(G_au8AntMessageAssign);
   \      0x14A   0x.... 0x....      BL       DebugPrintf
   1272                      break;
   \      0x14E   0xE048             B.N      ??AntProcessMessage_19
   1273          
   1274                    case MESG_UNASSIGN_CHANNEL_ID:
   1275                      G_au8AntMessageUnassign[12] = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM] + 0x30;
   \                     ??AntProcessMessage_12: (+1)
   \      0x150   0x.... 0x....      LDR.W    R0,??DataTable21_36
   \      0x154   0x78B1             LDRB     R1,[R6, #+2]
   \      0x156   0x3130             ADDS     R1,R1,#+48
   \      0x158   0x7301             STRB     R1,[R0, #+12]
   1276                      DebugPrintf(G_au8AntMessageUnassign);
   \      0x15A   0x.... 0x....      BL       DebugPrintf
   1277          
   1278                      /* Only change the flags if the command was successful */
   1279                      if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR )
   \      0x15E   0x7930             LDRB     R0,[R6, #+4]
   \      0x160   0x2800             CMP      R0,#+0
   \      0x162   0xD11B             BNE.N    ??AntProcessMessage_21
   1280                      {
   1281          /* 2017-11-13 Clearing _ANT_FLAGS_CHANNEL_CLOSE_PENDING here is wrong.  It should be
   1282                        set when the CLOSE_CHANNEL message has been confirmed.
   1283                        G_asAntChannelConfiguration[u8Channel].AntFlags &= ~(_ANT_FLAGS_CHANNEL_CLOSE_PENDING | _ANT_FLAGS_CHANNEL_OPEN);
   1284          */
   1285                        G_asAntChannelConfiguration[u8Channel].AntFlags |= _ANT_FLAGS_CHANNEL_CLOSE_PENDING;
   \      0x164   0x2014             MOVS     R0,#+20
   \      0x166   0x.... 0x....      LDR.W    R1,??DataTable21_3
   \      0x16A   0x002A             MOVS     R2,R5
   \      0x16C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x16E   0x4342             MULS     R2,R0,R2
   \      0x170   0x440A             ADD      R2,R1,R2
   \      0x172   0x002B             MOVS     R3,R5
   \      0x174   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x176   0x4343             MULS     R3,R0,R3
   \      0x178   0x440B             ADD      R3,R1,R3
   \      0x17A   0x7CDB             LDRB     R3,[R3, #+19]
   \      0x17C   0xF053 0x0308      ORRS     R3,R3,#0x8
   \      0x180   0x74D3             STRB     R3,[R2, #+19]
   1286                        G_asAntChannelConfiguration[u8Channel].AntFlags &= ~_ANT_FLAGS_CHANNEL_OPEN;
   \      0x182   0x002A             MOVS     R2,R5
   \      0x184   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x186   0x4342             MULS     R2,R0,R2
   \      0x188   0x440A             ADD      R2,R1,R2
   \      0x18A   0x002B             MOVS     R3,R5
   \      0x18C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x18E   0xFB00 0xF003      MUL      R0,R0,R3
   \      0x192   0x4408             ADD      R0,R1,R0
   \      0x194   0x7CC0             LDRB     R0,[R0, #+19]
   \      0x196   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \      0x19A   0x74D0             STRB     R0,[R2, #+19]
   1287                      }
   1288                      break;
   \                     ??AntProcessMessage_21: (+1)
   \      0x19C   0xE021             B.N      ??AntProcessMessage_19
   1289           
   1290                    default:
   1291                      G_au8AntMessageUnhandled[12] = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM] + 0x30;
   \                     ??AntProcessMessage_16: (+1)
   \      0x19E   0x.... 0x....      LDR.W    R7,??DataTable21_37
   \      0x1A2   0x78B0             LDRB     R0,[R6, #+2]
   \      0x1A4   0x3030             ADDS     R0,R0,#+48
   \      0x1A6   0x7338             STRB     R0,[R7, #+12]
   1292                      G_au8AntMessageUnhandled[24] = HexToASCIICharLower( (au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID] >> 4) & 0x0F );
   \      0x1A8   0x78F0             LDRB     R0,[R6, #+3]
   \      0x1AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x1AC   0x0900             LSRS     R0,R0,#+4
   \      0x1AE   0x.... 0x....      BL       HexToASCIICharLower
   \      0x1B2   0x7638             STRB     R0,[R7, #+24]
   1293                      G_au8AntMessageUnhandled[25] = HexToASCIICharLower( (au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID] & 0x0F) );
   \      0x1B4   0x78F0             LDRB     R0,[R6, #+3]
   \      0x1B6   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x1BA   0x.... 0x....      BL       HexToASCIICharLower
   \      0x1BE   0x7678             STRB     R0,[R7, #+25]
   1294                      G_au8AntMessageUnhandled[36] = HexToASCIICharLower( (au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] >> 4) & 0x0F );
   \      0x1C0   0x7930             LDRB     R0,[R6, #+4]
   \      0x1C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x1C4   0x0900             LSRS     R0,R0,#+4
   \      0x1C6   0x.... 0x....      BL       HexToASCIICharLower
   \      0x1CA   0xF887 0x0024      STRB     R0,[R7, #+36]
   1295                      G_au8AntMessageUnhandled[37] = HexToASCIICharLower( (au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] & 0x0F) );
   \      0x1CE   0x7930             LDRB     R0,[R6, #+4]
   \      0x1D0   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x1D4   0x.... 0x....      BL       HexToASCIICharLower
   \      0x1D8   0xF887 0x0025      STRB     R0,[R7, #+37]
   1296                      DebugPrintf(G_au8AntMessageUnhandled);
   \      0x1DC   0x0038             MOVS     R0,R7
   \      0x1DE   0x.... 0x....      BL       DebugPrintf
   1297                      break;
   1298                  } /* end switch */
   1299                  
   1300                  /* All messages print an "ok" or "fail" */
   1301                  if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR ) 
   \                     ??AntProcessMessage_19: (+1)
   \      0x1E2   0x7930             LDRB     R0,[R6, #+4]
   \      0x1E4   0x2800             CMP      R0,#+0
   \      0x1E6   0xD104             BNE.N    ??AntProcessMessage_22
   1302                  {
   1303                    DebugPrintf(G_au8AntMessageOk);
   \      0x1E8   0x.... 0x....      LDR.W    R0,??DataTable21_8
   \      0x1EC   0x.... 0x....      BL       DebugPrintf
   \      0x1F0   0xE08A             B.N      ??AntProcessMessage_23
   1304                  }
   1305                  else
   1306                  {
   1307                    DebugPrintf(G_au8AntMessageFail);
   \                     ??AntProcessMessage_22: (+1)
   \      0x1F2   0x.... 0x....      LDR.W    R0,??DataTable21_38
   \      0x1F6   0x.... 0x....      BL       DebugPrintf
   1308                    G_u32AntFlags |= _ANT_FLAGS_CMD_ERROR;
   \      0x1FA   0x.... 0x....      LDR.W    R0,??DataTable21_25
   \      0x1FE   0x6801             LDR      R1,[R0, #+0]
   \      0x200   0xF051 0x0102      ORRS     R1,R1,#0x2
   \      0x204   0x6001             STR      R1,[R0, #+0]
   \      0x206   0xE07F             B.N      ??AntProcessMessage_23
   1309                  }
   1310          
   1311                }
   1312                else /* The message is a Channel Event, so the Event Code must be parsed out */
   1313                { 
   1314                  switch ( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] )
   \                     ??AntProcessMessage_11: (+1)
   \      0x208   0x7930             LDRB     R0,[R6, #+4]
   \      0x20A   0x2800             CMP      R0,#+0
   \      0x20C   0xD00E             BEQ.N    ??AntProcessMessage_24
   \      0x20E   0x2801             CMP      R0,#+1
   \      0x210   0xD054             BEQ.N    ??AntProcessMessage_25
   \      0x212   0x2802             CMP      R0,#+2
   \      0x214   0xD00E             BEQ.N    ??AntProcessMessage_26
   \      0x216   0x2803             CMP      R0,#+3
   \      0x218   0xD029             BEQ.N    ??AntProcessMessage_27
   \      0x21A   0x2805             CMP      R0,#+5
   \      0x21C   0xD036             BEQ.N    ??AntProcessMessage_28
   \      0x21E   0x2806             CMP      R0,#+6
   \      0x220   0xD048             BEQ.N    ??AntProcessMessage_29
   \      0x222   0x2807             CMP      R0,#+7
   \      0x224   0xD04E             BEQ.N    ??AntProcessMessage_30
   \      0x226   0x2808             CMP      R0,#+8
   \      0x228   0xD01D             BEQ.N    ??AntProcessMessage_31
   \      0x22A   0xE060             B.N      ??AntProcessMessage_32
   1315                  {
   1316                    case RESPONSE_NO_ERROR: 
   1317                    {
   1318                      AntTickExtended(RESPONSE_NO_ERROR);
   \                     ??AntProcessMessage_24: (+1)
   \      0x22C   0x2000             MOVS     R0,#+0
   \      0x22E   0x.... 0x....      BL       AntTickExtended
   1319                      break;
   \      0x232   0xE069             B.N      ??AntProcessMessage_23
   1320                    }
   1321          
   1322                    case EVENT_RX_FAIL: /* slave did not receive a message when expected */
   1323                    {
   1324                      /* The slave missed a message it was expecting: communicate this to the
   1325                      application in case it matters. Could also queue a debug message here. */
   1326                      if(++Ant_u8SlaveMissedMessageLow == 0)
   \                     ??AntProcessMessage_26: (+1)
   \      0x234   0x.... 0x....      LDR.W    R0,??DataTable21_39
   \      0x238   0x7801             LDRB     R1,[R0, #+0]
   \      0x23A   0x1C49             ADDS     R1,R1,#+1
   \      0x23C   0x7001             STRB     R1,[R0, #+0]
   \      0x23E   0x7800             LDRB     R0,[R0, #+0]
   \      0x240   0x2800             CMP      R0,#+0
   \      0x242   0xD10C             BNE.N    ??AntProcessMessage_33
   1327                      {
   1328                        if(++Ant_u8SlaveMissedMessageMid == 0)
   \      0x244   0x.... 0x....      LDR.W    R0,??DataTable21_40
   \      0x248   0x7801             LDRB     R1,[R0, #+0]
   \      0x24A   0x1C49             ADDS     R1,R1,#+1
   \      0x24C   0x7001             STRB     R1,[R0, #+0]
   \      0x24E   0x7800             LDRB     R0,[R0, #+0]
   \      0x250   0x2800             CMP      R0,#+0
   \      0x252   0xD104             BNE.N    ??AntProcessMessage_33
   1329                        {
   1330                          ++Ant_u8SlaveMissedMessageHigh;
   \      0x254   0x.... 0x....      LDR.W    R0,??DataTable21_41
   \      0x258   0x7801             LDRB     R1,[R0, #+0]
   \      0x25A   0x1C49             ADDS     R1,R1,#+1
   \      0x25C   0x7001             STRB     R1,[R0, #+0]
   1331                        }
   1332                      }
   1333                      
   1334                      /* Queue an ANT_TICK message to the application message list. */
   1335                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_33: (+1)
   \      0x25E   0x4668             MOV      R0,SP
   \      0x260   0x.... 0x....      BL       AntTickExtended
   1336                      break;
   \      0x264   0xE050             B.N      ??AntProcessMessage_23
   1337                    }
   1338          
   1339                    case EVENT_RX_FAIL_GO_TO_SEARCH: /* slave has lost sync with Master (channel still open) */
   1340                    {
   1341                      /* The slave missed enough consecutive messages so it goes back to search: communicate this to the
   1342                      application in case it matters. Could also queue a debug message here. */
   1343                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_31: (+1)
   \      0x266   0x4668             MOV      R0,SP
   \      0x268   0x.... 0x....      BL       AntTickExtended
   1344                      break;
   \      0x26C   0xE04C             B.N      ??AntProcessMessage_23
   1345                    }
   1346          
   1347                    case EVENT_TX: /* ANT has sent a data message */
   1348                    {
   1349                      /* If this is a master device, then EVENT_TX means it's time to queue the 
   1350                      next message */
   1351                      if(G_asAntChannelConfiguration[u8Channel].AntChannelType == CHANNEL_TYPE_MASTER)
   \                     ??AntProcessMessage_27: (+1)
   \      0x26E   0x.... 0x....      LDR.W    R1,??DataTable21_3
   \      0x272   0x002A             MOVS     R2,R5
   \      0x274   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x276   0x2014             MOVS     R0,#+20
   \      0x278   0x4342             MULS     R2,R0,R2
   \      0x27A   0xEB01 0x0002      ADD      R0,R1,R2
   \      0x27E   0x7840             LDRB     R0,[R0, #+1]
   \      0x280   0x2810             CMP      R0,#+16
   \      0x282   0xD102             BNE.N    ??AntProcessMessage_34
   1352                      {
   1353                        AntTickExtended(au8MessageCopy);
   \      0x284   0x4668             MOV      R0,SP
   \      0x286   0x.... 0x....      BL       AntTickExtended
   1354                      }
   1355                      break;
   \                     ??AntProcessMessage_34: (+1)
   \      0x28A   0xE03D             B.N      ??AntProcessMessage_23
   1356                    } 
   1357          
   1358                    case EVENT_TRANSFER_TX_COMPLETED: /* ACK received from an acknowledged data message */
   1359                    { 
   1360                      G_asAntChannelConfiguration[u8Channel].AntFlags |= _ANT_FLAGS_GOT_ACK;
   \                     ??AntProcessMessage_28: (+1)
   \      0x28C   0x2014             MOVS     R0,#+20
   \      0x28E   0x.... 0x....      LDR.W    R1,??DataTable21_3
   \      0x292   0x002A             MOVS     R2,R5
   \      0x294   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x296   0x4342             MULS     R2,R0,R2
   \      0x298   0x440A             ADD      R2,R1,R2
   \      0x29A   0x002B             MOVS     R3,R5
   \      0x29C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x29E   0xFB00 0xF003      MUL      R0,R0,R3
   \      0x2A2   0x4408             ADD      R0,R1,R0
   \      0x2A4   0x7CC0             LDRB     R0,[R0, #+19]
   \      0x2A6   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x2AA   0x74D0             STRB     R0,[R2, #+19]
   1361          
   1362                      AntTickExtended(au8MessageCopy);
   \      0x2AC   0x4668             MOV      R0,SP
   \      0x2AE   0x.... 0x....      BL       AntTickExtended
   1363                      break;
   \      0x2B2   0xE029             B.N      ??AntProcessMessage_23
   1364                    } 
   1365          
   1366                    case EVENT_TRANSFER_TX_FAILED: /* ACK was not received from an acknowledged data message */
   1367                    { 
   1368                      /* Regardless of complete or fail, it is time to send the next message */
   1369                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_29: (+1)
   \      0x2B4   0x4668             MOV      R0,SP
   \      0x2B6   0x.... 0x....      BL       AntTickExtended
   1370                      break;
   \      0x2BA   0xE025             B.N      ??AntProcessMessage_23
   1371                    } 
   1372          
   1373                    case EVENT_RX_SEARCH_TIMEOUT: /* The ANT channel is going to close due to search timeout */
   1374                    {
   1375                      /* Forward this to application */
   1376                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_25: (+1)
   \      0x2BC   0x4668             MOV      R0,SP
   \      0x2BE   0x.... 0x....      BL       AntTickExtended
   1377                      break;
   \      0x2C2   0xE021             B.N      ??AntProcessMessage_23
   1378                    }
   1379           
   1380                    case EVENT_CHANNEL_CLOSED: /* The ANT channel is now closed */
   1381                    {
   1382                      DebugPrintf("Channel closed\n\r");
   \                     ??AntProcessMessage_30: (+1)
   \      0x2C4   0x.... 0x....      LDR.W    R0,??DataTable21_42
   \      0x2C8   0x.... 0x....      BL       DebugPrintf
   1383                      G_asAntChannelConfiguration[u8Channel].AntFlags &= ~(_ANT_FLAGS_CHANNEL_CLOSE_PENDING | _ANT_FLAGS_CHANNEL_OPEN);
   \      0x2CC   0x2014             MOVS     R0,#+20
   \      0x2CE   0x.... 0x....      LDR.W    R1,??DataTable21_3
   \      0x2D2   0x002A             MOVS     R2,R5
   \      0x2D4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x2D6   0x4342             MULS     R2,R0,R2
   \      0x2D8   0x440A             ADD      R2,R1,R2
   \      0x2DA   0x002B             MOVS     R3,R5
   \      0x2DC   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x2DE   0xFB00 0xF003      MUL      R0,R0,R3
   \      0x2E2   0x4408             ADD      R0,R1,R0
   \      0x2E4   0x7CC0             LDRB     R0,[R0, #+19]
   \      0x2E6   0xF010 0x00F3      ANDS     R0,R0,#0xF3
   \      0x2EA   0x74D0             STRB     R0,[R2, #+19]
   1384                      break;
   \      0x2EC   0xE00C             B.N      ??AntProcessMessage_23
   1385                    }
   1386                    
   1387                    /* All other messages are unexpected for now */
   1388                    default:
   1389                      DebugPrintNumber(au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE]);
   \                     ??AntProcessMessage_32: (+1)
   \      0x2EE   0x7930             LDRB     R0,[R6, #+4]
   \      0x2F0   0x.... 0x....      BL       DebugPrintNumber
   1390                      DebugPrintf(": unexpected channel event\n\r");
   \      0x2F4   0x.... 0x....      LDR.W    R0,??DataTable21_43
   \      0x2F8   0x.... 0x....      BL       DebugPrintf
   1391          
   1392                      G_u32AntFlags |= _ANT_FLAGS_UNEXPECTED_EVENT;
   \      0x2FC   0x.... 0x....      LDR.W    R0,??DataTable21_25
   \      0x300   0x6801             LDR      R1,[R0, #+0]
   \      0x302   0xF051 0x0104      ORRS     R1,R1,#0x4
   \      0x306   0x6001             STR      R1,[R0, #+0]
   1393                      break;
   1394                  } /* end Ant_pu8AntRxBufferUnreadMsg[EVENT_CODE_INDEX] */
   1395                } /* end else RF event */
   1396                
   1397                break; 
   \                     ??AntProcessMessage_23: (+1)
   \      0x308   0xE039             B.N      ??AntProcessMessage_35
   1398              } /* end case MESG_RESPONSE_EVENT_ID */
   1399          
   1400              case MESG_ACKNOWLEDGED_DATA_ID: /* An acknowledged data message was received */
   1401              /* Fall through */
   1402                
   1403              case MESG_BROADCAST_DATA_ID: /* A broadcast data message was received */
   1404              { 
   1405                /* Parse the extended data and put the message to the application buffer */
   1406                AntParseExtendedData(au8MessageCopy, &sExtendedData);
   \                     ??AntProcessMessage_7: (+1)
   \      0x30A   0xA905             ADD      R1,SP,#+20
   \      0x30C   0x4668             MOV      R0,SP
   \      0x30E   0x.... 0x....      BL       AntParseExtendedData
   1407                AntQueueExtendedApplicationMessage(ANT_DATA, &au8MessageCopy[BUFFER_INDEX_MESG_DATA], &sExtendedData);
   \      0x312   0xAA05             ADD      R2,SP,#+20
   \      0x314   0xF10D 0x0103      ADD      R1,SP,#+3
   \      0x318   0x2001             MOVS     R0,#+1
   \      0x31A   0x.... 0x....      BL       AntQueueExtendedApplicationMessage
   1408                
   1409                /* If this is a slave device, then a data message received means it's time to send */
   1410                if(G_asAntChannelConfiguration[u8Channel].AntChannelType == CHANNEL_TYPE_SLAVE)
   \      0x31E   0x....             LDR.N    R1,??DataTable21_3
   \      0x320   0x002A             MOVS     R2,R5
   \      0x322   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x324   0x2014             MOVS     R0,#+20
   \      0x326   0x4342             MULS     R2,R0,R2
   \      0x328   0xEB01 0x0002      ADD      R0,R1,R2
   \      0x32C   0x7840             LDRB     R0,[R0, #+1]
   \      0x32E   0x2800             CMP      R0,#+0
   \      0x330   0xD102             BNE.N    ??AntProcessMessage_36
   1411                {
   1412                  AntTickExtended(RESPONSE_NO_ERROR);
   \      0x332   0x2000             MOVS     R0,#+0
   \      0x334   0x.... 0x....      BL       AntTickExtended
   1413                }
   1414                
   1415                break;
   \                     ??AntProcessMessage_36: (+1)
   \      0x338   0xE021             B.N      ??AntProcessMessage_35
   1416              } /* end case MESG_BROADCAST_DATA_ID */
   1417              
   1418              case MESG_CHANNEL_STATUS_ID: /* Message sent in response to a channel status request */
   1419              { 
   1420                break;
   \                     ??AntProcessMessage_8: (+1)
   \      0x33A   0xE020             B.N      ??AntProcessMessage_35
   1421              } /* end case ChannelStatus_CMD */
   1422              
   1423              case MESG_VERSION_ID:
   1424              {
   1425                for(u8 i = 0; i < MESG_VERSION_SIZE; i++)
   \                     ??AntProcessMessage_5: (+1)
   \      0x33C   0x2000             MOVS     R0,#+0
   \                     ??AntProcessMessage_37: (+1)
   \      0x33E   0x0001             MOVS     R1,R0
   \      0x340   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x342   0x290A             CMP      R1,#+10
   \      0x344   0xDA0A             BGE.N    ??AntProcessMessage_38
   1426                {
   1427                  Ant_u8AntVersion[i] = au8MessageCopy[BUFFER_INDEX_VERSION_BYTE0 + i];
   \      0x346   0x4669             MOV      R1,SP
   \      0x348   0x0002             MOVS     R2,R0
   \      0x34A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x34C   0x4411             ADD      R1,R1,R2
   \      0x34E   0x7889             LDRB     R1,[R1, #+2]
   \      0x350   0x....             LDR.N    R2,??DataTable21_10
   \      0x352   0x0003             MOVS     R3,R0
   \      0x354   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x356   0x54D1             STRB     R1,[R2, R3]
   1428                }
   \      0x358   0x1C40             ADDS     R0,R0,#+1
   \      0x35A   0xE7F0             B.N      ??AntProcessMessage_37
   1429                
   1430                /* If we get a version message, we know that ANT comms is good */
   1431                G_u32ApplicationFlags |= _APPLICATION_FLAGS_ANT;
   \                     ??AntProcessMessage_38: (+1)
   \      0x35C   0x....             LDR.N    R0,??DataTable21_7
   \      0x35E   0x6801             LDR      R1,[R0, #+0]
   \      0x360   0xF051 0x0110      ORRS     R1,R1,#0x10
   \      0x364   0x6001             STR      R1,[R0, #+0]
   1432                
   1433                break;
   \      0x366   0xE00A             B.N      ??AntProcessMessage_35
   1434              } /* end case MESG_VERSION_ID */
   1435          
   1436              case MESG_RESTART_ID:
   1437              {
   1438                G_u32AntFlags |= _ANT_FLAGS_RESTART;  
   \                     ??AntProcessMessage_9: (+1)
   \      0x368   0x....             LDR.N    R0,??DataTable21_25
   \      0x36A   0x6801             LDR      R1,[R0, #+0]
   \      0x36C   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \      0x370   0x6001             STR      R1,[R0, #+0]
   1439                break;
   \      0x372   0xE004             B.N      ??AntProcessMessage_35
   1440              } /* end case MESG_RESTART_ID */
   1441              
   1442              default:
   1443                G_u32AntFlags |= _ANT_FLAGS_UNEXPECTED_MSG;
   \                     ??AntProcessMessage_10: (+1)
   \      0x374   0x....             LDR.N    R0,??DataTable21_25
   \      0x376   0x6801             LDR      R1,[R0, #+0]
   \      0x378   0xF051 0x0108      ORRS     R1,R1,#0x8
   \      0x37C   0x6001             STR      R1,[R0, #+0]
   1444                break;
   1445            } /* end switch( Ant_pu8AntRxBufferUnreadMsg[MESG_ID_OFFSET] ) */
   1446                     
   1447            return(0);
   \                     ??AntProcessMessage_35: (+1)
   \      0x37E   0x2000             MOVS     R0,#+0
   \                     ??AntProcessMessage_1: (+1)
   \      0x380   0xB007             ADD      SP,SP,#+28
   \      0x382   0xBDF0             POP      {R4-R7,PC}       ;; return
   1448            
   1449          } /* end AntProcessMessage() */
   1450          
   1451          
   1452          /*-----------------------------------------------------------------------------/
   1453          Function: AntTickExtended
   1454          
   1455          Description:
   1456          Queues an ANT_TICK message to the application message queue.
   1457          
   1458          Requires:
   1459            - u8Code_ is payload byte indicating system info that may be relavent to the application
   1460          
   1461          Promises:
   1462            - A MESSAGE_ANT_TICK is queued to G_sAntApplicationMsgList
   1463          */

   \                                 In section .text, align 2, keep-with-next
   1464          static void AntTickExtended(u8* pu8AntMessage_)
   1465          {
   \                     AntTickExtended: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1466            u8 au8Message[ANT_APPLICATION_MESSAGE_BYTES];
   1467            AntExtendedDataType sExtData;
   1468          
   1469            /* Update data to communicate the ANT_TICK to the application */
   1470            au8Message[ANT_TICK_MSG_ID_INDEX]               = MESSAGE_ANT_TICK;
   \        0x4   0x20FF             MOVS     R0,#+255
   \        0x6   0x0001             MOVS     R1,R0
   \        0x8   0xF88D 0x1008      STRB     R1,[SP, #+8]
   1471            au8Message[ANT_TICK_MSG_CHANNEL_INDEX]          = *(pu8AntMessage_ + BUFFER_INDEX_CHANNEL_NUM);
   \        0xC   0xA902             ADD      R1,SP,#+8
   \        0xE   0x78A2             LDRB     R2,[R4, #+2]
   \       0x10   0x704A             STRB     R2,[R1, #+1]
   1472            au8Message[ANT_TICK_MSG_RESPONSE_TYPE_INDEX]    = *(pu8AntMessage_ + BUFFER_INDEX_RESPONSE_MESG_ID);
   \       0x12   0x78E2             LDRB     R2,[R4, #+3]
   \       0x14   0x708A             STRB     R2,[R1, #+2]
   1473            au8Message[ANT_TICK_MSG_EVENT_CODE_INDEX]       = *(pu8AntMessage_ + BUFFER_INDEX_RESPONSE_CODE);
   \       0x16   0x7922             LDRB     R2,[R4, #+4]
   \       0x18   0x70CA             STRB     R2,[R1, #+3]
   1474            au8Message[ANT_TICK_MSG_SENTINEL3_INDEX]        = MESSAGE_ANT_TICK;
   \       0x1A   0x7108             STRB     R0,[R1, #+4]
   1475            au8Message[ANT_TICK_MSG_MISSED_HIGH_BYTE_INDEX] = Ant_u8SlaveMissedMessageHigh;
   \       0x1C   0x....             LDR.N    R2,??DataTable21_41
   \       0x1E   0x7812             LDRB     R2,[R2, #+0]
   \       0x20   0x714A             STRB     R2,[R1, #+5]
   1476            au8Message[ANT_TICK_MSG_MISSED_MID_BYTE_INDEX]  = Ant_u8SlaveMissedMessageMid;
   \       0x22   0x....             LDR.N    R2,??DataTable21_40
   \       0x24   0x7812             LDRB     R2,[R2, #+0]
   \       0x26   0x718A             STRB     R2,[R1, #+6]
   1477            au8Message[ANT_TICK_MSG_MISSED_LOW_BYTE_INDEX]  = Ant_u8SlaveMissedMessageLow;
   \       0x28   0x....             LDR.N    R2,??DataTable21_39
   \       0x2A   0x7812             LDRB     R2,[R2, #+0]
   \       0x2C   0xF88D 0x200F      STRB     R2,[SP, #+15]
   1478          
   1479            /* Extended data is not valid for an ANT_TICK message */
   1480            sExtData.u8Channel    = au8Message[ANT_TICK_MSG_CHANNEL_INDEX];
   \       0x30   0x7849             LDRB     R1,[R1, #+1]
   \       0x32   0xF88D 0x1000      STRB     R1,[SP, #+0]
   1481            sExtData.u16DeviceID  = 0xFF;
   \       0x36   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1482            sExtData.u8DeviceType = 0xFF;
   \       0x3A   0x0001             MOVS     R1,R0
   \       0x3C   0xF88D 0x1004      STRB     R1,[SP, #+4]
   1483            sExtData.u8TransType  = 0xFF;
   \       0x40   0x0001             MOVS     R1,R0
   \       0x42   0xF88D 0x1005      STRB     R1,[SP, #+5]
   1484            sExtData.s8RSSI       = 0xFF;
   \       0x46   0xF05F 0x31FF      MOVS     R1,#-1
   \       0x4A   0xF88D 0x1006      STRB     R1,[SP, #+6]
   1485            sExtData.u8Flags      = 0xFF;
   \       0x4E   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1486            
   1487            /* Data is ready so queue it in to the application buffer */
   1488            AntQueueExtendedApplicationMessage(ANT_TICK, 
   1489                                               &au8Message[ANT_TICK_MSG_ID_INDEX],
   1490                                               &sExtData);
   \       0x52   0x466A             MOV      R2,SP
   \       0x54   0xA902             ADD      R1,SP,#+8
   \       0x56   0x2002             MOVS     R0,#+2
   \       0x58   0x.... 0x....      BL       AntQueueExtendedApplicationMessage
   1491          
   1492          } /* end AntTickExtended() */
   \       0x5C   0xBD1F             POP      {R0-R4,PC}       ;; return
   1493          
   1494          
   1495          /*-----------------------------------------------------------------------------/
   1496          Function: AntQueueExtendedApplicationMessage
   1497          
   1498          Description:
   1499          Creates a new ANT data message structure and adds it to G_sAntApplicationMsgList.
   1500          The Application list used to communicate message information between the ANT driver and
   1501          the ANT_API simplified interface task.
   1502          
   1503          Requires:
   1504            - eMessageType_ specifies the type of message
   1505            - pu8DataSource_ is a pointer to the first element of an array of 8 data bytes
   1506            - psTargetList_ is a pointer to the list pointer that is being updated
   1507            - Enough space is available on the heap
   1508          
   1509          Promises:
   1510            - A new list item in the target linked list is created and inserted at the end
   1511              of the list.
   1512            - Returns TRUE if the entry is added successfully.
   1513            - Returns FALSE if the malloc fails or the list is full.
   1514          */

   \                                 In section .text, align 2, keep-with-next
   1515          static bool AntQueueExtendedApplicationMessage(AntApplicationMessageType eMessageType_, 
   1516                                                         u8* pu8DataSource_, 
   1517                                                         AntExtendedDataType* psExtData_)
   1518          {
   \                     AntQueueExtendedApplicationMessage: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB08B             SUB      SP,SP,#+44
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
   1519            AntApplicationMsgListType *psNewMessage;
   1520            AntApplicationMsgListType *psListParser;
   1521            u8 u8MessageCount = 0;
   \        0xC   0xF05F 0x0900      MOVS     R9,#+0
   1522            u8 au8AddMessageFailMsg[] = "\n\rNo space in AntQueueApplicationMessage\n\r";
   \       0x10   0x4668             MOV      R0,SP
   \       0x12   0x....             LDR.N    R1,??DataTable21_44
   \       0x14   0x222B             MOVS     R2,#+43
   \       0x16   0x.... 0x....      BL       __aeabi_memcpy
   1523            
   1524            /* Allocate space for the new message - always do maximum message size */
   1525            psNewMessage = malloc( sizeof(AntApplicationMsgListType) );
   \       0x1A   0x201C             MOVS     R0,#+28
   \       0x1C   0x.... 0x....      BL       malloc
   \       0x20   0x0004             MOVS     R4,R0
   1526            if (psNewMessage == NULL)
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD104             BNE.N    ??AntQueueExtendedApplicationMessage_0
   1527            {
   1528              DebugPrintf(au8AddMessageFailMsg);
   \       0x26   0x4668             MOV      R0,SP
   \       0x28   0x.... 0x....      BL       DebugPrintf
   1529              return(FALSE);
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xE045             B.N      ??AntQueueExtendedApplicationMessage_1
   1530            }
   1531            
   1532            /* Fill in all the fields of the newly allocated message structure */
   1533            for(u8 i = 0; i < ANT_APPLICATION_MESSAGE_BYTES; i++)
   \                     ??AntQueueExtendedApplicationMessage_0: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \                     ??AntQueueExtendedApplicationMessage_2: (+1)
   \       0x32   0x0001             MOVS     R1,R0
   \       0x34   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x36   0x2908             CMP      R1,#+8
   \       0x38   0xDA08             BGE.N    ??AntQueueExtendedApplicationMessage_3
   1534            {
   1535              psNewMessage->au8MessageData[i] = *(pu8DataSource_ + i);
   \       0x3A   0x0001             MOVS     R1,R0
   \       0x3C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x3E   0x5C71             LDRB     R1,[R6, R1]
   \       0x40   0x0002             MOVS     R2,R0
   \       0x42   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x44   0x4422             ADD      R2,R4,R2
   \       0x46   0x7191             STRB     R1,[R2, #+6]
   1536            }
   \       0x48   0x1C40             ADDS     R0,R0,#+1
   \       0x4A   0xE7F2             B.N      ??AntQueueExtendedApplicationMessage_2
   1537            
   1538            /* Copy basic items */
   1539            psNewMessage->u32TimeStamp  = G_u32SystemTime1ms;
   \                     ??AntQueueExtendedApplicationMessage_3: (+1)
   \       0x4C   0x....             LDR.N    R0,??DataTable21_45
   \       0x4E   0x6800             LDR      R0,[R0, #+0]
   \       0x50   0x6020             STR      R0,[R4, #+0]
   1540            psNewMessage->eMessageType  = eMessageType_;
   \       0x52   0x7125             STRB     R5,[R4, #+4]
   1541            
   1542            /* Copy all extended data fields */
   1543            psNewMessage->sExtendedData.u8Channel    = psExtData_->u8Channel;
   \       0x54   0x7838             LDRB     R0,[R7, #+0]
   \       0x56   0x73A0             STRB     R0,[R4, #+14]
   1544            psNewMessage->sExtendedData.u16DeviceID  = psExtData_->u16DeviceID;
   \       0x58   0x8878             LDRH     R0,[R7, #+2]
   \       0x5A   0x8220             STRH     R0,[R4, #+16]
   1545            psNewMessage->sExtendedData.u8DeviceType = psExtData_->u8DeviceType;
   \       0x5C   0x7938             LDRB     R0,[R7, #+4]
   \       0x5E   0x74A0             STRB     R0,[R4, #+18]
   1546            psNewMessage->sExtendedData.u8TransType  = psExtData_->u8TransType;
   \       0x60   0x7978             LDRB     R0,[R7, #+5]
   \       0x62   0x74E0             STRB     R0,[R4, #+19]
   1547            psNewMessage->sExtendedData.u8Flags      = psExtData_->u8Flags;
   \       0x64   0x7878             LDRB     R0,[R7, #+1]
   \       0x66   0x73E0             STRB     R0,[R4, #+15]
   1548            psNewMessage->sExtendedData.s8RSSI       = psExtData_->s8RSSI;
   \       0x68   0x79B8             LDRB     R0,[R7, #+6]
   \       0x6A   0x7520             STRB     R0,[R4, #+20]
   1549              
   1550            psNewMessage->psNextMessage = NULL;
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x61A0             STR      R0,[R4, #+24]
   1551          
   1552            /* Insert into an empty list */
   1553            if(G_sAntApplicationMsgList == NULL)
   \       0x70   0x....             LDR.N    R1,??DataTable21_1
   \       0x72   0x6808             LDR      R0,[R1, #+0]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD105             BNE.N    ??AntQueueExtendedApplicationMessage_4
   1554            {
   1555              G_sAntApplicationMsgList = psNewMessage;
   \       0x78   0x600C             STR      R4,[R1, #+0]
   1556              Ant_u32ApplicationMessageCount++;
   \       0x7A   0x....             LDR.N    R0,??DataTable21_29
   \       0x7C   0x6801             LDR      R1,[R0, #+0]
   \       0x7E   0x1C49             ADDS     R1,R1,#+1
   \       0x80   0x6001             STR      R1,[R0, #+0]
   \       0x82   0xE01A             B.N      ??AntQueueExtendedApplicationMessage_5
   1557            }
   1558          
   1559            /* Otherwise traverse the list to find the end where the new message will be inserted */
   1560            else
   1561            {
   1562              psListParser = G_sAntApplicationMsgList;
   \                     ??AntQueueExtendedApplicationMessage_4: (+1)
   \       0x84   0x6808             LDR      R0,[R1, #+0]
   \       0x86   0x4680             MOV      R8,R0
   1563              while(psListParser->psNextMessage != NULL) 
   \                     ??AntQueueExtendedApplicationMessage_6: (+1)
   \       0x88   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD004             BEQ.N    ??AntQueueExtendedApplicationMessage_7
   1564              {
   1565                psListParser = psListParser->psNextMessage;
   \       0x90   0xF8D8 0x8018      LDR      R8,[R8, #+24]
   1566                u8MessageCount++;
   \       0x94   0xF119 0x0901      ADDS     R9,R9,#+1
   \       0x98   0xE7F6             B.N      ??AntQueueExtendedApplicationMessage_6
   1567              }
   1568              
   1569              /* Check for full list */
   1570              if(u8MessageCount < ANT_APPLICATION_MESSAGE_BUFFER_SIZE)
   \                     ??AntQueueExtendedApplicationMessage_7: (+1)
   \       0x9A   0x4648             MOV      R0,R9
   \       0x9C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x9E   0x2820             CMP      R0,#+32
   \       0xA0   0xD206             BCS.N    ??AntQueueExtendedApplicationMessage_8
   1571              {
   1572                /* Insert the new message at the end of the list */
   1573                psListParser->psNextMessage = psNewMessage;
   \       0xA2   0xF8C8 0x4018      STR      R4,[R8, #+24]
   1574                Ant_u32ApplicationMessageCount++;
   \       0xA6   0x....             LDR.N    R0,??DataTable21_29
   \       0xA8   0x6801             LDR      R1,[R0, #+0]
   \       0xAA   0x1C49             ADDS     R1,R1,#+1
   \       0xAC   0x6001             STR      R1,[R0, #+0]
   \       0xAE   0xE004             B.N      ??AntQueueExtendedApplicationMessage_5
   1575              }
   1576              /* Handle a full list */
   1577              else
   1578              {
   1579                DebugPrintf(au8AddMessageFailMsg);
   \                     ??AntQueueExtendedApplicationMessage_8: (+1)
   \       0xB0   0x4668             MOV      R0,SP
   \       0xB2   0x.... 0x....      BL       DebugPrintf
   1580                return(FALSE);
   \       0xB6   0x2000             MOVS     R0,#+0
   \       0xB8   0xE000             B.N      ??AntQueueExtendedApplicationMessage_1
   1581              }
   1582            }
   1583              
   1584            return(TRUE);
   \                     ??AntQueueExtendedApplicationMessage_5: (+1)
   \       0xBA   0x2001             MOVS     R0,#+1
   \                     ??AntQueueExtendedApplicationMessage_1: (+1)
   \       0xBC   0xB00B             ADD      SP,SP,#+44
   \       0xBE   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1585              
   1586          } /* end AntQueueExtendedApplicationMessage() */
   1587          
   1588          
   1589          /*-----------------------------------------------------------------------------/
   1590          Function: AntDeQueueOutgoingMessage
   1591          
   1592          Description:
   1593          Removes the first entry of Ant_psDataOutgoingMsgList.
   1594          
   1595          Requires:
   1596            - 
   1597          
   1598          Promises:
   1599            - Ant_psDataOutgoingMsgList = Ant_psDataOutgoingMsgList->psNextMessage 
   1600            and the memory is freed
   1601          */

   \                                 In section .text, align 2, keep-with-next
   1602          static void AntDeQueueOutgoingMessage(void)
   1603          {
   \                     AntDeQueueOutgoingMessage: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1604            AntOutgoingMessageListType *psMessageToKill;
   1605            
   1606            if(Ant_psDataOutgoingMsgList != NULL)
   \        0x2   0x....             LDR.N    R1,??DataTable21_2
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD007             BEQ.N    ??AntDeQueueOutgoingMessage_0
   1607            {
   1608              psMessageToKill = Ant_psDataOutgoingMsgList;
   \        0xA   0x6808             LDR      R0,[R1, #+0]
   \        0xC   0x0004             MOVS     R4,R0
   1609              Ant_psDataOutgoingMsgList = Ant_psDataOutgoingMsgList->psNextMessage;
   \        0xE   0x6808             LDR      R0,[R1, #+0]
   \       0x10   0x6980             LDR      R0,[R0, #+24]
   \       0x12   0x6008             STR      R0,[R1, #+0]
   1610            
   1611              /* The doomed message is properly disconnected, so kill it */
   1612              free(psMessageToKill);
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x.... 0x....      BL       free
   1613            }
   1614            
   1615          } /* end AntDeQueueOutgoingMessage() */
   \                     ??AntDeQueueOutgoingMessage_0: (+1)
   \       0x1A   0xBD10             POP      {R4,PC}          ;; return
   1616          
   1617          
   1618          /***********************************************************************************************************************
   1619          ##### ANT State Machine Definition                                             
   1620          ***********************************************************************************************************************/
   1621          
   1622          /*------------------------------------------------------------------------------
   1623          Idle state that will process new messages if any are present, monitors ANT
   1624          for incoming messages, and sends broadcast messages that are waiting to be sent.
   1625          Incoming messages from ANT always get priority.  
   1626          */

   \                                 In section .text, align 4, keep-with-next
   1627          void AntSM_Idle(void)
   1628          {
   \                     AntSM_Idle: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   1629            u32 u32MsgBitMask = 0x01;
   \        0x2   0x2401             MOVS     R4,#+1
   1630            u8 u8MsgIndex = 0;
   \        0x4   0x2500             MOVS     R5,#+0
   1631            static u8 au8AntFlagAlert[] = "ANT flags:\n\r"; 
   1632            
   1633            /* Error messages: must match order of G_u32AntFlags Error / event flags */
   1634            static u8 au8AntFlagMessages[][20] = 
   1635            {/* "012345678901234567\n\r" */
   1636                "Length mismatch\n\r",
   1637                "Command error\n\r",
   1638                "Unexpected event\n\r",
   1639                "Unexpected message\n\r"
   1640            };
   1641            
   1642            /* Check flags */
   1643            if(G_u32AntFlags & ANT_ERROR_FLAGS_MASK)
   \        0x6   0x....             LDR.N    R6,??DataTable21_25
   \        0x8   0x6830             LDR      R0,[R6, #+0]
   \        0xA   0x0400             LSLS     R0,R0,#+16
   \        0xC   0xD01B             BEQ.N    ??AntSM_Idle_0
   1644            {
   1645              /* At least one flag is set, so print header and parse out */
   1646              DebugPrintf(au8AntFlagAlert);
   \        0xE   0x....             LDR.N    R0,??DataTable21_46
   \       0x10   0x.... 0x....      BL       DebugPrintf
   1647              for(u8 i = 0; i < ANT_ERROR_FLAGS_COUNT; i++)
   \       0x14   0x2700             MOVS     R7,#+0
   \                     ??AntSM_Idle_1: (+1)
   \       0x16   0x0038             MOVS     R0,R7
   \       0x18   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x1A   0x2804             CMP      R0,#+4
   \       0x1C   0xDA0F             BGE.N    ??AntSM_Idle_2
   1648              {
   1649                /* Check if current flag is set */
   1650                if(G_u32AntFlags & u32MsgBitMask)
   \       0x1E   0x6830             LDR      R0,[R6, #+0]
   \       0x20   0x4220             TST      R0,R4
   \       0x22   0xD008             BEQ.N    ??AntSM_Idle_3
   1651                {
   1652                  /* Print the error message */
   1653                  DebugPrintf(au8AntFlagMessages[u8MsgIndex]);
   \       0x24   0x....             LDR.N    R1,??DataTable21_47
   \       0x26   0x002A             MOVS     R2,R5
   \       0x28   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x2A   0x2014             MOVS     R0,#+20
   \       0x2C   0x4342             MULS     R2,R0,R2
   \       0x2E   0xEB01 0x0002      ADD      R0,R1,R2
   \       0x32   0x.... 0x....      BL       DebugPrintf
   1654                }
   1655                u32MsgBitMask <<= 1;
   \                     ??AntSM_Idle_3: (+1)
   \       0x36   0x0064             LSLS     R4,R4,#+1
   1656                u8MsgIndex++;
   \       0x38   0x1C6D             ADDS     R5,R5,#+1
   1657              }
   \       0x3A   0x1C7F             ADDS     R7,R7,#+1
   \       0x3C   0xE7EB             B.N      ??AntSM_Idle_1
   1658              
   1659              /* Clear all the error flags now that they have been reported */
   1660              G_u32AntFlags &= ~ANT_ERROR_FLAGS_MASK;
   \                     ??AntSM_Idle_2: (+1)
   \       0x3E   0x6830             LDR      R0,[R6, #+0]
   \       0x40   0x0C00             LSRS     R0,R0,#+16
   \       0x42   0x0400             LSLS     R0,R0,#+16
   \       0x44   0x6030             STR      R0,[R6, #+0]
   1661            }
   1662            
   1663            /* Process messages received from ANT */
   1664            AntProcessMessage();
   \                     ??AntSM_Idle_0: (+1)
   \       0x46   0x.... 0x....      BL       AntProcessMessage
   1665          
   1666            /* Handle messages coming in from ANT */
   1667            if( IS_SEN_ASSERTED() )
   \       0x4A   0x....             LDR.N    R0,??DataTable21_48
   \       0x4C   0x6800             LDR      R0,[R0, #+0]
   \       0x4E   0x07C0             LSLS     R0,R0,#+31
   \       0x50   0xD504             BPL.N    ??AntSM_Idle_4
   1668            {
   1669              Ant_pfnStateMachine = AntSM_ReceiveMessage;
   \       0x52   0x.... 0x....      ADR.W    R0,AntSM_ReceiveMessage
   \       0x56   0x....             LDR.N    R1,??DataTable21
   \       0x58   0x6008             STR      R0,[R1, #+0]
   \       0x5A   0xE015             B.N      ??AntSM_Idle_5
   1670            }
   1671            
   1672            /* Send a message if the system is ready and there is one to send */ 
   1673            else if( (Ant_u32CurrentTxMessageToken == 0 ) && 
   1674                     (Ant_psDataOutgoingMsgList != NULL) )
   \                     ??AntSM_Idle_4: (+1)
   \       0x5C   0x....             LDR.N    R0,??DataTable21_22
   \       0x5E   0x6800             LDR      R0,[R0, #+0]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD111             BNE.N    ??AntSM_Idle_5
   \       0x64   0x....             LDR.N    R1,??DataTable21_2
   \       0x66   0x6808             LDR      R0,[R1, #+0]
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD00D             BEQ.N    ??AntSM_Idle_5
   1675            {
   1676              /* Give the message to AntTx which will set Ant_u32CurrentTxMessageToken */
   1677              if(AntTxMessage(Ant_psDataOutgoingMsgList->au8MessageData))
   \       0x6C   0x6808             LDR      R0,[R1, #+0]
   \       0x6E   0x1D00             ADDS     R0,R0,#+4
   \       0x70   0x.... 0x....      BL       AntTxMessage
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD007             BEQ.N    ??AntSM_Idle_5
   1678              {
   1679                Ant_u32TxTimer = G_u32SystemTime1ms;
   \       0x78   0x....             LDR.N    R0,??DataTable21_45
   \       0x7A   0x6800             LDR      R0,[R0, #+0]
   \       0x7C   0x....             LDR.N    R1,??DataTable21_49
   \       0x7E   0x6008             STR      R0,[R1, #+0]
   1680                Ant_pfnStateMachine = AntSM_TransmitMessage;
   \       0x80   0x.... 0x....      ADR.W    R0,AntSM_TransmitMessage
   \       0x84   0x....             LDR.N    R1,??DataTable21
   \       0x86   0x6008             STR      R0,[R1, #+0]
   1681              }
   1682              else
   1683              {
   1684                /* Transmit attempt failed.  !!!! Do something? */
   1685              }
   1686            }
   1687            
   1688          } /* end AntSM_Idle() */
   \                     ??AntSM_Idle_5: (+1)
   \       0x88   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .data, align 4
   \                     `AntSM_Idle::au8AntFlagAlert`:
   \        0x0   0x41 0x4E          DC8 "ANT flags:\012\015"
   \              0x54 0x20    
   \              0x66 0x6C    
   \              0x61 0x67    
   \              0x73 0x3A    
   \              0x0A 0x0D    
   \              0x00         
   \        0xD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
   \                     `AntSM_Idle::au8AntFlagMessages`:
   \        0x0   0x4C 0x65          DC8 "Length mismatch\012\015"
   \              0x6E 0x67    
   \              0x74 0x68    
   \              0x20 0x6D    
   \              0x69 0x73    
   \              0x6D 0x61    
   \              0x74 0x63    
   \              0x68 0x0A    
   \              0x0D 0x00    
   \       0x12   0x00 0x00          DC8 0, 0
   \       0x14   0x43 0x6F          DC8 "Command error\012\015"
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x0A    
   \              0x0D 0x00    
   \       0x24   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x28   0x55 0x6E          DC8 "Unexpected event\012\015"
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x65    
   \              0x76 0x65    
   \              0x6E 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \       0x3B   0x00               DC8 0
   \       0x3C   0x55 0x6E          DC8 55H, 6EH, 65H, 78H, 70H, 65H, 63H, 74H
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \       0x44   0x65 0x64          DC8 65H, 64H, 20H, 6DH, 65H, 73H, 73H, 61H
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \       0x4C   0x67 0x65          DC8 67H, 65H, 0AH, 0DH
   \              0x0A 0x0D    
   1689          
   1690          
   1691          /*------------------------------------------------------------------------------
   1692          Completely receive an ANT message.  Reception is very fast and should complete
   1693          in less than 600us for a 15-byte message.  AntRxMessage could just be called from Idle,
   1694          but giving it its own state minimizes the total time and allows for easier future
   1695          updates should they be required.
   1696          */

   \                                 In section .text, align 4, keep-with-next
   1697          void AntSM_ReceiveMessage(void)
   1698          {
   \                     AntSM_ReceiveMessage: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1699            Ant_DebugRxMessageCounter++;
   \        0x2   0x....             LDR.N    R0,??DataTable21_50
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x1C49             ADDS     R1,R1,#+1
   \        0x8   0x6001             STR      R1,[R0, #+0]
   1700            AntRxMessage();
   \        0xA   0x.... 0x....      BL       AntRxMessage
   1701            
   1702            Ant_pfnStateMachine = AntSM_Idle;
   \        0xE   0x....             LDR.N    R0,??DataTable21_51
   \       0x10   0x....             LDR.N    R1,??DataTable21
   \       0x12   0x6008             STR      R0,[R1, #+0]
   1703          
   1704          } /* end AntSM_ReceiveMessage() */
   \       0x14   0xBD01             POP      {R0,PC}          ;; return
   1705          
   1706          
   1707          /*------------------------------------------------------------------------------
   1708          Wait for an ANT message to be transmitted.  This state only occurs once the 
   1709          handshaking transaction has been completed and transmit to ANT is verified 
   1710          and underway.
   1711          */

   \                                 In section .text, align 4, keep-with-next
   1712          void AntSM_TransmitMessage(void)
   1713          {
   \                     AntSM_TransmitMessage: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1714            static u8 au8TxTimeoutMsg[] = "\n\rTransmit message timeout\n\r";
   1715            MessageStateType eCurrentMsgStatus;
   1716            
   1717            eCurrentMsgStatus = QueryMessageStatus(Ant_u32CurrentTxMessageToken);
   \        0x2   0x....             LDR.N    R5,??DataTable21_22
   \        0x4   0x6828             LDR      R0,[R5, #+0]
   \        0x6   0x.... 0x....      BL       QueryMessageStatus
   \        0xA   0x0004             MOVS     R4,R0
   1718            switch(eCurrentMsgStatus)
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x10   0x1F00             SUBS     R0,R0,#+4
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD829             BHI.N    ??AntSM_TransmitMessage_0
   1719            {
   1720              case TIMEOUT:
   1721                /* Fall through */
   1722                
   1723              case COMPLETE:
   1724                /* Kill the message and update flags */
   1725                AntDeQueueOutgoingMessage();
   \                     ??AntSM_TransmitMessage_1: (+1)
   \       0x16   0x.... 0x....      BL       AntDeQueueOutgoingMessage
   1726                Ant_u32CurrentTxMessageToken = 0;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x6028             STR      R0,[R5, #+0]
   1727                G_u32AntFlags &= ~_ANT_FLAGS_TX_IN_PROGRESS;
   \       0x1E   0x....             LDR.N    R0,??DataTable21_25
   \       0x20   0x6801             LDR      R1,[R0, #+0]
   \       0x22   0xF031 0x6100      BICS     R1,R1,#0x8000000
   \       0x26   0x6001             STR      R1,[R0, #+0]
   1728          
   1729                /* Wait for SEN to deassert so we know ANT is totally ready for the next
   1730                transaction.  This takes about 170us, so block in this state until that's over */
   1731                while ( IS_SEN_ASSERTED() && (Ant_u32TxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntSM_TransmitMessage_2: (+1)
   \       0x28   0x....             LDR.N    R5,??DataTable21_48
   \       0x2A   0x6828             LDR      R0,[R5, #+0]
   \       0x2C   0x07C0             LSLS     R0,R0,#+31
   \       0x2E   0xD509             BPL.N    ??AntSM_TransmitMessage_3
   \       0x30   0x....             LDR.N    R0,??DataTable21_49
   \       0x32   0x6801             LDR      R1,[R0, #+0]
   \       0x34   0xF242 0x7210      MOVW     R2,#+10000
   \       0x38   0x4291             CMP      R1,R2
   \       0x3A   0xD203             BCS.N    ??AntSM_TransmitMessage_3
   1732                {
   1733                  Ant_u32TxTimer++;
   \       0x3C   0x6801             LDR      R1,[R0, #+0]
   \       0x3E   0x1C49             ADDS     R1,R1,#+1
   \       0x40   0x6001             STR      R1,[R0, #+0]
   \       0x42   0xE7F1             B.N      ??AntSM_TransmitMessage_2
   1734                }
   1735          
   1736                /* If we timed out, then ANT is stuck so print error and unstick ANT */
   1737                if(Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT)
   \                     ??AntSM_TransmitMessage_3: (+1)
   \       0x44   0x....             LDR.N    R0,??DataTable21_52
   \       0x46   0x6800             LDR      R0,[R0, #+0]
   \       0x48   0xF242 0x7111      MOVW     R1,#+10001
   \       0x4C   0x4288             CMP      R0,R1
   \       0x4E   0xD308             BCC.N    ??AntSM_TransmitMessage_4
   1738                {
   1739                  DebugPrintf(au8TxTimeoutMsg);
   \       0x50   0x....             LDR.N    R0,??DataTable21_53
   \       0x52   0x.... 0x....      BL       DebugPrintf
   1740                  while( IS_SEN_ASSERTED() )
   \                     ??AntSM_TransmitMessage_5: (+1)
   \       0x56   0x6828             LDR      R0,[R5, #+0]
   \       0x58   0x07C0             LSLS     R0,R0,#+31
   \       0x5A   0xD502             BPL.N    ??AntSM_TransmitMessage_4
   1741                  {
   1742                    AntSrdyPulse();
   \       0x5C   0x.... 0x....      BL       AntSrdyPulse
   \       0x60   0xE7F9             B.N      ??AntSM_TransmitMessage_5
   1743                  }
   1744                }
   1745                
   1746                Ant_pfnStateMachine = AntSM_Idle;
   \                     ??AntSM_TransmitMessage_4: (+1)
   \       0x62   0x....             LDR.N    R0,??DataTable21_51
   \       0x64   0x....             LDR.N    R1,??DataTable21
   \       0x66   0x6008             STR      R0,[R1, #+0]
   1747                break;
   \       0x68   0xE7FF             B.N      ??AntSM_TransmitMessage_6
   1748                
   1749              default:
   1750                /* Do nothing for now */
   1751                break;
   1752                
   1753            } /* end switch */
   1754            
   1755          } /* end AntSM_TransmitMessage() */
   \                     ??AntSM_TransmitMessage_0: (+1)
   \                     ??AntSM_TransmitMessage_6: (+1)
   \       0x6A   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .data, align 4
   \                     `AntSM_TransmitMessage::au8TxTimeoutMsg`:
   \        0x0   0x0A 0x0D          DC8 "\012\015Transmit message timeout\012\015"
   \              0x54 0x72    
   \              0x61 0x6E    
   \              0x73 0x6D    
   \              0x69 0x74    
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \       0x1D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1756          
   1757          
   1758          /*------------------------------------------------------------------------------
   1759          Do-nothing state if ANT is dead (requires restart to retry initialization)
   1760          */

   \                                 In section .text, align 4, keep-with-next
   1761          void AntSM_NoResponse(void)
   1762          {
   1763            
   1764          } /* end AntSM_NoResponse() */
   \                     AntSM_NoResponse: (+1)
   \        0x0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x....'....        DC32     Ant_pu8AntRxBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x....'....        DC32     Ant_pu8AntRxBufferCurrentChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x....'....        DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0x400E'0E34        DC32     0x400e0e34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \        0x0   0x....'....        DC32     G_u32Ssp2ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \        0x0   0x....'....        DC32     Ant_u32RxByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \        0x0   0x....'....        DC32     Ant_u32RxTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \        0x0   0x....'....        DC32     G_u32AntFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x....'....        DC32     Ant_au8AntRxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x....'....        DC32     Ant_pu8AntRxBufferUnreadMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0x....'....        DC32     Ant_u8AntNewRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \        0x0   0x400E'0E30        DC32     0x400e0e30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x....'....        DC32     G_au8ANTGetVersion

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0x....'....        DC32     Ant_DebugTotalRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0x....'....        DC32     Ant_u32RxTimeoutCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \        0x0   0x....'....        DC32     Ant_u32UnexpectedByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \        0x0   0x....'....        DC32     Ant_pu8AntRxBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0x....'....        DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \        0x0   0x....'....        DC32     G_au8AntMessageNoAnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \        0x0   0x....'....        DC32     AntSM_NoResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \        0x0   0x400E'0E10        DC32     0x400e0e10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \        0x0   0x....'....        DC32     G_au8AntMessageInit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \        0x0   0x....'....        DC32     Ant_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \        0x0   0x....'....        DC32     G_sAntApplicationMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \        0x0   0x....'....        DC32     Ant_psDataOutgoingMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \        0x0   0x....'....        DC32     G_asAntChannelConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_4:
   \        0x0   0x....'....        DC32     Ant_sSspConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_5:
   \        0x0   0x400E'0E00        DC32     0x400e0e00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_6:
   \        0x0   0x....'....        DC32     Ant_Ssp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_7:
   \        0x0   0x....'....        DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_8:
   \        0x0   0x....'....        DC32     G_au8AntMessageOk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_9:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_10:
   \        0x0   0x....'....        DC32     Ant_u8AntVersion

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_11:
   \        0x0   0x....'....        DC32     G_au8AntMessageInitFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_12:
   \        0x0   0x400E'0C04        DC32     0x400e0c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_13:
   \        0x0   0x400E'0C00        DC32     0x400e0c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_14:
   \        0x0   0x400E'0E04        DC32     0x400e0e04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_15:
   \        0x0   0x400E'0C14        DC32     0x400e0c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_16:
   \        0x0   0x400E'0E14        DC32     0x400e0e14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_17:
   \        0x0   0x....'....        DC32     G_u32SystemTime1s

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_18:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_19:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_20:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_21:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_22:
   \        0x0   0x....'....        DC32     Ant_u32CurrentTxMessageToken

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_23:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_24:
   \        0x0   0x....'....        DC32     Ant_u32TxByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_25:
   \        0x0   0x....'....        DC32     G_u32AntFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_26:
   \        0x0   0x....'....        DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_27:
   \        0x0   0x....'....        DC32     Ant_DebugQueuedDataMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_28:
   \        0x0   0x....'....        DC32     Ant_u32OutgoingMessageCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_29:
   \        0x0   0x....'....        DC32     Ant_u32ApplicationMessageCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_30:
   \        0x0   0x....'....        DC32     Ant_DebugProcessRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_31:
   \        0x0   0x....'....        DC32     G_stMessageResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_32:
   \        0x0   0x....'....        DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_33:
   \        0x0   0x....'....        DC32     G_au8AntMessageOpen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_34:
   \        0x0   0x....'....        DC32     G_au8AntMessageClose

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_35:
   \        0x0   0x....'....        DC32     G_au8AntMessageAssign

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_36:
   \        0x0   0x....'....        DC32     G_au8AntMessageUnassign

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_37:
   \        0x0   0x....'....        DC32     G_au8AntMessageUnhandled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_38:
   \        0x0   0x....'....        DC32     G_au8AntMessageFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_39:
   \        0x0   0x....'....        DC32     Ant_u8SlaveMissedMessageLow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_40:
   \        0x0   0x....'....        DC32     Ant_u8SlaveMissedMessageMid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_41:
   \        0x0   0x....'....        DC32     Ant_u8SlaveMissedMessageHigh

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_42:
   \        0x0   0x....'....        DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_43:
   \        0x0   0x....'....        DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_44:
   \        0x0   0x....'....        DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_45:
   \        0x0   0x....'....        DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_46:
   \        0x0   0x....'....        DC32     `AntSM_Idle::au8AntFlagAlert`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_47:
   \        0x0   0x....'....        DC32     `AntSM_Idle::au8AntFlagMessages`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_48:
   \        0x0   0x....'....        DC32     G_u32Ssp2ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_49:
   \        0x0   0x....'....        DC32     Ant_u32TxTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_50:
   \        0x0   0x....'....        DC32     Ant_DebugRxMessageCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_51:
   \        0x0   0x....'....        DC32     AntSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_52:
   \        0x0   0x....'....        DC32     Ant_u32RxTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_53:
   \        0x0   0x....'....        DC32     `AntSM_TransmitMessage::au8TxTimeoutMsg`

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x41 0x6E          DC8 "AntRx: timeout\012\015"
   \              0x74 0x52    
   \              0x78 0x3A    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \       0x11   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x41 0x6E          DC8 "AntRx: message failed\012\015"
   \              0x74 0x52    
   \              0x78 0x3A    
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x0A 0x0D          DC8 "\012\015Unexpected ANT message size\012\012\015"
   \              0x55 0x6E    
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x41    
   \              0x4E 0x54    
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x73    
   \              0x69 0x7A    
   \              0x65 0x0A    
   \              0x0A 0x0D    
   \              0x00         
   \       0x21   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x41 0x4E          DC8 "ANT version: "
   \              0x54 0x20    
   \              0x76 0x65    
   \              0x72 0x73    
   \              0x69 0x6F    
   \              0x6E 0x3A    
   \              0x20 0x00    
   \        0xE   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x41 0x6E          DC8 "AntTx: msg already in progress\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x6D    
   \              0x73 0x67    
   \              0x20 0x61    
   \              0x6C 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x6F 0x67    
   \              0x72 0x65    
   \              0x73 0x73    
   \              0x0A 0x0D    
   \              0x00         
   \       0x21   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x41 0x6E          DC8 "AntTx: SEN timeout\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x53    
   \              0x45 0x4E    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \       0x15   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x41 0x6E          DC8 "AntTx: No token\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x74 0x6F    
   \              0x6B 0x65    
   \              0x6E 0x0A    
   \              0x0D 0x00    
   \       0x12   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x41 0x6E          DC8 "AntTx: No SYNC\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x53 0x59    
   \              0x4E 0x43    
   \              0x0A 0x0D    
   \              0x00         
   \       0x11   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x0D 0x0A          DC8 "\015\012ANT expected msg fail\012\015"
   \              0x41 0x4E    
   \              0x54 0x20    
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x6D    
   \              0x73 0x67    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x0A    
   \              0x0D 0x00    
   \       0x1A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_9:
   \        0x0   0x0A 0x0D          DC8 "\012\015No space in AntQueueOutgoingMessage\012\015"
   \              0x4E 0x6F    
   \              0x20 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x41 0x6E    
   \              0x74 0x51    
   \              0x75 0x65    
   \              0x75 0x65    
   \              0x4F 0x75    
   \              0x74 0x67    
   \              0x6F 0x69    
   \              0x6E 0x67    
   \              0x4D 0x65    
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0x53 0x63          DC8 "Scanning "
   \              0x61 0x6E    
   \              0x6E 0x69    
   \              0x6E 0x67    
   \              0x20 0x00    
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_11:
   \        0x0   0x43 0x68          DC8 "Channel closed\012\015"
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x63 0x6C    
   \              0x6F 0x73    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \       0x11   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_12:
   \        0x0   0x3A 0x20          DC8 ": unexpected channel event\012\015"
   \              0x75 0x6E    
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x63    
   \              0x68 0x61    
   \              0x6E 0x6E    
   \              0x65 0x6C    
   \              0x20 0x65    
   \              0x76 0x65    
   \              0x6E 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \       0x1D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0x0A 0x0D          DC8 "\012\015No space in AntQueueApplicationMessage\012\015"
   \              0x4E 0x6F    
   \              0x20 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x41 0x6E    
   \              0x74 0x51    
   \              0x75 0x65    
   \              0x75 0x65    
   \              0x41 0x70    
   \              0x70 0x6C    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x4D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x0A 0x0D    
   \              0x00         
   \       0x2B   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AdvanceAntRxBufferCurrentChar
       0   AdvanceAntRxBufferUnreadMsgPointer
       0   AntAbortMessage
       8   AntCalculateTxChecksum
       8   AntDeQueueApplicationMessage
         8   -> free
       8   AntDeQueueOutgoingMessage
         8   -> free
      64   AntExpectResponse
        64   -> AntDeQueueOutgoingMessage
        64   -> AntProcessMessage
        64   -> AntRxMessage
        64   -> DebugPrintf
        64   -> IsTimeUp
        64   -> __aeabi_memcpy
      24   AntInitialize
        24   -> AntSyncSerialInitialize
        24   -> DebugLineFeed
        24   -> DebugPrintf
        24   -> SspRequest
      40   AntParseExtendedData
        40   -> DebugPrintf
      48   AntProcessMessage
        48   -> AdvanceAntRxBufferUnreadMsgPointer
        48   -> AntParseExtendedData
        48   -> AntQueueExtendedApplicationMessage
        48   -> AntTickExtended
        48   -> DebugPrintNumber
        48   -> DebugPrintf
        48   -> HexToASCIICharLower
      72   AntQueueExtendedApplicationMessage
        72   -> DebugPrintf
        72   -> __aeabi_memcpy
        72   -> malloc
      64   AntQueueOutgoingMessage
        64   -> DebugPrintf
        64   -> __aeabi_memcpy4
        64   -> malloc
       8   AntRunActiveState
         8   -- Indirect call
       8   AntRxFlowControlCallback
         8   -> AntSrdyPulse
      88   AntRxMessage
        88   -> AdvanceAntRxBufferCurrentChar
        88   -> AdvanceAntRxBufferUnreadMsgPointer
        88   -> AntAbortMessage
        88   -> AntSrdyPulse
        88   -> DebugPrintf
        88   -> __aeabi_memcpy
        88   -> __aeabi_memcpy4
      24   AntSM_Idle
        24   -> AntProcessMessage
        24   -> AntTxMessage
        24   -> DebugPrintf
       0   AntSM_NoResponse
       8   AntSM_ReceiveMessage
         8   -> AntRxMessage
      16   AntSM_TransmitMessage
        16   -> AntDeQueueOutgoingMessage
        16   -> AntSrdyPulse
        16   -> DebugPrintf
        16   -> QueryMessageStatus
       0   AntSrdyPulse
      24   AntSyncSerialInitialize
        24   -> AntCalculateTxChecksum
        24   -> AntExpectResponse
        24   -> AntProcessMessage
        24   -> AntRxMessage
        24   -> AntTxMessage
        24   -> IsTimeUp
      24   AntTickExtended
        24   -> AntQueueExtendedApplicationMessage
       8   AntTxFlowControlCallback
         8   -> AntSrdyPulse
     136   AntTxMessage
       136   -> AdvanceAntRxBufferCurrentChar
       136   -> AdvanceAntRxBufferUnreadMsgPointer
       136   -> AntSrdyPulse
       136   -> DebugPrintf
       136   -> SspWriteData
       136   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_11
       4  ??DataTable21_12
       4  ??DataTable21_13
       4  ??DataTable21_14
       4  ??DataTable21_15
       4  ??DataTable21_16
       4  ??DataTable21_17
       4  ??DataTable21_18
       4  ??DataTable21_19
       4  ??DataTable21_2
       4  ??DataTable21_20
       4  ??DataTable21_21
       4  ??DataTable21_22
       4  ??DataTable21_23
       4  ??DataTable21_24
       4  ??DataTable21_25
       4  ??DataTable21_26
       4  ??DataTable21_27
       4  ??DataTable21_28
       4  ??DataTable21_29
       4  ??DataTable21_3
       4  ??DataTable21_30
       4  ??DataTable21_31
       4  ??DataTable21_32
       4  ??DataTable21_33
       4  ??DataTable21_34
       4  ??DataTable21_35
       4  ??DataTable21_36
       4  ??DataTable21_37
       4  ??DataTable21_38
       4  ??DataTable21_39
       4  ??DataTable21_4
       4  ??DataTable21_40
       4  ??DataTable21_41
       4  ??DataTable21_42
       4  ??DataTable21_43
       4  ??DataTable21_44
       4  ??DataTable21_45
       4  ??DataTable21_46
       4  ??DataTable21_47
       4  ??DataTable21_48
       4  ??DataTable21_49
       4  ??DataTable21_5
       4  ??DataTable21_50
       4  ??DataTable21_51
       4  ??DataTable21_52
       4  ??DataTable21_53
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
      20  ?_0
      24  ?_1
      12  ?_10
      20  ?_11
      32  ?_12
      44  ?_13
      36  ?_2
      16  ?_3
      36  ?_4
      24  ?_5
      20  ?_6
      20  ?_7
      28  ?_8
      40  ?_9
      28  AdvanceAntRxBufferCurrentChar
      28  AdvanceAntRxBufferUnreadMsgPointer
      36  AntAbortMessage
      40  AntCalculateTxChecksum
      40  AntDeQueueApplicationMessage
      28  AntDeQueueOutgoingMessage
     230  AntExpectResponse
     446  AntInitialize
     244  AntParseExtendedData
     900  AntProcessMessage
     194  AntQueueExtendedApplicationMessage
     184  AntQueueOutgoingMessage
      12  AntRunActiveState
      52  AntRxFlowControlCallback
     462  AntRxMessage
     138  AntSM_Idle
       2  AntSM_NoResponse
      22  AntSM_ReceiveMessage
     108  AntSM_TransmitMessage
      38  AntSrdyPulse
     182  AntSyncSerialInitialize
      94  AntTickExtended
      18  AntTxFlowControlCallback
     338  AntTxMessage
       4  Ant_DebugProcessRxMessages
       4  Ant_DebugQueuedDataMessages
       4  Ant_DebugRxMessageCounter
       4  Ant_DebugTotalRxMessages
       4  Ant_Ssp
     256  Ant_au8AntRxBuffer
       4  Ant_pfnStateMachine
       4  Ant_psDataOutgoingMsgList
       4  Ant_pu8AntRxBufferCurrentChar
       4  Ant_pu8AntRxBufferNextChar
       4  Ant_pu8AntRxBufferUnreadMsg
      36  Ant_sSspConfig
       4  Ant_u32ApplicationMessageCount
       4  Ant_u32CurrentTxMessageToken
       4  Ant_u32OutgoingMessageCount
       4  Ant_u32RxByteCounter
       4  Ant_u32RxTimeoutCounter
       4  Ant_u32RxTimer
       4  Ant_u32TxByteCounter
       4  Ant_u32TxTimer
       4  Ant_u32UnexpectedByteCounter
       1  Ant_u8AntNewRxMessages
      12  Ant_u8AntVersion
       1  Ant_u8SlaveMissedMessageHigh
       1  Ant_u8SlaveMissedMessageLow
       1  Ant_u8SlaveMissedMessageMid
     160  G_asAntChannelConfiguration
       8  G_au8ANTGetVersion
      12  G_au8AntAckDataMessage
       8  G_au8AntAssignChannel
      12  G_au8AntBroadcastDataMessage
       8  G_au8AntLibConfig
      24  G_au8AntMessageAssign
      24  G_au8AntMessageClose
       8  G_au8AntMessageFail
      24  G_au8AntMessageInit
      32  G_au8AntMessageInitFail
      64  G_au8AntMessageNoAnt
       8  G_au8AntMessageOk
      20  G_au8AntMessageOpen
      24  G_au8AntMessageSetup
      24  G_au8AntMessageUnassign
      40  G_au8AntMessageUnhandled
       8  G_au8AntSetChannelID
       8  G_au8AntSetChannelPeriod
       8  G_au8AntSetChannelPower
       8  G_au8AntSetChannelRFFreq
      12  G_au8AntSetNetworkKey
       4  G_sAntApplicationMsgList
       4  G_stMessageResponse
       4  G_u32AntFlags
      16  au8AntFlagAlert
      80  au8AntFlagMessages
      32  au8TxTimeoutMsg

 
   556 bytes in section .bss
   512 bytes in section .data
   372 bytes in section .rodata
 4 180 bytes in section .text
 
 4 180 bytes of CODE  memory
   372 bytes of CONST memory
 1 068 bytes of DATA  memory

Errors: none
Warnings: none
