###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.2.160/W32 for ARM         14/Oct/2018  14:43:38
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_common\drivers\sam3u_uart.c
#    Command line =  
#        -f C:\Users\BUDWA_~1\AppData\Local\Temp\EWE174.tmp
#        (C:\Embedded\Firmware\git_Razor_Atmel\firmware_common\drivers\sam3u_uart.c
#        -D EIE1 --preprocess=c
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List
#        -lC
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List
#        -o
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\ -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\bsp\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\drivers\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\application\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.1\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List\sam3u_uart.lst
#    Object file  =  
#        C:\Embedded\Firmware\git_Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\Obj\sam3u_uart.o
#
###############################################################################

C:\Embedded\Firmware\git_Razor_Atmel\firmware_common\drivers\sam3u_uart.c
      1          /**********************************************************************************************************************
      2          File: sam3u_uart.c                                                                
      3          
      4          Description:
      5          Provides a driver to use UART peripherals to send and receive data using interrupts. 
      6          This driver covers both the dedicated UART peripheral and the three USART peripherals (assuming they are
      7          running in asynchronous (UART) mode).
      8          
      9          UART0 (38,400 8-N-1) gets special treatment to allow it to run very simply since it is only a debug interface.  The transmit buffer is
     10          owned by this source file and is accessed through the API.
     11          
     12          
     13          ------------------------------------------------------------------------------------------------------------------------
     14          API:
     15          Simple Public Debug UART functions:
     16          void Uart_putc(u8 u8Char_)
     17          bool UartCheckForNewChar(void)
     18          u8 Uart_getc(void)
     19          
     20          Generic Public UART functions
     21          UartPeripheralType* UartRequest(UartConfigurationType* psUartConfig_);
     22          Request a UART peripheral for your task.  No other tasks in the system will be able to access 
     23          the specific UART peripheral you request.
     24          e.g. MyTaskUart = UartRequest(&MyTaskUartConfig);
     25          
     26          void UartRelease(UartPeripheralType* psUartPeripheral_);
     27          If your task is done using the UART it requested, call this function to "give it back" to the system.
     28          e.g. UartRelease(&MyTaskUart);
     29          
     30          u32 UartWriteByte(UartPeripheralType* psUartPeripheral_, u8 u8Byte_);
     31          Write a single byte to the UART.  A token corresponding to the message is returned if you want to monitor
     32          if the byte sends correctly.
     33          e.g u32CurrentMessageToken = UartWriteByte(&MyTaskUart, 'A');
     34          
     35          u32 UartWriteData(UartPeripheralType* psUartPeripheral_, u32 u32Size_, u8* u8Data_);
     36          Write an array of bytes to the UART.  Returns the message token for monitoring the status of the message.
     37          e.g. 
     38          u8 au8Sting[] = "Send this string!\n\r";
     39          u32CurrentMessageToken = UartWriteData(&MyTaskUart, strlen(au8Sting), au8Sting);
     40          
     41          All receive functionality is automatic. Incoming bytes are deposited to the 
     42          buffer specified in psUartConfig_
     43          
     44          Both Tx and Rx use the peripheral DMA controller, though received bytes
     45          are always received one at a time to allow use of a circular buffer by the
     46          client task.
     47          
     48          INITIALIZATION (should take place in application's initialization function):
     49          1. Create a variable of UartConfigurationType in your application and initialize it to the desired UART peripheral,
     50          the address of the receive buffer for the application and the size in bytes of the receive buffer.
     51          
     52          2. Call UartRequest() with pointer to the configuration variable created in step 1.  The returned pointer is the
     53          UartPeripheralType object created that will be used by your application and should be assigned to a variable
     54          accessible to your application.
     55          
     56          3. If the application no longer needs the UART resource, call UartRelease().  
     57          
     58          DATA TRANSFER:
     59          1. Received bytes on the allocated peripheral will be dropped into the application's designated receive
     60          buffer.  The buffer is written circularly, with no provision to monitor bytes that are overwritten.  The 
     61          application is responsible for processing all received data.  The application must provide its own parsing
     62          pointer to read the receive buffer and properly wrap around.  This pointer will not be impacted by the interrupt
     63          service routine that may add additional characters at any time.
     64          
     65          2. Transmitted data is queued using one of two functions, UartWriteByte() and UartWriteData().  Once the data
     66          is queued, it is sent as soon as possible.  Each UART resource has a transmit queue, but only one UART resource
     67          will send data at any given time from this state machine.  However, all UART resources may receive data simultaneously
     68          through their respective interrupt handlers based on interrupt priority.
     69          
     70          **********************************************************************************************************************/
     71          
     72          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0x6   0x408A             LSLS     R2,R2,R1
   \        0x8   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0xe000e100
   \        0xC   0x0003             MOVS     R3,R0
   \        0xE   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \       0x10   0x095B             LSRS     R3,R3,#+5
   \       0x12   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \       0x16   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0x6   0x408A             LSLS     R2,R2,R1
   \        0x8   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0xe000e180
   \        0xC   0x0003             MOVS     R3,R0
   \        0xE   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \       0x10   0x095B             LSRS     R3,R3,#+5
   \       0x12   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \       0x16   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0x6   0x408A             LSLS     R2,R2,R1
   \        0x8   0x.... 0x....      LDR.W    R1,??DataTable16_2  ;; 0xe000e280
   \        0xC   0x0003             MOVS     R3,R0
   \        0xE   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \       0x10   0x095B             LSRS     R3,R3,#+5
   \       0x12   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \       0x16   0x4770             BX       LR               ;; return
     73          
     74          
     75          /***********************************************************************************************************************
     76          Global variable definitions with scope across entire project.
     77          All Global variable names shall start with "G_<type>Uart"
     78          ***********************************************************************************************************************/
     79          /* New variables */

   \                                 In section .bss, align 4
     80          u32 G_u32UartApplicationFlags;                    /* Status flags meant for application using this UART peripheral */
   \                     G_u32UartApplicationFlags:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     81          u32 G_u32Uart0ApplicationFlags;                   /* Status flags meant for application using this UART peripheral */
   \                     G_u32Uart0ApplicationFlags:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     82          u32 G_u32Uart1ApplicationFlags;                   /* Status flags meant for application using this UART peripheral */
   \                     G_u32Uart1ApplicationFlags:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     83          u32 G_u32Uart2ApplicationFlags;                   /* Status flags meant for application using this UART peripheral */
   \                     G_u32Uart2ApplicationFlags:
   \        0x0                      DS8 4
     84          
     85          
     86          /*--------------------------------------------------------------------------------------------------------------------*/
     87          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     88          extern volatile u32 G_u32SystemTime1ms;        /* From board-specific source file */
     89          extern volatile u32 G_u32SystemTime1s;         /* From board-specific source file */
     90          
     91          extern volatile u32 G_u32SystemFlags;          /* From main.c */
     92          extern volatile u32 G_u32ApplicationFlags;     /* From main.c */
     93          
     94          
     95          /***********************************************************************************************************************
     96          Global variable definitions with scope limited to this local application.
     97          Variable names shall start with "UART_" and be declared as static.
     98          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     99          static fnCode_type Uart_pfnStateMachine;        /* The UART application state machine function pointer */
   \                     Uart_pfnStateMachine:
   \        0x0                      DS8 4
    100          

   \                                 In section .bss, align 4
    101          static u32 UART_u32Timer;                       /* Counter used across states */
   \                     UART_u32Timer:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    102          static u32 UART_u32Flags;                       /* Application flags for UART */
   \                     UART_u32Flags:
   \        0x0                      DS8 4

   \                                 In section .bss, align 1
    103          static u8 UART_u8ActiveUarts = 0;               /* Counting semaphore for # of active UARTs */
   \                     UART_u8ActiveUarts:
   \        0x0                      DS8 1
    104          

   \                                 In section .bss, align 4
    105          static UartPeripheralType UART_Peripheral;      /* UART peripheral object */
   \                     UART_Peripheral:
   \        0x0                      DS8 36

   \                                 In section .bss, align 4
    106          static UartPeripheralType UART_Peripheral0;     /* USART0 peripheral object (used as UART) */
   \                     UART_Peripheral0:
   \        0x0                      DS8 36

   \                                 In section .bss, align 4
    107          static UartPeripheralType UART_Peripheral1;     /* USART1 peripheral object (used as UART) */
   \                     UART_Peripheral1:
   \        0x0                      DS8 36

   \                                 In section .bss, align 4
    108          static UartPeripheralType UART_Peripheral2;     /* USART2 peripheral object (used as UART) */
   \                     UART_Peripheral2:
   \        0x0                      DS8 36
    109          

   \                                 In section .bss, align 4
    110          static UartPeripheralType* UART_psCurrentUart;   /* Current UART peripheral being processed */
   \                     UART_psCurrentUart:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    111          static UartPeripheralType* UART_psCurrentISR;    /* Current UART peripheral being processed in ISR */
   \                     UART_psCurrentISR:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    112          static u32* UART_pu32ApplicationFlagsISR;        /* Current UART application status flags in ISR */
   \                     UART_pu32ApplicationFlagsISR:
   \        0x0                      DS8 4
    113          
    114          /* Buffers for simple UART implementation */
    115          #if USE_SIMPLE_USART0
    116          static u8  UART_au8U0RxBuffer[U0RX_BUFFER_SIZE];/* Receive buffer for basic UART0 */
    117          static u8* UART_pu8U0RxBufferNextChar;          /* Pointer to location where next incoming char should be written */
    118          static u8* UART_pu8U0RxBufferUnreadChar;        /* Pointer to location of next char that has not yet been read */
    119          
    120          static u8  UART_au8U0TxBuffer[U0TX_BUFFER_SIZE];/* Transmit buffer for basic UART0 */
    121          static u8* UART_pu8U0TxBufferNextChar;          /* Pointer to location where next outgoing char should be written */
    122          static u8* UART_pu8U0TxBufferUnsentChar;        /* Pointer to location of next char that has not yet been sent */
    123          #endif /* USE_SIMPLE_USART0 */
    124          

   \                                 In section .bss, align 4
    125          static u32 UART_u32IntCount = 0;                /* Debug counter for UART interrupts */
   \                     UART_u32IntCount:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    126          static u32 UART_u32Int0Count = 0;               /* Debug counter for USART0 interrupts */
   \                     UART_u32Int0Count:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    127          static u32 UART_u32Int1Count = 0;               /* Debug counter for USART1 interrupts */
   \                     UART_u32Int1Count:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    128          static u32 UART_u32Int2Count = 0;               /* Debug counter for USART2 interrupts */
   \                     UART_u32Int2Count:
   \        0x0                      DS8 4
    129          
    130          
    131          /***********************************************************************************************************************
    132          Function Definitions
    133          ***********************************************************************************************************************/
    134          /*--------------------------------------------------------------------------------------------------------------------*/
    135          /* Public Functions */
    136          /*--------------------------------------------------------------------------------------------------------------------*/
    137          
    138          #if USE_SIMPLE_USART0
    139          
    140          /*----------------------------------------------------------------------------------------------------------------------
    141          Function: Uart_putc
    142          
    143          Description:
    144          Writes a char directly to the debug UART transmit buffer.
    145          
    146          Requires:
    147            - Debug UART is set up
    148          
    149          Promises:
    150            - Character is written directly to the UART buffer if transmitter is ready
    151            - Returns TRUE if character queued to transmit buffer; else returns FALSE
    152          */
    153          bool Uart_putc(u8 u8Char_)
    154          {
    155            /* Check if the transmitter is available */
    156            if(AT91C_BASE_US0->US_CSR & AT91C_US_TXRDY)
    157            {
    158              /* Load the character to send it */
    159              AT91C_BASE_US0->US_THR = u8Char_;    
    160              return TRUE;
    161            }
    162            else
    163            {
    164              /* Transmitter not ready: return FALSE */
    165              return FALSE;
    166            }
    167            
    168          } /* end Uart_putc() */
    169          
    170          
    171          /*----------------------------------------------------------------------------------------------------------------------
    172          Function: Uart_getc
    173          
    174          Description:
    175          Reads a char directly to the debug UART transmit buffer.
    176          Recommended that user first calls UartCheckForNewChar to ensure there is a valid character ready.
    177          
    178          Requires:
    179            - Debug UART is set up
    180          
    181          Promises:
    182            - If there is at least 1 new character, the oldest character from the UART is loaded to pu8Byte and function returns TRUE
    183            - If there are no new characters, pu8Byte_ is untouched and function returns FALSE.
    184          */
    185          bool Uart_getc(u8* pu8Byte_)
    186          {
    187            /* Check if there is at least one new character in the buffer */
    188            if( UartCheckForNewChar() )
    189            {
    190              /* Read the oldest unread character */
    191              *pu8Byte_ = *UART_pu8U0RxBufferUnreadChar;
    192          
    193              /* Safely advance the pointer */
    194              UART_pu8U0RxBufferUnreadChar++;
    195              if(UART_pu8U0RxBufferUnreadChar == &UART_au8U0RxBuffer[U0RX_BUFFER_SIZE])
    196              {
    197                UART_pu8U0RxBufferUnreadChar = &UART_au8U0RxBuffer[0];
    198              }
    199            }
    200            else
    201            {
    202              return FALSE;
    203            }
    204            
    205            return TRUE;
    206            
    207          } /* end Uart_getc() */
    208          
    209          
    210          /*----------------------------------------------------------------------------------------------------------------------
    211          Function: UartCheckForNewChar
    212          
    213          Description:
    214          Checks to see if any new characters are present in the UART debug receive buffer.
    215          
    216          Requires:
    217            - Debug UART is set up
    218          
    219          Promises:
    220            - Returns TRUE if there are new chars ready in the debug UART rx buffer; otherwise
    221              returns FALSE
    222          */
    223          bool UartCheckForNewChar(void)
    224          {
    225            if(UART_pu8U0RxBufferNextChar == UART_pu8U0RxBufferUnreadChar)
    226            {
    227              return(FALSE);
    228            }
    229            else
    230            {
    231              return(TRUE);
    232            }
    233            
    234          } /* end UartCheckForNewChar() */
    235          
    236          #endif /* USE_SIMPLE_USART0 */
    237          
    238          /*----------------------------------------------------------------------------------------------------------------------
    239          Function: UartRequest
    240          
    241          Description:
    242          Requests access to a UART resource.  If the resource is available, the transmit and receive parameters are set up
    243          and the peripheral is made ready to use in the application.  
    244          
    245          Requires:
    246            - UART_Peripheralx perihperal objects have been initialized
    247            - USART Peripheralx registers are not write-protected (WPEN)
    248            - UART peripheral register initialization values in configuration.h must be set correctly
    249            - psUartConfig_ has the UART peripheral number, address of the RxBuffer, and the RxBuffer size and the calling
    250              application is ready to start using the peripheral.
    251            - UART/USART peripheral registers configured here are available and at the same address offset regardless of the peripheral. 
    252          
    253          Promises:
    254            - Returns NULL if a resource cannot be assigned; OR
    255            - Returns a pointer to the requested UART peripheral object if the resource is available
    256            - Peripheral is configured and enabled 
    257            - Peripheral interrupts are enabled.
    258          */

   \                                 In section .text, align 2, keep-with-next
    259          UartPeripheralType* UartRequest(UartConfigurationType* psUartConfig_)
    260          {
   \                     UartRequest: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
    261            UartPeripheralType* psRequestedUart;
    262            u32 u32TargetCR, u32TargetMR, u32TargetIER, u32TargetIDR, u32TargetBRGR;
    263            
    264            switch(psUartConfig_->UartPeripheral)
   \        0x6   0x7820             LDRB     R0,[R4, #+0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD006             BEQ.N    ??UartRequest_0
   \        0xC   0xD335             BCC.N    ??UartRequest_1
   \        0xE   0x2803             CMP      R0,#+3
   \       0x10   0xD01B             BEQ.N    ??UartRequest_2
   \       0x12   0xD30E             BCC.N    ??UartRequest_3
   \       0x14   0x2804             CMP      R0,#+4
   \       0x16   0xD024             BEQ.N    ??UartRequest_4
   \       0x18   0xE02F             B.N      ??UartRequest_1
    265            {
    266              case UART:
    267              {
    268                psRequestedUart = &UART_Peripheral; 
   \                     ??UartRequest_0: (+1)
   \       0x1A   0x.... 0x....      LDR.W    R5,??DataTable16_3
    269          
    270                u32TargetCR   = UART_US_CR_INIT;
   \       0x1E   0x2650             MOVS     R6,#+80
    271                u32TargetMR   = UART_US_MR_INIT; 
   \       0x20   0x.... 0x....      LDR.W    R7,??DataTable16_4  ;; 0x4008c0
    272                u32TargetIER  = UART_US_IER_INIT; 
   \       0x24   0xF05F 0x0800      MOVS     R8,#+0
    273                u32TargetIDR  = UART_US_IDR_INIT;
   \       0x28   0xF05F 0x39FF      MOVS     R9,#-1
    274                u32TargetBRGR = UART_US_BRGR_INIT;
   \       0x2C   0xF05F 0x0A1A      MOVS     R10,#+26
    275                break;
   \       0x30   0xE025             B.N      ??UartRequest_5
    276              } 
    277          
    278              case USART0:
    279              {
    280                psRequestedUart = &UART_Peripheral0; 
   \                     ??UartRequest_3: (+1)
   \       0x32   0x.... 0x....      LDR.W    R5,??DataTable16_5
    281          
    282                u32TargetCR   = USART0_US_CR_INIT;
   \       0x36   0x2650             MOVS     R6,#+80
    283                u32TargetMR   = USART0_US_MR_INIT; 
   \       0x38   0x.... 0x....      LDR.W    R7,??DataTable16_4  ;; 0x4008c0
    284                u32TargetIER  = USART0_US_IER_INIT; 
   \       0x3C   0xF05F 0x0808      MOVS     R8,#+8
    285                u32TargetIDR  = USART0_US_IDR_INIT;
   \       0x40   0xF07F 0x0908      MVNS     R9,#+8
    286                u32TargetBRGR = USART0_US_BRGR_INIT;
   \       0x44   0xF05F 0x0A1A      MOVS     R10,#+26
    287                break;
   \       0x48   0xE019             B.N      ??UartRequest_5
    288              } 
    289          
    290              case USART1:
    291              {
    292                psRequestedUart = &UART_Peripheral1; 
   \                     ??UartRequest_2: (+1)
   \       0x4A   0x.... 0x....      LDR.W    R5,??DataTable16_6
    293          
    294                u32TargetCR   = USART1_US_CR_INIT;
   \       0x4E   0x2650             MOVS     R6,#+80
    295                u32TargetMR   = USART1_US_MR_INIT; 
   \       0x50   0x.... 0x....      LDR.W    R7,??DataTable16_7  ;; 0x4518ce
    296                u32TargetIER  = USART1_US_IER_INIT; 
   \       0x54   0xF05F 0x0800      MOVS     R8,#+0
    297                u32TargetIDR  = USART1_US_IDR_INIT;
   \       0x58   0xF05F 0x39FF      MOVS     R9,#-1
    298                u32TargetBRGR = USART1_US_BRGR_INIT;
   \       0x5C   0xF05F 0x0A30      MOVS     R10,#+48
    299                break;
   \       0x60   0xE00D             B.N      ??UartRequest_5
    300              } 
    301              
    302              case USART2:
    303              {
    304                psRequestedUart = &UART_Peripheral2; 
   \                     ??UartRequest_4: (+1)
   \       0x62   0x.... 0x....      LDR.W    R5,??DataTable16_8
    305                
    306                u32TargetCR   = USART2_US_CR_INIT;
   \       0x66   0x2650             MOVS     R6,#+80
    307                u32TargetMR   = USART2_US_MR_INIT; 
   \       0x68   0x.... 0x....      LDR.W    R7,??DataTable16_9  ;; 0x4118ff
    308                u32TargetIER  = USART2_US_IER_INIT; 
   \       0x6C   0xF45F 0x2800      MOVS     R8,#+524288
    309                u32TargetIDR  = USART2_US_IDR_INIT;
   \       0x70   0xF47F 0x2900      MVNS     R9,#+524288
    310                u32TargetBRGR = USART2_US_BRGR_INIT;
   \       0x74   0xF05F 0x0A00      MOVS     R10,#+0
    311                break;
   \       0x78   0xE001             B.N      ??UartRequest_5
    312              } 
    313          
    314              default:
    315              {
    316                return(NULL);
   \                     ??UartRequest_1: (+1)
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0xE047             B.N      ??UartRequest_6
    317                break;
    318              } 
    319            } /* end switch */
    320          
    321            /* If the requested peripheral is already assigned, return NULL now */
    322            if(psRequestedUart->u32PrivateFlags & _UART_PERIPHERAL_ASSIGNED)
   \                     ??UartRequest_5: (+1)
   \       0x7E   0x7928             LDRB     R0,[R5, #+4]
   \       0x80   0x07C0             LSLS     R0,R0,#+31
   \       0x82   0xD501             BPL.N    ??UartRequest_7
    323            {
    324              return(NULL);
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0xE042             B.N      ??UartRequest_6
    325            }
    326            
    327            /* Activate and configure the peripheral */
    328            AT91C_BASE_PMC->PMC_PCER |= (1 << psRequestedUart->u8PeripheralId);
   \                     ??UartRequest_7: (+1)
   \       0x88   0x.... 0x....      LDR.W    R1,??DataTable16_10  ;; 0x400e0410
   \       0x8C   0x680A             LDR      R2,[R1, #+0]
   \       0x8E   0x2301             MOVS     R3,#+1
   \       0x90   0xF995 0x0022      LDRSB    R0,[R5, #+34]
   \       0x94   0x4083             LSLS     R3,R3,R0
   \       0x96   0x431A             ORRS     R2,R3,R2
   \       0x98   0x600A             STR      R2,[R1, #+0]
    329          
    330            psRequestedUart->pu8RxBuffer     = psUartConfig_->pu8RxBufferAddress;
   \       0x9A   0x6860             LDR      R0,[R4, #+4]
   \       0x9C   0x6168             STR      R0,[R5, #+20]
    331            psRequestedUart->u16RxBufferSize = psUartConfig_->u16RxBufferSize;
   \       0x9E   0x8860             LDRH     R0,[R4, #+2]
   \       0xA0   0x8428             STRH     R0,[R5, #+32]
    332            psRequestedUart->pu8RxNextByte   = psUartConfig_->pu8RxNextByte;
   \       0xA2   0x68A0             LDR      R0,[R4, #+8]
   \       0xA4   0x61A8             STR      R0,[R5, #+24]
    333            psRequestedUart->fnRxCallback    = psUartConfig_->fnRxCallback;
   \       0xA6   0x68E0             LDR      R0,[R4, #+12]
   \       0xA8   0x61E8             STR      R0,[R5, #+28]
    334            psRequestedUart->u32PrivateFlags |= _UART_PERIPHERAL_ASSIGNED;
   \       0xAA   0x6868             LDR      R0,[R5, #+4]
   \       0xAC   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xB0   0x6068             STR      R0,[R5, #+4]
    335            
    336            psRequestedUart->pBaseAddress->US_CR   = u32TargetCR;
   \       0xB2   0x6828             LDR      R0,[R5, #+0]
   \       0xB4   0x6006             STR      R6,[R0, #+0]
    337            psRequestedUart->pBaseAddress->US_MR   = u32TargetMR;
   \       0xB6   0x6828             LDR      R0,[R5, #+0]
   \       0xB8   0x6047             STR      R7,[R0, #+4]
    338            psRequestedUart->pBaseAddress->US_IER  = u32TargetIER;
   \       0xBA   0x6828             LDR      R0,[R5, #+0]
   \       0xBC   0xF8C0 0x8008      STR      R8,[R0, #+8]
    339            psRequestedUart->pBaseAddress->US_IDR  = u32TargetIDR;
   \       0xC0   0x6828             LDR      R0,[R5, #+0]
   \       0xC2   0xF8C0 0x900C      STR      R9,[R0, #+12]
    340            psRequestedUart->pBaseAddress->US_BRGR = u32TargetBRGR;
   \       0xC6   0x6828             LDR      R0,[R5, #+0]
   \       0xC8   0xF8C0 0xA020      STR      R10,[R0, #+32]
    341          
    342            /* Preset the receive PDC pointers and counters; the receive buffer must be starting from [0] and be at least 2 bytes long)*/
    343            psRequestedUart->pBaseAddress->US_RPR  = (unsigned int)psUartConfig_->pu8RxBufferAddress;
   \       0xCC   0x6860             LDR      R0,[R4, #+4]
   \       0xCE   0x6829             LDR      R1,[R5, #+0]
   \       0xD0   0xF8C1 0x0100      STR      R0,[R1, #+256]
    344            psRequestedUart->pBaseAddress->US_RNPR = (unsigned int)((psUartConfig_->pu8RxBufferAddress) + 1);
   \       0xD4   0x6860             LDR      R0,[R4, #+4]
   \       0xD6   0x1C40             ADDS     R0,R0,#+1
   \       0xD8   0x6829             LDR      R1,[R5, #+0]
   \       0xDA   0xF8C1 0x0110      STR      R0,[R1, #+272]
    345            psRequestedUart->pBaseAddress->US_RCR  = 1;
   \       0xDE   0x2001             MOVS     R0,#+1
   \       0xE0   0x6829             LDR      R1,[R5, #+0]
   \       0xE2   0xF8C1 0x0104      STR      R0,[R1, #+260]
    346            psRequestedUart->pBaseAddress->US_RNCR = 1;
   \       0xE6   0x2001             MOVS     R0,#+1
   \       0xE8   0x6829             LDR      R1,[R5, #+0]
   \       0xEA   0xF8C1 0x0114      STR      R0,[R1, #+276]
    347            
    348            /* Enable the receiver and transmitter requests */
    349            psRequestedUart->pBaseAddress->US_PTCR = AT91C_PDC_RXTEN | AT91C_PDC_TXTEN;
   \       0xEE   0xF240 0x1001      MOVW     R0,#+257
   \       0xF2   0x6829             LDR      R1,[R5, #+0]
   \       0xF4   0xF8C1 0x0120      STR      R0,[R1, #+288]
    350          
    351            /* Enable UART interrupts */
    352            NVIC_ClearPendingIRQ( (IRQn_Type)psRequestedUart->u8PeripheralId );
   \       0xF8   0xF995 0x0022      LDRSB    R0,[R5, #+34]
   \       0xFC   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \       0xFE   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    353            NVIC_EnableIRQ( (IRQn_Type)psRequestedUart->u8PeripheralId );
   \      0x102   0xF995 0x0022      LDRSB    R0,[R5, #+34]
   \      0x106   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \      0x108   0x.... 0x....      BL       NVIC_EnableIRQ
    354            
    355            return(psRequestedUart);
   \      0x10C   0x0028             MOVS     R0,R5
   \                     ??UartRequest_6: (+1)
   \      0x10E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    356            
    357          } /* end UartRequest() */
    358          
    359          
    360          /*----------------------------------------------------------------------------------------------------------------------
    361          Function: UartRelease
    362          
    363          Description:
    364          Releases a UART resource.  
    365          
    366          Requires:
    367            - psUartPeripheral_ has the UART peripheral number, address of the RxBuffer, and the RxBuffer size and the calling
    368              application is ready to start using the peripheral.
    369          
    370          Promises:
    371            - Resets peripheral object's pointers and data to safe values
    372            - Peripheral is disabled
    373            - Peripheral interrupts are disabled.
    374          */

   \                                 In section .text, align 2, keep-with-next
    375          void UartRelease(UartPeripheralType* psUartPeripheral_)
    376          {
   \                     UartRelease: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    377            /* Check to see if the peripheral is already released */
    378            if(psUartPeripheral_->pu8RxBuffer == NULL)
   \        0x4   0x6960             LDR      R0,[R4, #+20]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD023             BEQ.N    ??UartRelease_0
    379            {
    380              return;
    381            }
    382            
    383            /* First disable the interrupts */
    384            NVIC_DisableIRQ( (IRQn_Type)(psUartPeripheral_->u8PeripheralId) );
   \                     ??UartRelease_1: (+1)
   \        0xA   0xF994 0x0022      LDRSB    R0,[R4, #+34]
   \        0xE   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \       0x10   0x.... 0x....      BL       NVIC_DisableIRQ
    385            NVIC_ClearPendingIRQ( (IRQn_Type)(psUartPeripheral_->u8PeripheralId) );
   \       0x14   0xF994 0x0022      LDRSB    R0,[R4, #+34]
   \       0x18   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \       0x1A   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    386           
    387            /* Now it's safe to release all of the resources in the target peripheral */
    388            psUartPeripheral_->pu8RxBuffer    = NULL;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6160             STR      R0,[R4, #+20]
    389            psUartPeripheral_->pu8RxNextByte  = NULL;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x61A0             STR      R0,[R4, #+24]
    390            psUartPeripheral_->fnRxCallback   = NULL;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x61E0             STR      R0,[R4, #+28]
    391            psUartPeripheral_->u32PrivateFlags = 0;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x6060             STR      R0,[R4, #+4]
    392          
    393            /* Empty the transmit buffer if there were leftover messages */
    394            while(psUartPeripheral_->psTransmitBuffer != NULL)
   \                     ??UartRelease_2: (+1)
   \       0x2E   0x68A0             LDR      R0,[R4, #+8]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD009             BEQ.N    ??UartRelease_3
    395            {
    396              UpdateMessageStatus(psUartPeripheral_->psTransmitBuffer->u32Token, ABANDONED);
   \       0x34   0x2106             MOVS     R1,#+6
   \       0x36   0x68A0             LDR      R0,[R4, #+8]
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0x.... 0x....      BL       UpdateMessageStatus
    397              DeQueueMessage(&psUartPeripheral_->psTransmitBuffer);
   \       0x3E   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x42   0x.... 0x....      BL       DeQueueMessage
   \       0x46   0xE7F2             B.N      ??UartRelease_2
    398            }
    399            
    400            /* Ensure the SM is in the Idle state */
    401            Uart_pfnStateMachine = UartSM_Idle;
   \                     ??UartRelease_3: (+1)
   \       0x48   0x.... 0x....      ADR.W    R0,UartSM_Idle
   \       0x4C   0x.... 0x....      LDR.W    R1,??DataTable16_11
   \       0x50   0x6008             STR      R0,[R1, #+0]
    402           
    403          } /* end UartRelease() */
   \                     ??UartRelease_0: (+1)
   \       0x52   0xBD10             POP      {R4,PC}          ;; return
    404          
    405          
    406          /*----------------------------------------------------------------------------------------------------------------------
    407          Function: UartWriteByte
    408          
    409          Description:
    410          Queues a single byte for transfer on the target UART peripheral.  
    411          
    412          Requires:
    413            - psUartPeripheral_ has been requested.
    414          
    415          Promises:
    416            - Creates a 1-byte message at psUartPeripheral_->pTransmitBuffer that will be sent by the UART application
    417              when it is available.
    418            - Returns the message token assigned to the message
    419          */

   \                                 In section .text, align 2, keep-with-next
    420          u32 UartWriteByte(UartPeripheralType* psUartPeripheral_, u8 u8Byte_)
    421          {
   \                     UartWriteByte: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
    422            u32 u32Token;
    423            u8 u8Data = u8Byte_;
   \        0x6   0xF88D 0x6000      STRB     R6,[SP, #+0]
    424            
    425            u32Token = QueueMessage(&psUartPeripheral_->psTransmitBuffer, 1, &u8Data);
   \        0xA   0x466A             MOV      R2,SP
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0xF115 0x0008      ADDS     R0,R5,#+8
   \       0x12   0x.... 0x....      BL       QueueMessage
   \       0x16   0x0004             MOVS     R4,R0
    426            if( u32Token != 0 )
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD006             BEQ.N    ??UartWriteByte_0
    427            {
    428              /* If the system is initializing, we want to manually cycle the UART task through one iteration
    429              to send the message */
    430              if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable16_12
   \       0x20   0x6800             LDR      R0,[R0, #+0]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD501             BPL.N    ??UartWriteByte_0
    431              {
    432                UartManualMode();
   \       0x26   0x.... 0x....      BL       UartManualMode
    433              }
    434            }
    435            
    436            return(u32Token);
   \                     ??UartWriteByte_0: (+1)
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    437            
    438          } /* end UartWriteByte() */
    439          
    440          
    441          /*----------------------------------------------------------------------------------------------------------------------
    442          Function: UartWriteData
    443          
    444          Description:
    445          Queues a data array for transfer on the target UART peripheral.  
    446          
    447          Requires:
    448            - psUartPeripheral_ has been requested and holds a valid pointer to a transmit buffer; even if a transmission is
    449              in progress, the node in the buffer that is currently being sent will not be destroyed during this function.
    450            - u32Size_ is the number of bytes in the data array
    451            - u8Data_ points to the first byte of the data array
    452          
    453          Promises:
    454            - adds the data message at psUartPeripheral_->pTransmitBuffer that will be sent by the UART application
    455              when it is available.
    456            - Returns the message token assigned to the message; 0 is returned if the message cannot be queued in which case
    457              G_u32MessagingFlags can be checked for the reason
    458          */

   \                                 In section .text, align 2, keep-with-next
    459          u32 UartWriteData(UartPeripheralType* psUartPeripheral_, u32 u32Size_, u8* u8Data_)
    460          {
   \                     UartWriteData: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0017             MOVS     R7,R2
    461            u32 u32Token;
    462          
    463            u32Token = QueueMessage(&psUartPeripheral_->psTransmitBuffer, u32Size_, u8Data_);
   \        0x8   0x003A             MOVS     R2,R7
   \        0xA   0x0031             MOVS     R1,R6
   \        0xC   0xF115 0x0008      ADDS     R0,R5,#+8
   \       0x10   0x.... 0x....      BL       QueueMessage
   \       0x14   0x0004             MOVS     R4,R0
    464            if(u32Token)
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD005             BEQ.N    ??UartWriteData_0
    465            {
    466              /* If the system is initializing, manually cycle the UART task through one iteration to send the message */
    467              if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \       0x1A   0x....             LDR.N    R0,??DataTable16_12
   \       0x1C   0x6800             LDR      R0,[R0, #+0]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD501             BPL.N    ??UartWriteData_0
    468              {
    469                UartManualMode();
   \       0x22   0x.... 0x....      BL       UartManualMode
    470              }
    471            }
    472            
    473            return(u32Token);
   \                     ??UartWriteData_0: (+1)
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    474            
    475          } /* end UartWriteData() */
    476          
    477          
    478          /*--------------------------------------------------------------------------------------------------------------------*/
    479          /* Protected Functions */
    480          /*--------------------------------------------------------------------------------------------------------------------*/
    481          
    482          /*----------------------------------------------------------------------------------------------------------------------
    483          Function: UartInitialize
    484          
    485          Description:
    486          Initializes the UART application and its variables.  UART0 is setup to be available immediately for debugging
    487          purposes.  The generic peripherals themselves are not fully configured until requested by a calling application.
    488          
    489          Requires:
    490            - 
    491          
    492          Promises:
    493            - UART peripheral objects are ready 
    494            - UART application set to Idle
    495          */

   \                                 In section .text, align 2, keep-with-next
    496          void UartInitialize(void)
    497          {
    498            UART_u32Flags = 0;
   \                     UartInitialize: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x....             LDR.N    R1,??DataTable16_13
   \        0x4   0x6008             STR      R0,[R1, #+0]
    499          
    500          #ifdef USE_SIMPLE_USART0
    501            /* Setup USART0 for use as a basic debug port */
    502            
    503            /* Initialize pointers and clear the receive buffer */
    504            UART_pu8U0RxBufferNextChar   = &UART_au8U0RxBuffer[0];
    505            UART_pu8U0RxBufferUnreadChar = &UART_au8U0RxBuffer[0];
    506            for(u16 i = 0; i < U0RX_BUFFER_SIZE; i++)
    507            {
    508              UART_au8U0RxBuffer[i] = 0;
    509            }
    510          
    511            UART_pu8U0TxBufferNextChar   = &UART_au8U0TxBuffer[0];
    512            UART_pu8U0TxBufferUnsentChar = &UART_au8U0TxBuffer[0];
    513            for(u16 i = 0; i < U0TX_BUFFER_SIZE; i++)
    514            {
    515              UART_au8U0TxBuffer[i] = 0;
    516            }
    517            
    518            /* Activate the US0 clock and set peripheral configuration registers */
    519            AT91C_BASE_PMC->PMC_PCER |= (1 << AT91C_ID_US0);
    520            
    521            AT91C_BASE_US0->US_CR   = USART0_US_CR_INIT;
    522            AT91C_BASE_US0->US_MR   = USART0_US_MR_INIT;
    523            AT91C_BASE_US0->US_IER  = USART0_US_IER_INIT;
    524            AT91C_BASE_US0->US_IDR  = USART0_US_IDR_INIT;
    525            AT91C_BASE_US0->US_BRGR = USART0_US_BRGR_INIT;
    526          
    527            /* Enable U0 interrupts */
    528            NVIC_ClearPendingIRQ(IRQn_US0);
    529            NVIC_EnableIRQ(IRQn_US0);
    530          
    531            /* Print the startup message */
    532            UART_u32Timer = G_u32SystemTime1ms;
    533            pu8Parser = &au8Uart0StartupMsg[0];
    534            while(*pu8Parser != NULL)
    535            {
    536              /* Attempt to queue the character */
    537              if( Uart_putc(*pu8Parser) )
    538              {
    539                /* Advance only if character has been sent */
    540                pu8Parser++;
    541              }
    542                 
    543              /* Watch for timeout */
    544              if( IsTimeUp(&UART_u32Timer, UART_INIT_MSG_TIMEOUT) )
    545              {
    546                break;
    547              }
    548            }
    549          
    550          #if 0
    551            DebugPrintf(au8Uart0StartupMsg);
    552            while(UART_pu8U0TxBufferUnsentChar != UART_pu8U0TxBufferNextChar)
    553            {
    554              UartManualMode();
    555            }
    556          #endif
    557            
    558          #endif /* USE_SIMPLE_USART0 */
    559            
    560            /* Setup generic UARTs */
    561            
    562            /* Initialize the UART peripheral structures */
    563            UART_Peripheral.pBaseAddress     = (AT91S_USART*)AT91C_BASE_DBGU;
   \        0x6   0x....             LDR.N    R0,??DataTable16_3
   \        0x8   0x....             LDR.N    R1,??DataTable16_14  ;; 0x400e0600
   \        0xA   0x6001             STR      R1,[R0, #+0]
    564            UART_Peripheral.psTransmitBuffer = NULL;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x6081             STR      R1,[R0, #+8]
    565            UART_Peripheral.pu8RxBuffer      = NULL;
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x6141             STR      R1,[R0, #+20]
    566            UART_Peripheral.u16RxBufferSize  = 0;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x8401             STRH     R1,[R0, #+32]
    567            UART_Peripheral.pu8RxNextByte    = NULL;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x6181             STR      R1,[R0, #+24]
    568            UART_Peripheral.u32PrivateFlags  = 0;
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x6041             STR      R1,[R0, #+4]
    569            UART_Peripheral.u8PeripheralId  = AT91C_ID_DBGU;
   \       0x20   0x2108             MOVS     R1,#+8
   \       0x22   0xF880 0x1022      STRB     R1,[R0, #+34]
    570          
    571            UART_Peripheral0.pBaseAddress    = AT91C_BASE_US0;
   \       0x26   0x....             LDR.N    R1,??DataTable16_5
   \       0x28   0x....             LDR.N    R2,??DataTable16_15  ;; 0x40090000
   \       0x2A   0x600A             STR      R2,[R1, #+0]
    572            UART_Peripheral0.psTransmitBuffer = NULL;
   \       0x2C   0x2200             MOVS     R2,#+0
   \       0x2E   0x608A             STR      R2,[R1, #+8]
    573            UART_Peripheral0.pu8RxBuffer     = NULL;
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0x614A             STR      R2,[R1, #+20]
    574            UART_Peripheral0.u16RxBufferSize = 0;
   \       0x34   0x2200             MOVS     R2,#+0
   \       0x36   0x840A             STRH     R2,[R1, #+32]
    575            UART_Peripheral0.pu8RxNextByte   = NULL;
   \       0x38   0x2200             MOVS     R2,#+0
   \       0x3A   0x618A             STR      R2,[R1, #+24]
    576            UART_Peripheral0.u32PrivateFlags = 0;
   \       0x3C   0x2200             MOVS     R2,#+0
   \       0x3E   0x604A             STR      R2,[R1, #+4]
    577            UART_Peripheral0.u8PeripheralId  = AT91C_ID_US0;
   \       0x40   0x220D             MOVS     R2,#+13
   \       0x42   0xF881 0x2022      STRB     R2,[R1, #+34]
    578          
    579            UART_Peripheral1.pBaseAddress    = AT91C_BASE_US1;
   \       0x46   0x....             LDR.N    R1,??DataTable16_6
   \       0x48   0x....             LDR.N    R2,??DataTable16_16  ;; 0x40094000
   \       0x4A   0x600A             STR      R2,[R1, #+0]
    580            UART_Peripheral1.psTransmitBuffer = NULL;
   \       0x4C   0x2200             MOVS     R2,#+0
   \       0x4E   0x608A             STR      R2,[R1, #+8]
    581            UART_Peripheral1.pu8RxBuffer     = NULL;
   \       0x50   0x2200             MOVS     R2,#+0
   \       0x52   0x614A             STR      R2,[R1, #+20]
    582            UART_Peripheral1.u16RxBufferSize = 0;
   \       0x54   0x2200             MOVS     R2,#+0
   \       0x56   0x840A             STRH     R2,[R1, #+32]
    583            UART_Peripheral1.pu8RxNextByte   = NULL;
   \       0x58   0x2200             MOVS     R2,#+0
   \       0x5A   0x618A             STR      R2,[R1, #+24]
    584            UART_Peripheral1.u32PrivateFlags = 0;
   \       0x5C   0x2200             MOVS     R2,#+0
   \       0x5E   0x604A             STR      R2,[R1, #+4]
    585            UART_Peripheral1.u8PeripheralId  = AT91C_ID_US1;
   \       0x60   0x220E             MOVS     R2,#+14
   \       0x62   0xF881 0x2022      STRB     R2,[R1, #+34]
    586          
    587            UART_Peripheral2.pBaseAddress    = AT91C_BASE_US2;
   \       0x66   0x....             LDR.N    R1,??DataTable16_8
   \       0x68   0x....             LDR.N    R2,??DataTable16_17  ;; 0x40098000
   \       0x6A   0x600A             STR      R2,[R1, #+0]
    588            UART_Peripheral2.psTransmitBuffer = NULL;
   \       0x6C   0x2200             MOVS     R2,#+0
   \       0x6E   0x608A             STR      R2,[R1, #+8]
    589            UART_Peripheral2.pu8RxBuffer     = NULL;
   \       0x70   0x2200             MOVS     R2,#+0
   \       0x72   0x614A             STR      R2,[R1, #+20]
    590            UART_Peripheral2.u16RxBufferSize = 0;
   \       0x74   0x2200             MOVS     R2,#+0
   \       0x76   0x840A             STRH     R2,[R1, #+32]
    591            UART_Peripheral2.pu8RxNextByte   = NULL;
   \       0x78   0x2200             MOVS     R2,#+0
   \       0x7A   0x618A             STR      R2,[R1, #+24]
    592            UART_Peripheral2.u32PrivateFlags = 0;
   \       0x7C   0x2200             MOVS     R2,#+0
   \       0x7E   0x604A             STR      R2,[R1, #+4]
    593            UART_Peripheral2.u8PeripheralId  = AT91C_ID_US2;
   \       0x80   0x220F             MOVS     R2,#+15
   \       0x82   0xF881 0x2022      STRB     R2,[R1, #+34]
    594            
    595            UART_psCurrentUart               = &UART_Peripheral;
   \       0x86   0x....             LDR.N    R1,??DataTable16_18
   \       0x88   0x6008             STR      R0,[R1, #+0]
    596          //  UART_u32CurrentTxBytesRemaining  = 0;
    597          //  UART_pu8CurrentTxData            = NULL;
    598          
    599            /* Set application pointer */
    600            Uart_pfnStateMachine = UartSM_Idle;
   \       0x8A   0x.... 0x....      ADR.W    R0,UartSM_Idle
   \       0x8E   0x....             LDR.N    R1,??DataTable16_11
   \       0x90   0x6008             STR      R0,[R1, #+0]
    601            
    602          } /* end UartInitialize() */
   \       0x92   0x4770             BX       LR               ;; return
    603          
    604          
    605          /*----------------------------------------------------------------------------------------------------------------------
    606          Function UartRunActiveState()
    607          
    608          Description:
    609          Selects and runs one iteration of the current state in the state machine.
    610          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    611          may take 1ms / n to execute.
    612          
    613          Requires:
    614            - State machine function pointer points at current state
    615          
    616          Promises:
    617            - Calls the function to pointed by the state machine function pointer
    618          */

   \                                 In section .text, align 2, keep-with-next
    619          void UartRunActiveState(void)
    620          {
   \                     UartRunActiveState: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    621            Uart_pfnStateMachine();
   \        0x2   0x....             LDR.N    R0,??DataTable16_11
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x4780             BLX      R0
    622          
    623          } /* end UartRunActiveState */
   \        0x8   0xBD01             POP      {R0,PC}          ;; return
    624          
    625          
    626          
    627          /*--------------------------------------------------------------------------------------------------------------------*/
    628          /* Private functions */
    629          /*--------------------------------------------------------------------------------------------------------------------*/
    630          
    631          #if 0
    632          /*----------------------------------------------------------------------------------------------------------------------
    633          Function: UartFillTxBuffer
    634          
    635          Description:
    636          Fills the UART peripheral buffer with bytes from the current messsage that is sending.  
    637          This function can be called from the UART ISR!
    638          Note: if the implemented processor does not have a FIFO, this function can still be used but will only ever
    639          add one byte to the transmitter.
    640          
    641          Requires:
    642            - The TxBuffer is empty
    643            - psUartPeripheral_ points to the UART peripheral being used.  
    644            - UART_pu8CurrentTxData points to the next byte in the message to be sent
    645            - UART_u32CurrentTxBytesRemaining has an accurate count of the bytes remaining in the message data to be sent
    646            - Transmit interrupts are off
    647          
    648          Promises:
    649            - Data from *UART_pu8CurrentTxData is added to the UART peripheral Tx FIFO until the FIFO is full or there
    650              is no more data to send.
    651          */
    652          static void UartFillTxBuffer(UartPeripheralType* psUartPeripheral_)
    653          {
    654            u8 u8ByteCount = UART_TX_FIFO_SIZE;
    655            
    656            /* Use the active global variables to fill up the transmit FIFO */
    657            while( (u8ByteCount != 0) && (UART_u32CurrentTxBytesRemaining != 0) )
    658            {
    659              psUartPeripheral_->pBaseAddress->US_THR = *UART_pu8CurrentTxData;
    660              UART_pu8CurrentTxData++;
    661              UART_u32CurrentTxBytesRemaining--;
    662              u8ByteCount--;
    663            }
    664              
    665            /* If there are no remaining bytes to load to the TX FIFO, disable the UART transmit 
    666            FIFO empty interrupt */
    667            if(UART_u32CurrentTxBytesRemaining == 0)
    668            {
    669              psUartPeripheral_->pBaseAddress->US_IDR = AT91C_US_TXEMPTY;
    670            }
    671            /* Otherwise make sure transmit interrupts are enabled */
    672            else
    673            {
    674              psUartPeripheral_->pBaseAddress->US_IER = AT91C_US_TXEMPTY;
    675            }
    676            
    677          } /* end UartFillTxBuffer() */
    678          
    679          
    680          /*----------------------------------------------------------------------------------------------------------------------
    681          Function: UartReadRxBuffer
    682          
    683          Description:
    684          Reads all bytes from the UART peripheral Rx FIFO and places them in the application receive buffer.  
    685          This function is only called from the UART ISR so interrupts will be off.
    686          
    687          Requires:
    688            - UART_pu8CurrentTxData points to the next byte in the message to be sent
    689            - UART_u32CurrentTxBytesRemaining has an accurate count of the bytes remaining in the message data to be sent
    690            - Transmit interrupts are off
    691          
    692          Promises:
    693            - All bytes currently in the UART Rx FIFO are read out to the application receive circular buffer.
    694          */
    695          static void UartReadRxBuffer(UartPeripheralType* psTargetUart_) 
    696          {
    697            u8 u8Test;
    698            
    699            /* Read all the bytes in the Rx FIFO */
    700            while(psTargetUart_->pBaseAddress->US_CSR & AT91C_US_RXRDY)
    701            {
    702              u8Test = psTargetUart_->pBaseAddress->US_RHR;
    703              **(psTargetUart_->pu8RxNextByte) = u8Test; 
    704          
    705              /* Safely advance the pointer in the circular buffer */
    706              (*psTargetUart_->pu8RxNextByte)++;
    707              if( *psTargetUart_->pu8RxNextByte >= ( psTargetUart_->pu8RxBuffer + psTargetUart_->u16RxBufferSize ) )
    708              {
    709                *psTargetUart_->pu8RxNextByte = psTargetUart_->pu8RxBuffer; 
    710              }
    711              /* Always zero the current char in the buffer */
    712              **(psTargetUart_->pu8RxNextByte) = 0;
    713            }
    714                
    715          } /* end UartReadRxBuffer() */
    716          #endif
    717          
    718          /*----------------------------------------------------------------------------------------------------------------------
    719          Function: UartManualMode
    720          
    721          Description:
    722          Runs a transmit cycle of the UART application to clock out a message.  This function is used only during
    723          initialization.
    724          
    725          Requires:
    726            - UART application has been initialized.
    727          
    728          Promises:
    729            - All bytes currently in the UART Rx FIFO are read out to the application receive circular buffer.
    730          */

   \                                 In section .text, align 2, keep-with-next
    731          static void UartManualMode(void)
    732          {
   \                     UartManualMode: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    733            UART_u32Flags |=_UART_MANUAL_MODE;
   \        0x2   0x....             LDR.N    R4,??DataTable16_13
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0xF050 0x0001      ORRS     R0,R0,#0x1
   \        0xA   0x6020             STR      R0,[R4, #+0]
    734            UART_psCurrentUart = &UART_Peripheral;
   \        0xC   0x....             LDR.N    R0,??DataTable16_3
   \        0xE   0x....             LDR.N    R1,??DataTable16_18
   \       0x10   0x6008             STR      R0,[R1, #+0]
    735            
    736            while(UART_u32Flags &_UART_MANUAL_MODE)
   \                     ??UartManualMode_0: (+1)
   \       0x12   0x7820             LDRB     R0,[R4, #+0]
   \       0x14   0x07C0             LSLS     R0,R0,#+31
   \       0x16   0xD50A             BPL.N    ??UartManualMode_1
    737            {
    738              Uart_pfnStateMachine();
   \       0x18   0x....             LDR.N    R0,??DataTable16_11
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0x4780             BLX      R0
    739              UART_u32Timer  = G_u32SystemTime1ms;
   \       0x1E   0x....             LDR.N    R0,??DataTable16_19
   \       0x20   0x....             LDR.N    R1,??DataTable16_20
   \       0x22   0x6809             LDR      R1,[R1, #+0]
   \       0x24   0x6001             STR      R1,[R0, #+0]
    740              IsTimeUp(&UART_u32Timer, 1);
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x.... 0x....      BL       IsTimeUp
   \       0x2C   0xE7F1             B.N      ??UartManualMode_0
    741            }
    742                
    743          } /* end UartManualMode() */
   \                     ??UartManualMode_1: (+1)
   \       0x2E   0xBD10             POP      {R4,PC}          ;; return
    744          
    745          
    746          #ifdef USE_SIMPLE_USART0
    747          /*----------------------------------------------------------------------------------------------------------------------
    748          Interrupt Service Routine: UART0_IRQHandler
    749          
    750          Description:
    751          Handles the enabled UART0 interrupts. 
    752          Receive: The UART peripheral is always enabled and ready to receive data.  Receive interrupts will occur when a
    753          new byte has been read by the peripheral. All incoming data is dumped into the circular receive data buffer UART_au8U0RxBuffer.
    754          No processing is done on the data - it is up to the processing application to parse incoming data to find useful information
    755          and to manage dummy bytes.
    756          
    757          Note that if the Rx buffer is not read and U0RX_BUFFER_SIZE characters come in, all data will be lost because of the popinter wrap.
    758          
    759          Transmit: All data bytes in the transmit buffer are immediately sent as fast as the interrupt can process them.
    760          
    761          Requires:
    762            - Only TXEMPTY and RXRDY interrupts are ever enabled
    763            - Transmit and receive buffers should be correctly configured 
    764          
    765          Promises:
    766            - If ENDRX interrupt occurs, the received character is deposited in UART_au8U0RxBuffer
    767            - If ENDTX interrupt occurs, the transmit buffer is checked to see if another character should be queued to the peripheral
    768          */
    769          
    770          void USART0_IrqHandler(void)
    771          {
    772            /* Check which interrupt has occurred */
    773            if(AT91C_BASE_US0->US_CSR & AT91C_US_RXRDY)
    774            {
    775              /* Move the received character into the buffer - clears the RXRDY flag */
    776              *UART_pu8U0RxBufferNextChar = (u8)(AT91C_BASE_US0->US_RHR);
    777              
    778              /* Safely advance the pointer */
    779              UART_pu8U0RxBufferNextChar++;
    780              if(UART_pu8U0RxBufferNextChar == &UART_au8U0RxBuffer[U0RX_BUFFER_SIZE])
    781              {
    782                UART_pu8U0RxBufferNextChar = &UART_au8U0RxBuffer[0];
    783              }
    784            }
    785          #if 0
    786            if(AT91C_BASE_US0->US_CSR & AT91C_US_TXEMPTY)
    787            {
    788              /* If the transmit buffer has more data to send, then queue the next byte */
    789              if(UART_pu8U0TxBufferUnsentChar != UART_pu8U0TxBufferNextChar)
    790              {
    791                /* Queue the next byte */
    792                AT91C_BASE_US0->US_THR = *UART_pu8U0TxBufferUnsentChar;
    793          
    794                /* Safely advance the pointer */
    795                UART_pu8U0TxBufferUnsentChar++;
    796                if(UART_pu8U0TxBufferUnsentChar == &UART_au8U0TxBuffer[U0TX_BUFFER_SIZE])
    797                {
    798                  UART_pu8U0TxBufferUnsentChar = &UART_au8U0TxBuffer[0];
    799                }
    800              }
    801              /* Otherwise all data has been sent */
    802              else
    803              {
    804                UART_u32Flags &= _UART_U0_SENDING;
    805                AT91C_BASE_US0->US_IER = AT91C_US_TXEMPTY;
    806              }
    807            }
    808          #endif
    809          } /* end UART0_IRQHandler() */
    810          #endif /* USE_SIMPLE_USART0 */
    811          
    812          
    813          /*----------------------------------------------------------------------------------------------------------------------
    814          Interrupt Service Routine: UART_IRQHandler
    815          
    816          Description:
    817          Handles the enabled UART interrupts for the current UART. 
    818          
    819          
    820          Requires:
    821            - No other interrupts UART interrupts may be active
    822          
    823          Promises:
    824            - Gets the current interrupt context and proceeds to the Generic handler
    825          */
    826          

   \                                 In section .text, align 2, keep-with-next
    827          void UART_IRQHandler(void)
    828          {
   \                     DBGU_IrqHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    829            /* Set the current ISR pointers to SSP1 targets */
    830            UART_psCurrentISR = &UART_Peripheral;                          /* Current UART ISR */
   \        0x2   0x....             LDR.N    R0,??DataTable16_3
   \        0x4   0x....             LDR.N    R1,??DataTable16_21
   \        0x6   0x6008             STR      R0,[R1, #+0]
    831            UART_pu32ApplicationFlagsISR = &G_u32UartApplicationFlags;     /* Current UART application status flags */
   \        0x8   0x....             LDR.N    R0,??DataTable16_22
   \        0xA   0x....             LDR.N    R1,??DataTable16_23
   \        0xC   0x6008             STR      R0,[R1, #+0]
    832            UART_u32IntCount++;
   \        0xE   0x....             LDR.N    R0,??DataTable16_24
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0x1C49             ADDS     R1,R1,#+1
   \       0x14   0x6001             STR      R1,[R0, #+0]
    833          
    834            /* Go to common SSP interrupt using psCurrentSspISR since the SSP cannot interrupt itself */
    835            UartGenericHandler();
   \       0x16   0x.... 0x....      BL       UartGenericHandler
    836          
    837          } /* end UART_IRQHandler() */
   \       0x1A   0xBD01             POP      {R0,PC}          ;; return
    838          
    839          
    840          /*----------------------------------------------------------------------------------------------------------------------
    841          Interrupt Service Routine: UART0_IRQHandler
    842          
    843          Description:
    844          Handles the enabled UART interrupts for the current UART. 
    845          
    846          
    847          Requires:
    848            - No other interrupts UART interrupts may be active
    849          
    850          Promises:
    851            - Gets the current interrupt context and proceeds to the Generic handler
    852          */
    853          

   \                                 In section .text, align 2, keep-with-next
    854          void UART0_IRQHandler(void)
    855          {
   \                     USART0_IrqHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    856            /* Set the current ISR pointers to SSP1 targets */
    857            UART_psCurrentISR = &UART_Peripheral0;                          /* Current UART ISR */
   \        0x2   0x....             LDR.N    R0,??DataTable16_5
   \        0x4   0x....             LDR.N    R1,??DataTable16_21
   \        0x6   0x6008             STR      R0,[R1, #+0]
    858            UART_pu32ApplicationFlagsISR = &G_u32Uart0ApplicationFlags;     /* Current UART application status flags */
   \        0x8   0x....             LDR.N    R0,??DataTable16_25
   \        0xA   0x....             LDR.N    R1,??DataTable16_23
   \        0xC   0x6008             STR      R0,[R1, #+0]
    859            UART_u32Int0Count++;
   \        0xE   0x....             LDR.N    R0,??DataTable16_26
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0x1C49             ADDS     R1,R1,#+1
   \       0x14   0x6001             STR      R1,[R0, #+0]
    860          
    861            /* Go to common interrupt */
    862            UartGenericHandler();
   \       0x16   0x.... 0x....      BL       UartGenericHandler
    863          
    864          } /* end UART0_IRQHandler() */
   \       0x1A   0xBD01             POP      {R0,PC}          ;; return
    865          
    866          
    867          /*----------------------------------------------------------------------------------------------------------------------
    868          Interrupt Service Routine: UART1_IRQHandler
    869          
    870          Description:
    871          Handles the enabled UART interrupts for the current UART. 
    872          
    873          
    874          Requires:
    875            - No other interrupts UART interrupts may be active
    876          
    877          Promises:
    878            - Gets the current interrupt context and proceeds to the Generic handler
    879          */
    880          

   \                                 In section .text, align 2, keep-with-next
    881          void UART1_IRQHandler(void)
    882          {
   \                     UART1_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    883            /* Set the current ISR pointers to SSP1 targets */
    884            UART_psCurrentISR = &UART_Peripheral1;                          /* Current UART ISR */
   \        0x2   0x....             LDR.N    R0,??DataTable16_6
   \        0x4   0x....             LDR.N    R1,??DataTable16_21
   \        0x6   0x6008             STR      R0,[R1, #+0]
    885            UART_pu32ApplicationFlagsISR = &G_u32Uart1ApplicationFlags;     /* Current UART application status flags */
   \        0x8   0x....             LDR.N    R0,??DataTable16_27
   \        0xA   0x....             LDR.N    R1,??DataTable16_23
   \        0xC   0x6008             STR      R0,[R1, #+0]
    886            UART_u32Int1Count++;
   \        0xE   0x....             LDR.N    R0,??DataTable16_28
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0x1C49             ADDS     R1,R1,#+1
   \       0x14   0x6001             STR      R1,[R0, #+0]
    887          
    888            /* Go to common interrupt */
    889            UartGenericHandler();
   \       0x16   0x.... 0x....      BL       UartGenericHandler
    890          
    891          } /* end UART1_IRQHandler() */
   \       0x1A   0xBD01             POP      {R0,PC}          ;; return
    892          
    893          
    894          /*----------------------------------------------------------------------------------------------------------------------
    895          Interrupt Service Routine: UART2_IRQHandler
    896          
    897          Description:
    898          Handles the enabled UART interrupts for the current UART. 
    899          
    900          
    901          Requires:
    902            - No other interrupts UART interrupts may be active
    903          
    904          Promises:
    905            - Gets the current interrupt context and proceeds to the Generic handler
    906          */
    907          

   \                                 In section .text, align 2, keep-with-next
    908          void UART2_IRQHandler(void)
    909          {
   \                     UART2_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    910            /* Set the current ISR pointers to SSP1 targets */
    911            UART_psCurrentISR = &UART_Peripheral2;                          /* Current UART ISR */
   \        0x2   0x....             LDR.N    R0,??DataTable16_8
   \        0x4   0x....             LDR.N    R1,??DataTable16_21
   \        0x6   0x6008             STR      R0,[R1, #+0]
    912            UART_pu32ApplicationFlagsISR = &G_u32Uart2ApplicationFlags;     /* Current UART application status flags */
   \        0x8   0x....             LDR.N    R0,??DataTable16_29
   \        0xA   0x....             LDR.N    R1,??DataTable16_23
   \        0xC   0x6008             STR      R0,[R1, #+0]
    913            UART_u32Int2Count++;
   \        0xE   0x....             LDR.N    R0,??DataTable16_30
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0x1C49             ADDS     R1,R1,#+1
   \       0x14   0x6001             STR      R1,[R0, #+0]
    914          
    915            /* Go to common interrupt */
    916            UartGenericHandler();
   \       0x16   0x.... 0x....      BL       UartGenericHandler
    917          
    918          } /* end UART2_IRQHandler() */
   \       0x1A   0xBD01             POP      {R0,PC}          ;; return
    919          
    920          
    921          /*----------------------------------------------------------------------------------------------------------------------
    922          Generic Interrupt Service Routine
    923          
    924          Description:
    925          Receive: A requested UART peripheral is always enabled and ready to receive data.  Receive interrupts will occur when a
    926          new byte has been read by the peripheral. All incoming data is dumped into the circular receive data buffer configured.
    927          No processing is done on the data - it is up to the processing application to parse incoming data to find useful information
    928          and to manage dummy bytes.  All data reception is done with DMA, but only 1 byte at a time.  Receiving is done by using
    929          the two reception pointers to ensure no data is missed.
    930          
    931          Transmit: All data bytes in the transmit buffer are sent using DMA and interrupts. Once the full message has been sent,
    932          the message status is updated.
    933          */

   \                                 In section .text, align 2, keep-with-next
    934          void UartGenericHandler(void)
    935          {
   \                     UartGenericHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    936            /* ENDRX Interrupt when a byte has been received (RNCR is moved to RCR; RNPR is copied to RPR))*/
    937            if( (UART_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_ENDRX) && 
    938                (UART_psCurrentISR->pBaseAddress->US_CSR & AT91C_US_ENDRX) )
   \        0x2   0x....             LDR.N    R4,??DataTable16_21
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x6900             LDR      R0,[R0, #+16]
   \        0xA   0x0700             LSLS     R0,R0,#+28
   \        0xC   0xD52D             BPL.N    ??UartGenericHandler_0
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x6940             LDR      R0,[R0, #+20]
   \       0x14   0x0700             LSLS     R0,R0,#+28
   \       0x16   0xD528             BPL.N    ??UartGenericHandler_0
    939            {
    940              /* Flag that a byte has arrived */
    941              *UART_pu32ApplicationFlagsISR |= _UART_RX_COMPLETE;
   \       0x18   0x....             LDR.N    R0,??DataTable16_23
   \       0x1A   0x6801             LDR      R1,[R0, #+0]
   \       0x1C   0x6809             LDR      R1,[R1, #+0]
   \       0x1E   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x22   0x6800             LDR      R0,[R0, #+0]
   \       0x24   0x6001             STR      R1,[R0, #+0]
    942          
    943              /* Update the "next" DMA pointer to the next valid Rx location */
    944              UART_psCurrentISR->pBaseAddress->US_RNPR++;
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0xF8D0 0x0110      LDR      R0,[R0, #+272]
   \       0x2E   0x1C40             ADDS     R0,R0,#+1
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x6809             LDR      R1,[R1, #+0]
   \       0x34   0xF8C1 0x0110      STR      R0,[R1, #+272]
    945              if(UART_psCurrentISR->pBaseAddress->US_RNPR == (u32)(UART_psCurrentISR->pu8RxBuffer + (u32)UART_psCurrentISR->u16RxBufferSize) )
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x6800             LDR      R0,[R0, #+0]
   \       0x3C   0xF8D0 0x0110      LDR      R0,[R0, #+272]
   \       0x40   0x6821             LDR      R1,[R4, #+0]
   \       0x42   0x6949             LDR      R1,[R1, #+20]
   \       0x44   0x6822             LDR      R2,[R4, #+0]
   \       0x46   0x8C12             LDRH     R2,[R2, #+32]
   \       0x48   0x4411             ADD      R1,R1,R2
   \       0x4A   0x4288             CMP      R0,R1
   \       0x4C   0xD105             BNE.N    ??UartGenericHandler_1
    946              {
    947                UART_psCurrentISR->pBaseAddress->US_RNPR = (u32)UART_psCurrentISR->pu8RxBuffer;  /* !!!!! CHECK */
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x6940             LDR      R0,[R0, #+20]
   \       0x52   0x6821             LDR      R1,[R4, #+0]
   \       0x54   0x6809             LDR      R1,[R1, #+0]
   \       0x56   0xF8C1 0x0110      STR      R0,[R1, #+272]
    948              }
    949          
    950              /* Invoke the callback */
    951              UART_psCurrentISR->fnRxCallback();
   \                     ??UartGenericHandler_1: (+1)
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x69C0             LDR      R0,[R0, #+28]
   \       0x5E   0x4780             BLX      R0
    952              
    953              /* Write RNCR to 1 to clear the ENDRX flag */
    954              UART_psCurrentISR->pBaseAddress->US_RNCR = 1;
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0x6821             LDR      R1,[R4, #+0]
   \       0x64   0x6809             LDR      R1,[R1, #+0]
   \       0x66   0xF8C1 0x0114      STR      R0,[R1, #+276]
    955            }
    956          
    957            
    958            /* ENDTX Interrupt when all requested transmit bytes have been sent (if enabled) */
    959            if( (UART_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_ENDTX) && 
    960                (UART_psCurrentISR->pBaseAddress->US_CSR & AT91C_US_ENDTX) )
   \                     ??UartGenericHandler_0: (+1)
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6800             LDR      R0,[R0, #+0]
   \       0x6E   0x6900             LDR      R0,[R0, #+16]
   \       0x70   0x06C0             LSLS     R0,R0,#+27
   \       0x72   0xD529             BPL.N    ??UartGenericHandler_2
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x6800             LDR      R0,[R0, #+0]
   \       0x78   0x6940             LDR      R0,[R0, #+20]
   \       0x7A   0x06C0             LSLS     R0,R0,#+27
   \       0x7C   0xD524             BPL.N    ??UartGenericHandler_2
    961            {
    962              /* Update this message token status and then DeQueue it */
    963              UpdateMessageStatus(UART_psCurrentISR->psTransmitBuffer->u32Token, COMPLETE);
   \       0x7E   0x2104             MOVS     R1,#+4
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x6880             LDR      R0,[R0, #+8]
   \       0x84   0x6800             LDR      R0,[R0, #+0]
   \       0x86   0x.... 0x....      BL       UpdateMessageStatus
    964              DeQueueMessage( &UART_psCurrentISR->psTransmitBuffer );
   \       0x8A   0x6820             LDR      R0,[R4, #+0]
   \       0x8C   0x3008             ADDS     R0,R0,#+8
   \       0x8E   0x.... 0x....      BL       DeQueueMessage
    965              UART_psCurrentISR->u32PrivateFlags &= ~_UART_PERIPHERAL_TX;
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x6840             LDR      R0,[R0, #+4]
   \       0x96   0xF430 0x1000      BICS     R0,R0,#0x200000
   \       0x9A   0x6821             LDR      R1,[R4, #+0]
   \       0x9C   0x6048             STR      R0,[R1, #+4]
    966                  
    967              /* Disable the transmitter and interrupt source */
    968              UART_psCurrentISR->pBaseAddress->US_PTCR = AT91C_PDC_TXTDIS;
   \       0x9E   0xF44F 0x7000      MOV      R0,#+512
   \       0xA2   0x6821             LDR      R1,[R4, #+0]
   \       0xA4   0x6809             LDR      R1,[R1, #+0]
   \       0xA6   0xF8C1 0x0120      STR      R0,[R1, #+288]
    969              UART_psCurrentISR->pBaseAddress->US_IDR  = AT91C_US_ENDTX;
   \       0xAA   0x2010             MOVS     R0,#+16
   \       0xAC   0x6821             LDR      R1,[R4, #+0]
   \       0xAE   0x6809             LDR      R1,[R1, #+0]
   \       0xB0   0x60C8             STR      R0,[R1, #+12]
    970              
    971              /* Decrement # of active UARTs */
    972              if(UART_u8ActiveUarts != 0)
   \       0xB2   0x....             LDR.N    R1,??DataTable16_31
   \       0xB4   0x7808             LDRB     R0,[R1, #+0]
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD003             BEQ.N    ??UartGenericHandler_3
    973              {
    974                UART_u8ActiveUarts--;
   \       0xBA   0x7808             LDRB     R0,[R1, #+0]
   \       0xBC   0x1E40             SUBS     R0,R0,#+1
   \       0xBE   0x7008             STRB     R0,[R1, #+0]
   \       0xC0   0xE002             B.N      ??UartGenericHandler_2
    975              }
    976              else
    977              {
    978                /* If UART_u8ActiveUarts is already 0, then we are not properly synchronized */
    979                DebugPrintf("\n\rUART counter out of sync\n\r");
   \                     ??UartGenericHandler_3: (+1)
   \       0xC2   0x....             LDR.N    R0,??DataTable16_32
   \       0xC4   0x.... 0x....      BL       DebugPrintf
    980              }
    981            }
    982            
    983          } /* end SspGenericHandler() */
   \                     ??UartGenericHandler_2: (+1)
   \       0xC8   0xBD10             POP      {R4,PC}          ;; return
    984          
    985          
    986          /***********************************************************************************************************************
    987          State Machine Function Definitions
    988          
    989          The UART state machine monitors messaging activity on the available UART peripherals.  It manages outgoing messages and will
    990          transmit any bytes that has been queued.  Only one message will be transferred at once (e.g. UART1 and UART2 will not both 
    991          send at the same time, though both peripherals will continue to receive simultaneously).
    992          Since all transmit and receive bytes are transferred using interrupts, the SM does not have to worry about prioritizing.
    993          
    994          Transmitting on USART 0:
    995          When UART_pu8U0TxBufferUnsentChar doesn't match UART_pu8U0TxBufferNextChar, then we know that there is data to send.
    996          Data transfer is initiated by writing the first byte and setting the _UART_U0_SENDING flag to keep the USART state machine 
    997          busy sending all of the current data on the USART.  The interrupt service routine will be responsible for clearing the
    998          bit which will allow the SM to return to Idle.  
    999          
   1000          Receiving on USART 0:
   1001          Since the UART can only talk to one device, we will hard-code some of the functionality.  Reception of bytes will
   1002          simply dump into the UartRxBuffer and the task interested in those bytes can read the data.  In this case, we
   1003          know that this is only the Debug / User interface task.  Though other tasks could also access the buffer, we
   1004          assume they won't.
   1005          
   1006          ***********************************************************************************************************************/
   1007          
   1008          /*-------------------------------------------------------------------------------------------------------------------*/
   1009          /* Wait for a transmit message to be queued.  Received data is handled in interrupts. */

   \                                 In section .text, align 4, keep-with-next
   1010          void UartSM_Idle(void)
   1011          {
   \                     UartSM_Idle: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1012          #if USE_SIMPLE_USART0
   1013            u8 u8Temp;
   1014          
   1015            /* Send on the debug UART */
   1016            if( (UART_pu8U0TxBufferUnsentChar != UART_pu8U0TxBufferNextChar) && !(UART_u32Flags & _UART_U0_SENDING) )
   1017            {
   1018              /* Flag that a send on U0 is in progress */
   1019              UART_u32Flags |= _UART_U0_SENDING;
   1020              
   1021              /* Get a copy of the next byte and safely advance the pointer */
   1022              u8Temp = *UART_pu8U0TxBufferUnsentChar;
   1023              UART_pu8U0TxBufferUnsentChar++;
   1024              if(UART_pu8U0TxBufferUnsentChar == &UART_au8U0TxBuffer[U0TX_BUFFER_SIZE])
   1025              {
   1026                UART_pu8U0TxBufferUnsentChar = &UART_au8U0TxBuffer[0];
   1027              }
   1028              
   1029              /* Queue the next byte and enable the Tx interrupt */
   1030              AT91C_BASE_US0->US_THR = u8Temp;
   1031              AT91C_BASE_US0->US_IER = AT91C_US_TXEMPTY;
   1032            }
   1033          #endif /* USE_SIMPLE_USART0 */
   1034          
   1035            /* Check all UART peripherals for message activity or skip the current peripheral if it is already busy sending.
   1036            All receive functions take place outside of the state machine.
   1037            Devices sending a message will have UART_psCurrentSsp->psTransmitBuffer->pu8Message pointing to the message to send. */
   1038            if( (UART_psCurrentUart->psTransmitBuffer != NULL) && 
   1039               !(UART_psCurrentUart->u32PrivateFlags & _UART_PERIPHERAL_TX ) )
   \        0x2   0x....             LDR.N    R4,??DataTable16_18
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6880             LDR      R0,[R0, #+8]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD02B             BEQ.N    ??UartSM_Idle_0
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x6840             LDR      R0,[R0, #+4]
   \       0x10   0x0280             LSLS     R0,R0,#+10
   \       0x12   0xD427             BMI.N    ??UartSM_Idle_0
   1040            {
   1041              /* Transmitting: update the message's status and flag that the peripheral is now busy */
   1042              UpdateMessageStatus(UART_psCurrentUart->psTransmitBuffer->u32Token, SENDING);
   \       0x14   0x2102             MOVS     R1,#+2
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6880             LDR      R0,[R0, #+8]
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0x.... 0x....      BL       UpdateMessageStatus
   1043              UART_psCurrentUart->u32PrivateFlags |= _UART_PERIPHERAL_TX;    
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x6840             LDR      R0,[R0, #+4]
   \       0x24   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \       0x28   0x6821             LDR      R1,[R4, #+0]
   \       0x2A   0x6048             STR      R0,[R1, #+4]
   1044                
   1045              /* Load the PDC counter and pointer registers */
   1046              UART_psCurrentUart->pBaseAddress->US_TPR = (unsigned int)UART_psCurrentUart->psTransmitBuffer->pu8Message; /* CHECK */
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6880             LDR      R0,[R0, #+8]
   \       0x30   0x3008             ADDS     R0,R0,#+8
   \       0x32   0x6821             LDR      R1,[R4, #+0]
   \       0x34   0x6809             LDR      R1,[R1, #+0]
   \       0x36   0xF8C1 0x0108      STR      R0,[R1, #+264]
   1047              UART_psCurrentUart->pBaseAddress->US_TCR = UART_psCurrentUart->psTransmitBuffer->u32Size;
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x6880             LDR      R0,[R0, #+8]
   \       0x3E   0x6840             LDR      R0,[R0, #+4]
   \       0x40   0x6821             LDR      R1,[R4, #+0]
   \       0x42   0x6809             LDR      R1,[R1, #+0]
   \       0x44   0xF8C1 0x010C      STR      R0,[R1, #+268]
   1048          
   1049              /* When TCR is loaded, the ENDTX flag is cleared so it is safe to enable the interrupt */
   1050              UART_psCurrentUart->pBaseAddress->US_IER = AT91C_US_ENDTX;
   \       0x48   0x2010             MOVS     R0,#+16
   \       0x4A   0x6821             LDR      R1,[R4, #+0]
   \       0x4C   0x6809             LDR      R1,[R1, #+0]
   \       0x4E   0x6088             STR      R0,[R1, #+8]
   1051              
   1052              /* Update active UART count and enable the transmitter to start the transfer */
   1053              UART_u8ActiveUarts++;
   \       0x50   0x....             LDR.N    R0,??DataTable16_31
   \       0x52   0x7801             LDRB     R1,[R0, #+0]
   \       0x54   0x1C49             ADDS     R1,R1,#+1
   \       0x56   0x7001             STRB     R1,[R0, #+0]
   1054              UART_psCurrentUart->pBaseAddress->US_PTCR = AT91C_PDC_TXTEN;
   \       0x58   0xF44F 0x7080      MOV      R0,#+256
   \       0x5C   0x6821             LDR      R1,[R4, #+0]
   \       0x5E   0x6809             LDR      R1,[R1, #+0]
   \       0x60   0xF8C1 0x0120      STR      R0,[R1, #+288]
   1055            }
   1056            
   1057            /* Adjust to check the next peripheral next time through */
   1058            switch (UART_psCurrentUart->u8PeripheralId)
   \                     ??UartSM_Idle_0: (+1)
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0xF890 0x0022      LDRB     R0,[R0, #+34]
   \       0x6A   0x2808             CMP      R0,#+8
   \       0x6C   0xD006             BEQ.N    ??UartSM_Idle_1
   \       0x6E   0x280D             CMP      R0,#+13
   \       0x70   0xD007             BEQ.N    ??UartSM_Idle_2
   \       0x72   0x280E             CMP      R0,#+14
   \       0x74   0xD008             BEQ.N    ??UartSM_Idle_3
   \       0x76   0x280F             CMP      R0,#+15
   \       0x78   0xD009             BEQ.N    ??UartSM_Idle_4
   \       0x7A   0xE018             B.N      ??UartSM_Idle_5
   1059            {
   1060              case AT91C_ID_DBGU:
   1061                UART_psCurrentUart = &UART_Peripheral0;
   \                     ??UartSM_Idle_1: (+1)
   \       0x7C   0x....             LDR.N    R0,??DataTable16_5
   \       0x7E   0x6020             STR      R0,[R4, #+0]
   1062                break;
   \       0x80   0xE017             B.N      ??UartSM_Idle_6
   1063          
   1064              case AT91C_ID_US0:
   1065                UART_psCurrentUart = &UART_Peripheral1;
   \                     ??UartSM_Idle_2: (+1)
   \       0x82   0x....             LDR.N    R0,??DataTable16_6
   \       0x84   0x6020             STR      R0,[R4, #+0]
   1066                break;
   \       0x86   0xE014             B.N      ??UartSM_Idle_6
   1067          
   1068              case AT91C_ID_US1:
   1069                UART_psCurrentUart = &UART_Peripheral2;
   \                     ??UartSM_Idle_3: (+1)
   \       0x88   0x....             LDR.N    R0,??DataTable16_8
   \       0x8A   0x6020             STR      R0,[R4, #+0]
   1070                break;
   \       0x8C   0xE011             B.N      ??UartSM_Idle_6
   1071          
   1072              case AT91C_ID_US2:
   1073                UART_psCurrentUart = &UART_Peripheral;
   \                     ??UartSM_Idle_4: (+1)
   \       0x8E   0x....             LDR.N    R0,??DataTable16_3
   \       0x90   0x6020             STR      R0,[R4, #+0]
   1074                
   1075                /* Only clear _UART_MANUAL_MODE if all UARTs are done sending to ensure messages are sent during initialization */
   1076                if( (G_u32SystemFlags & _SYSTEM_INITIALIZING) && !UART_u8ActiveUarts)
   \       0x92   0x....             LDR.N    R0,??DataTable16_12
   \       0x94   0x6800             LDR      R0,[R0, #+0]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD508             BPL.N    ??UartSM_Idle_7
   \       0x9A   0x....             LDR.N    R0,??DataTable16_31
   \       0x9C   0x7800             LDRB     R0,[R0, #+0]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD104             BNE.N    ??UartSM_Idle_7
   1077                {
   1078                  UART_u32Flags &= ~_UART_MANUAL_MODE;
   \       0xA2   0x....             LDR.N    R0,??DataTable16_13
   \       0xA4   0x6801             LDR      R1,[R0, #+0]
   \       0xA6   0x0849             LSRS     R1,R1,#+1
   \       0xA8   0x0049             LSLS     R1,R1,#+1
   \       0xAA   0x6001             STR      R1,[R0, #+0]
   1079                }
   1080                break;
   \                     ??UartSM_Idle_7: (+1)
   \       0xAC   0xE001             B.N      ??UartSM_Idle_6
   1081          
   1082              default:
   1083                UART_psCurrentUart = &UART_Peripheral;
   \                     ??UartSM_Idle_5: (+1)
   \       0xAE   0x....             LDR.N    R0,??DataTable16_3
   \       0xB0   0x6020             STR      R0,[R4, #+0]
   1084                break;
   1085            } /* end switch */
   1086            
   1087          } /* end UartSM_Idle() */
   \                     ??UartSM_Idle_6: (+1)
   \       0xB2   0xBD10             POP      {R4,PC}          ;; return
   1088          
   1089          
   1090          #ifdef USE_SIMPLE_USART0        
   1091          /*-------------------------------------------------------------------------------------------------------------------*/
   1092          /* Transmit in progress until current bytes have reached 0.  On exit, the transmit message must be dequeued.
   1093          */
   1094          void UartSM_Transmitting(void)
   1095          {
   1096            /* Check if all of the message bytes have completely finished sending */
   1097            if( (UART_u32CurrentTxBytesRemaining == 0) && 
   1098                (UART_psCurrentUart->pBaseAddress->US_IER & AT91C_US_TXEMPTY) )
   1099            {
   1100              /* Update the status queue and then dequeue the message */
   1101              UpdateMessageStatus(UART_psCurrentUart->pTransmitBuffer->u32Token, COMPLETE);
   1102              DeQueueMessage(&UART_psCurrentUart->pTransmitBuffer);
   1103          
   1104              /* Make sure _UART_INIT_MODE flag is clear in case this was a manual cycle */
   1105              UART_u32Flags &= ~_UART_INIT_MODE;
   1106              Uart_pfnStateMachine = UartSM_Idle;
   1107            }
   1108              
   1109          } /* end UartSM_Transmitting() */
   1110          #endif /* USE_SIMPLE_USART0 */
   1111          
   1112          /*-------------------------------------------------------------------------------------------------------------------*/
   1113          /* Handle an error */

   \                                 In section .text, align 2, keep-with-next
   1114          void UartSM_Error(void)          
   1115          {
   1116            UART_u32Flags &= ~UART_ERROR_FLAG_MASK;
   \                     UartSM_Error: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_13
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF021 0x417F      BIC      R1,R1,#0xFF000000
   \        0x8   0x6001             STR      R1,[R0, #+0]
   1117            
   1118            Uart_pfnStateMachine = UartSM_Idle;
   \        0xA   0x....             LDR.N    R0,??DataTable16_33
   \        0xC   0x....             LDR.N    R1,??DataTable16_11
   \        0xE   0x6008             STR      R0,[R1, #+0]
   1119            
   1120          } /* end UartSM_Error() */
   \       0x10   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0xE000'E180        DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0xE000'E280        DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \        0x0   0x....'....        DC32     UART_Peripheral

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \        0x0   0x0040'08C0        DC32     0x4008c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \        0x0   0x....'....        DC32     UART_Peripheral0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \        0x0   0x....'....        DC32     UART_Peripheral1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \        0x0   0x0045'18CE        DC32     0x4518ce

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \        0x0   0x....'....        DC32     UART_Peripheral2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \        0x0   0x0041'18FF        DC32     0x4118ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \        0x0   0x400E'0410        DC32     0x400e0410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \        0x0   0x....'....        DC32     Uart_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \        0x0   0x....'....        DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \        0x0   0x....'....        DC32     UART_u32Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \        0x0   0x400E'0600        DC32     0x400e0600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \        0x0   0x4009'0000        DC32     0x40090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \        0x0   0x4009'4000        DC32     0x40094000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_17:
   \        0x0   0x4009'8000        DC32     0x40098000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_18:
   \        0x0   0x....'....        DC32     UART_psCurrentUart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_19:
   \        0x0   0x....'....        DC32     UART_u32Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_20:
   \        0x0   0x....'....        DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_21:
   \        0x0   0x....'....        DC32     UART_psCurrentISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_22:
   \        0x0   0x....'....        DC32     G_u32UartApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_23:
   \        0x0   0x....'....        DC32     UART_pu32ApplicationFlagsISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_24:
   \        0x0   0x....'....        DC32     UART_u32IntCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_25:
   \        0x0   0x....'....        DC32     G_u32Uart0ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_26:
   \        0x0   0x....'....        DC32     UART_u32Int0Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_27:
   \        0x0   0x....'....        DC32     G_u32Uart1ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_28:
   \        0x0   0x....'....        DC32     UART_u32Int1Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_29:
   \        0x0   0x....'....        DC32     G_u32Uart2ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_30:
   \        0x0   0x....'....        DC32     UART_u32Int2Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_31:
   \        0x0   0x....'....        DC32     UART_u8ActiveUarts

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_32:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_33:
   \        0x0   0x....'....        DC32     UartSM_Idle

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x0A 0x0D          DC8 "\012\015UART counter out of sync\012\015"
   \              0x55 0x41    
   \              0x52 0x54    
   \              0x20 0x63    
   \              0x6F 0x75    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x20 0x6F    
   \              0x75 0x74    
   \              0x20 0x6F    
   \              0x66 0x20    
   \              0x73 0x79    
   \              0x6E 0x63    
   \              0x0A 0x0D    
   \              0x00         
   \       0x1D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1121          
   1122                    
   1123                    
   1124                    
   1125                    
   1126                  
   1127          /*--------------------------------------------------------------------------------------------------------------------*/
   1128          /* End of File */
   1129          /*--------------------------------------------------------------------------------------------------------------------*/
   1130          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DBGU_IrqHandler
         8   -> UartGenericHandler
       0   NVIC_ClearPendingIRQ
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       8   UART1_IRQHandler
         8   -> UartGenericHandler
       8   UART2_IRQHandler
         8   -> UartGenericHandler
       8   USART0_IrqHandler
         8   -> UartGenericHandler
       8   UartGenericHandler
         8   -- Indirect call
         8   -> DeQueueMessage
         8   -> DebugPrintf
         8   -> UpdateMessageStatus
       0   UartInitialize
       8   UartManualMode
         8   -- Indirect call
         8   -> IsTimeUp
       8   UartRelease
         8   -> DeQueueMessage
         8   -> NVIC_ClearPendingIRQ
         8   -> NVIC_DisableIRQ
         8   -> UpdateMessageStatus
      32   UartRequest
        32   -> NVIC_ClearPendingIRQ
        32   -> NVIC_EnableIRQ
       8   UartRunActiveState
         8   -- Indirect call
       0   UartSM_Error
       8   UartSM_Idle
         8   -> UpdateMessageStatus
      24   UartWriteByte
        24   -> QueueMessage
        24   -> UartManualMode
      24   UartWriteData
        24   -> QueueMessage
        24   -> UartManualMode


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_20
       4  ??DataTable16_21
       4  ??DataTable16_22
       4  ??DataTable16_23
       4  ??DataTable16_24
       4  ??DataTable16_25
       4  ??DataTable16_26
       4  ??DataTable16_27
       4  ??DataTable16_28
       4  ??DataTable16_29
       4  ??DataTable16_3
       4  ??DataTable16_30
       4  ??DataTable16_31
       4  ??DataTable16_32
       4  ??DataTable16_33
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
      32  ?_0
      28  DBGU_IrqHandler
       4  G_u32Uart0ApplicationFlags
       4  G_u32Uart1ApplicationFlags
       4  G_u32Uart2ApplicationFlags
       4  G_u32UartApplicationFlags
      24  NVIC_ClearPendingIRQ
      24  NVIC_DisableIRQ
      24  NVIC_EnableIRQ
      28  UART1_IRQHandler
      28  UART2_IRQHandler
      36  UART_Peripheral
      36  UART_Peripheral0
      36  UART_Peripheral1
      36  UART_Peripheral2
       4  UART_psCurrentISR
       4  UART_psCurrentUart
       4  UART_pu32ApplicationFlagsISR
       4  UART_u32Flags
       4  UART_u32Int0Count
       4  UART_u32Int1Count
       4  UART_u32Int2Count
       4  UART_u32IntCount
       4  UART_u32Timer
       1  UART_u8ActiveUarts
      28  USART0_IrqHandler
     202  UartGenericHandler
     148  UartInitialize
      48  UartManualMode
      84  UartRelease
     274  UartRequest
      10  UartRunActiveState
      18  UartSM_Error
     180  UartSM_Idle
      46  UartWriteByte
      42  UartWriteData
       4  Uart_pfnStateMachine

 
   201 bytes in section .bss
    32 bytes in section .rodata
 1 372 bytes in section .text
 
 1 372 bytes of CODE  memory
    32 bytes of CONST memory
   201 bytes of DATA  memory

Errors: none
Warnings: none
